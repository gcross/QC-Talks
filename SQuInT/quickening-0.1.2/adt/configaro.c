#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "configaro.h"
#include "log.h"
#include "socket_printf.h"
#include <assert.h>
#include <ctype.h>
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif

void configaro_boolean(const char *value, 
                       void *pb) {
  boolean *p = (boolean *)pb;
  if(strncasecmp("False", value, 5) == 0) {
    *p = FALSE; 
  } else if(strncasecmp("True", value, 4) == 0) {
    *p = TRUE;
  } else {
    printf("unable to parse configuration that should be boolean "
           "(true or fase) but is '%s'\n", value);
    exit(EXIT_FAILURE);
  }
}

void configaro_header(const char *value,
                      UNUSED(void *pb)) FUNCATTR_NORETURN;
void configaro_header(const char *value,
                      UNUSED(void *pb)) {
  printf("This value should not be set at all, least of all to %s.\n", 
         value);
  exit(EXIT_FAILURE);
}

static const char *
sprint_default(const struct configaro *cf, 
               /*@returned@*//*@out@*/ char *buf, int buflen) {
  if(cf->cb == commando_strdup) {
    sprintf(buf, "%.*s", buflen,
            (cf->value_address != NULL && 
             *((const char **)cf->value_address) != NULL) ? 
            *(const char **)cf->value_address : "");
  } else if(cf->cb == configaro_boolean) {
      sprintf(buf, "%.*s", buflen,
            *(boolean *)cf->value_address ? "True" : "False");
  } else if(cf->cb == commando_int) {
    sprintf(buf, "%d", *(int *)cf->value_address);
  } else if(cf->cb == commando_boolean) {
    fprintf(stderr, 
            "SORRY; most use commando_x, but booleans need to "
            "use configaro_boolean.\n");
    exit(EXIT_FAILURE);
  } else if(cf->cb == configaro_header) {
    buf[0] = '\0';
  } else {
    if(buflen > 14) {
      sprintf(buf, "%.*s", buflen, "<< UNKNOWN TYPE >> ");
    }
  }
  return(buf);
}

static char *
escapetex(/*@notnull@*/ const char *orig) {
  char *ret = malloc(2*strlen(orig));
  int i,j;
  assert(ret != NULL);
  for(i=0, j=0; orig[i]!= '\0'; i++, j++) {
    /* prefixes */
    if(orig[i] == '_' || orig[i] == '#' || orig[i] == '&')
      ret[j++] = '\\'; 
    if(orig[i] == '<')
      ret[j++] = '$'; 

    /* replacements */
    if(orig[i] == '"' && isalpha((int) orig[i+1])) {
      ret[j++] = '`'; 
      ret[j] = '`'; 
    } else if(orig[i] == '\'' && !isspace((int) orig[i+1])) {
      ret[j] = '`'; 
    } else
      ret[j]=orig[i];  /* do it. */
    
    /* suffixes */
    if(orig[i] == '<')
      ret[++j] = '$'; 
  }
  ret[j] = '\0';
  return ret;
}

void 
configaro_write_tex_description(struct configaro *cfg,
                                const char *texfilename,
                                int argc,
                                char **argv) { 
  int i;
  FILE *fpTex;
  fpTex = fopen(texfilename, "w");
  if(fpTex == NULL) exit(EXIT_FAILURE);
  fprintf(fpTex, "%% configuration file documentation generated by\n");
  fprintf(fpTex, "%%");
  for(i=0; i < argc; i++) {
    fprintf(fpTex, " %s", argv[i]);
  }
  fprintf(fpTex, "\n");
  for(i=0; cfg[i].description != NULL; i++) {
    // int prefixlen = strchr(cfg[i].name, '.') - cfg[i].name;
#define DEF_BUF_LEN 300
    char buf[DEF_BUF_LEN];
    char *escapedDesc, *escapedDefault;

    if(cfg[i].cb == configaro_header) {
      if(i != 0) fprintf(fpTex, "\\end{desc}\n");
      escapedDesc = escapetex(cfg[i].description);
      fprintf(fpTex, "\\subsection{%s}\n", cfg[i].name);
      fprintf(fpTex, "\n%s\n", escapedDesc);
      fprintf(fpTex, "\\begin{desc}\n");
      free(escapedDesc);
    } else {
    /*     if(i==0) {
      fprintf(fpTex, "\\paragraph{%.*s}\n", prefixlen, cfg[i].name);
      fprintf(fpTex, "\\begin{desc}\n");
    } else if(strncmp(cfg[i].name, cfg[i-1].name, prefixlen) != 0) {
      fprintf(fpTex, "\\end{desc}\n");
      fprintf(fpTex, "\\paragraph{%.*s}\n", prefixlen, cfg[i].name);
      fprintf(fpTex, "\\begin{desc}\n");
      } */
      escapedDesc = escapetex(cfg[i].description);
      escapedDefault = escapetex(sprint_default(&cfg[i], buf, DEF_BUF_LEN));
      fprintf(fpTex, "\\item[\\parbox{\\columnwidth}"
              "{{\\lstinline!%s!}~~~~~~\\hfill \\rm{%s}}]\n"
              "   %s\n\n", cfg[i].name, 
              escapedDefault,
              escapedDesc);
      if(escapedDesc) free(escapedDesc);
      if(escapedDefault) free(escapedDefault);
    }
  }
  fprintf(fpTex, "\\end{desc}\n");
  fclose(fpTex);
}

void 
configaro_write_default_config_file(struct configaro *cfg, 
                                     const char * filename) {
  int i;
  FILE *fpDefaultcfg;
  boolean piping = FALSE;

  if( strcmp(filename, "-") == 0) {
    fpDefaultcfg = stdout;
  } else {
    fpDefaultcfg = fopen(filename, "w");
  }

  if(fpDefaultcfg == NULL) return;
  
  for(i=0; cfg[i].description != NULL; i++) {
    const char *newline, *start;
    char buf[DEF_BUF_LEN];
    char *desc;

    if(cfg[i].cb == configaro_header) {
      fprintf(fpDefaultcfg, 
              "####################### %s ################\n", 
              cfg[i].name);
    }

    start = desc = fmt_buffer(cfg[i].description, 60);
    /* valgrind doesn't much care for the next line.
       I believe index is implemented as an unsigned int
       skipping thing, and the few uninitialized bytes off 
       the end make  valgrind complain without being real problems. */
    newline = index(desc, '\n'); 
    for( ;
        newline != NULL; 
        start = newline + 1, newline = index(start, '\n')) {
      fprintf(fpDefaultcfg, "## %.*s", (int)(newline-start)+1, start);
    } 
    fprintf(fpDefaultcfg, "## %s\n", start);
    free(desc); desc=NULL;
    if(cfg[i].cb != configaro_header)
      fprintf(fpDefaultcfg, "%s%s = %s\n", 
              cfg[i].custom ? "" : "#", cfg[i].name,
              sprint_default(&cfg[i], buf, DEF_BUF_LEN));
    
    fprintf(fpDefaultcfg, "\n\n");
  }
  if(piping) 
    pclose(fpDefaultcfg);
  else
    fclose(fpDefaultcfg);
}

void 
configaro_set(struct configaro *cfg, const char *name, const char *value) {
  unsigned int i;
  for(i=0; cfg[i].description != NULL; i++) {
    if(strcmp(name, cfg[i].name) == 0) {
      // printf("setting config '%s' = '%s'\n", name, value);
      cfg[i].cb(value, cfg[i].value_address);
      cfg[i].custom = TRUE;
      return;
    }
  }
  log_print(LOG_WARNING, "ERROR: Attempted to set unknown value %s to %s\n", 
            name, value);
}

boolean 
configaro_is_customized(const struct configaro *cfg, const char *name) {
  unsigned int i;
  for(i=0; cfg[i].description != NULL; i++) {
    if(strcmp(name, cfg[i].name) == 0) {
      return cfg[i].custom;
    }
  }
  return FALSE;
}

boolean 
configaro_load_configuration(struct configaro *cfg, 
                             const char * filename) {
  FILE *fpConf = fopen(filename, "r");
  char buf[1024];
  if(fpConf == NULL) return FALSE;
  while( fgets(buf, 1023, fpConf) != NULL ) {
    char *name, *value, *endname, *endvalue;
    if(buf[0] == '#') continue;
    if(buf[0] == '\n') continue;
    value = index(buf, '='); 
    if(value == NULL) continue;
    /* null terminate the name */
    *value = '\0';
    /* trim the left edge of the name */
    for(name = buf; isspace((int) *name); name++);
    if(*name == '\0') continue;
    /* trim the right edge of the name */
    for(endname = value-1; isspace((int) *endname); endname--);
    endname[1] = '\0';
    /* trim the left edge of the value */
    for(++value; isspace((int) *value); value++);
    for(endvalue = value+strlen(value)-1; isspace((int) *endvalue); endvalue--);
    endvalue[1] = '\0';
    // printf("found config '%s' = '%s'\n", name, value);

    configaro_set(cfg, name, value);

  } 

  /* from the man page: The fgets() and gets() functions do
  not distinguish between end-of-file and error, and callers
  must use feof(3) and ferror(3) to determine which
  occurred. */

  fclose(fpConf); 
  return TRUE; 
}

/* designed to dump the configuration across the socket to
   an interested interpreter */
void 
configaro_write_current_config(struct configaro *cfg, int s) {
  int i;
  for(i=0; cfg[i].description != NULL; i++) {
    char buf[DEF_BUF_LEN];

    if(cfg[i].cb != configaro_header)
      socket_printf(s, "%s = %s\n", 
                    cfg[i].name,
                    sprint_default(&cfg[i], buf, DEF_BUF_LEN));
  }
}

