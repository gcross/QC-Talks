<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.514726507714">
	<global_window_position top="22" left="-1" height="713" width="1004"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="cog.20080209114911"><vh>@settings</vh>
<v t="cog.20080209114911.1"><vh>@bool use_chapters = True</vh></v>
<v t="cog.20080209114911.2"><vh>@bool use_chapter_tabs = True</vh></v>
</v>
<v t="gcross.20080205144016.1"><vh>@chapters</vh>
<v t="cog.20080209114750"><vh>@chapter Objects</vh>
<v t="cog.20080202171431" a="E" tnodeList="cog.20080202171431,gcross.20080205154455,cog.20080202221727,gcross.20080205154433,cog.20080202223726,cog.20080206105306,gcross.20080206160626,cog.20080205202554,cog.20080203122007,cog.20080205202554.1,cog.20080210214408,cog.20080209130316,cog.20080209154832,cog.20080209125617,cog.20080202223407,cog.20080202221727.1,cog.20080203122007.1,cog.20080203122007.2,cog.20080203122007.3,cog.20080203193930,cog.20080204102848,cog.20080204102848.1,gcross.20080205150700,gcross.20080205145843,gcross.20080205151350,gcross.20080205152554,gcross.20080205152804,gcross.20080205152826,gcross.20080205160937,cog.20080205193134.2,cog.20080205193134,cog.20080205193134.1,cog.20080205195954,cog.20080205202933,cog.20080205220726,cog.20080209125111,cog.20080205221825,cog.20080209121350,cog.20080205223711,cog.20080205221252,cog.20080205221533,cog.20080205223711.1,cog.20080205220726.1,cog.20080205221106,cog.20080205230828,cog.20080205221751,cog.20080205230828.1,cog.20080206002656,cog.20080206002656.1,cog.20080206003855,cog.20080206003855.1,cog.20080209121118,gcross.20080206160516,cog.20080206214555,gcross.20080207161559,gcross.20080207163659,cog.20080206105228,cog.20080209113402,cog.20080206102219,cog.20080206102219.1,cog.20080206102633,cog.20080209121350.1,cog.20080209124808,cog.20080209135843,cog.20080209145629,cog.20080209154613,cog.20080210225424,gcross.20080207161129,cog.20080203111120,cog.20080210214303,cog.20080210214303.1,cog.20080210110019,cog.20080210110019.1,cog.20080210110458,cog.20080210130554,cog.20080210172454,cog.20080210110827,cog.20080210124109,cog.20080210130554.1,cog.20080210110827.1,cog.20080210144002,cog.20080210182247"><vh>@file objects.py</vh>
<v t="gcross.20080205154455"><vh>Transitions</vh>
<v t="cog.20080202221727"><vh>Exponential Transition</vh></v>
<v t="gcross.20080205154433"><vh>Logarithmic Transition</vh></v>
</v>
<v t="cog.20080202223726"><vh>Background</vh></v>
<v t="cog.20080206105306"><vh>Images</vh></v>
<v t="gcross.20080206160626"><vh>Colors</vh></v>
<v t="cog.20080205202554"><vh>Paths</vh>
<v t="cog.20080203122007"><vh>Sine paths</vh></v>
<v t="cog.20080205202554.1"><vh>Qubit path</vh></v>
</v>
<v t="cog.20080210214408" a="E"><vh>Functions</vh>
<v t="cog.20080209130316"><vh>def draw_with_shadows</vh></v>
<v t="cog.20080209154832"><vh>def draw_centered_rectangle</vh></v>
<v t="cog.20080209125617"><vh>def faded_rectangle</vh></v>
</v>
<v t="cog.20080202223407" a="E"><vh>Objects</vh>
<v t="cog.20080202221727.1"><vh>Circles</vh>
<v t="cog.20080203122007.1"><vh>Generate colors</vh></v>
<v t="cog.20080203122007.2"><vh>Thousand circles</vh></v>
<v t="cog.20080203122007.3"><vh>Circles w/ waves</vh></v>
</v>
<v t="cog.20080203193930"><vh>Wires</vh>
<v t="cog.20080204102848"><vh>Draw top wire</vh></v>
<v t="cog.20080204102848.1"><vh>Draw bottom wire</vh></v>
<v t="gcross.20080205150700"><vh>Draw middle wire</vh></v>
<v t="gcross.20080205145843"><vh>Draw box around center site</vh></v>
<v t="gcross.20080205151350"><vh>Draw X around middle wire</vh></v>
<v t="gcross.20080205152554"><vh>Draw long-scale wires</vh>
<v t="gcross.20080205152804"><vh>Draw top wire</vh></v>
<v t="gcross.20080205152826"><vh>Draw bottom wire</vh></v>
</v>
<v t="gcross.20080205160937"><vh>Draw dot-dot-dots</vh>
<v t="cog.20080205193134.2"><vh>Draw connection arrows</vh></v>
<v t="cog.20080205193134"><vh>Draw dots</vh></v>
<v t="cog.20080205193134.1"><vh>Draw port labels</vh></v>
</v>
<v t="cog.20080205195954"><vh>Draw remaining connections</vh></v>
</v>
<v t="cog.20080205202933"><vh>W state</vh></v>
<v t="cog.20080205220726"><vh>W state wirings</vh>
<v t="cog.20080209125111" a="E"><vh>Utility functions</vh>
<v t="cog.20080205221825"><vh>def draw_qubit</vh></v>
</v>
<v t="cog.20080209121350"><vh>Draw diagram</vh>
<v t="cog.20080205223711" a="E"><vh>Draw connections</vh>
<v t="cog.20080205221252"><vh>Draw center connections</vh></v>
<v t="cog.20080205221533"><vh>Draw outer connections</vh></v>
</v>
<v t="cog.20080205223711.1" a="E"><vh>Draw ports</vh>
<v t="cog.20080205220726.1"><vh>Draw center ports</vh></v>
<v t="cog.20080205221106"><vh>Draw outer ports</vh></v>
</v>
<v t="cog.20080205230828" a="E"><vh>Draw qubits</vh>
<v t="cog.20080205221751"><vh>Draw center qubits</vh></v>
<v t="cog.20080205230828.1"><vh>Draw outside qubits</vh></v>
</v>
</v>
<v t="cog.20080206002656"><vh>Draw matrices</vh>
<v t="cog.20080206002656.1"><vh>def draw_matrix</vh></v>
<v t="cog.20080206003855"><vh>Draw center matrix</vh></v>
<v t="cog.20080206003855.1"><vh>Draw outer matrices</vh></v>
</v>
<v t="cog.20080209121118"><vh>Draw hints to connect matrix with diagram</vh>
<v t="gcross.20080206160516"><vh>Draw index labels</vh></v>
<v t="cog.20080206214555"><vh>Draw arrows</vh></v>
<v t="gcross.20080207161559"><vh>Draw vectors</vh></v>
</v>
<v t="gcross.20080207163659"><vh>Draw operators</vh></v>
<v t="cog.20080206105228"><vh>Draw equation</vh></v>
<v t="cog.20080209113402" a="E"><vh>Draw operator chain</vh></v>
<v t="cog.20080206102219" a="E"><vh>Draw matrix labels</vh>
<v t="cog.20080206102219.1"><vh>def draw_matrix_label</vh></v>
<v t="cog.20080206102633"><vh>Draw labels</vh></v>
<v t="cog.20080209121350.1"><vh>Draw connection index labels</vh></v>
</v>
<v t="cog.20080209124808"><vh>Draw environment</vh></v>
<v t="cog.20080209135843"><vh>Draw state chains</vh></v>
<v t="cog.20080209145629"><vh>Draw environmonster</vh></v>
<v t="cog.20080209154613"><vh>Draw environment</vh></v>
<v t="cog.20080210225424"><vh>Draw optimization matrix box</vh></v>
</v>
<v t="gcross.20080207161129"><vh>Vector</vh></v>
<v t="cog.20080203111120"><vh>Thermometer</vh></v>
<v t="cog.20080210214303"><vh>Qubit</vh></v>
<v t="cog.20080210214303.1"><vh>Connector</vh></v>
<v t="cog.20080210110019"><vh>Visualizer</vh>
<v t="cog.20080210110019.1"><vh>matrix drawing routines</vh></v>
<v t="cog.20080210110458"><vh>port drawing routines</vh></v>
<v t="cog.20080210130554"><vh>draw_matrix_blend</vh></v>
<v t="cog.20080210172454"><vh>draw_port_blend</vh></v>
<v t="cog.20080210110827"><vh>draw_visualizer</vh>
<v t="cog.20080210124109"><vh>Compute sliding heights</vh></v>
<v t="cog.20080210130554.1"><vh>fetch_and_draw_matrix_blend</vh></v>
<v t="cog.20080210110827.1"><vh>Draw sites</vh></v>
<v t="cog.20080210144002"><vh>Draw ports</vh></v>
</v>
</v>
<v t="cog.20080210182247"><vh>Meter</vh></v>
</v>
</v>
</v>
<v t="cog.20080209114750.1"><vh>@chapter Slides</vh>
<v t="cog.20080209114750.2" a="E" tnodeList="cog.20080209114750.2,cog.20080203165722,cog.20080203165722.1,cog.20080210233155,cog.20080210233638,cog.20080210235708,cog.20080211000339,cog.20080203120235,cog.20080203193930.1,cog.20080203120414,cog.20080203120235.1,cog.20080203120235.2,cog.20080203124947,cog.20080203122343.1,cog.20080203132537,cog.20080203132537.1,cog.20080203132537.2,cog.20080203132537.3,cog.20080203132537.4,cog.20080203132740,cog.20080203130300,cog.20080203132907,cog.20080203135754,cog.20080203135754.1,cog.20080203143825,cog.20080203143859.1,cog.20080203144224,cog.20080203151959,cog.20080203151558,cog.20080203152654,cog.20080203152336,cog.20080203152654.1,cog.20080203153419,cog.20080203154946,cog.20080203154946.1,cog.20080203154952,cog.20080203155254,cog.20080203155529,cog.20080203193930.2,cog.20080203194441,cog.20080204103008,gcross.20080205151538,gcross.20080205151651,gcross.20080205153207,cog.20080205184010,cog.20080205194051,cog.20080205194051.1,cog.20080205195225,cog.20080205195954.1,cog.20080205202511,cog.20080205202511.1,cog.20080205203215,cog.20080205211049,cog.20080205211049.1,cog.20080205211602,cog.20080205222004,cog.20080206111833,cog.20080206121251,cog.20080206122604,cog.20080206122604.1,cog.20080206111833.1,cog.20080206114238,cog.20080206111905,cog.20080207000444,cog.20080206112012,cog.20080206111917,gcross.20080207164423,cog.20080209123403,cog.20080209114750.3,cog.20080209140327,cog.20080209142243,cog.20080209150019,cog.20080209162206.1,cog.20080209162206.3,cog.20080209162206.4,cog.20080209162206.5,cog.20080209162206.2,cog.20080210223736,cog.20080211004454,cog.20080210222140,cog.20080210214717,cog.20080210133850,cog.20080210134812,cog.20080210134812.3,cog.20080210173147,cog.20080210173147.1,cog.20080210173147.2,cog.20080210185340,cog.20080210173147.3,cog.20080210134840,cog.20080210134840.9,cog.20080210134840.10,cog.20080210134840.1,cog.20080210134840.2,cog.20080210134840.3,cog.20080210134840.4,cog.20080210134840.5,cog.20080210134840.6,cog.20080210134840.7,cog.20080210134840.8,cog.20080210134840.11,cog.20080210134840.12,cog.20080210134840.13,cog.20080210134840.14,cog.20080210180720,cog.20080210164632,cog.20080210140005,cog.20080210165252,cog.20080210182948,cog.20080210194351,cog.20080210174137,cog.20080210165945,cog.20080210174231,cog.20080210180641,cog.20080210203604,cog.20080210205214,cog.20080211004821,cog.20080211004535,cog.20080211012358"><vh>@file slides.py</vh>
<v t="cog.20080203165722" a="E"><vh>Slides</vh>
<v t="cog.20080203165722.1"><vh>Logo</vh></v>
<v t="cog.20080210233155"><vh>Title Slide</vh></v>
<v t="cog.20080210233638"><vh>Logo Slide</vh></v>
<v t="cog.20080210235708"><vh>Grey Slide</vh></v>
<v t="cog.20080211000339"><vh>Outline Slide</vh></v>
<v t="cog.20080203120235" a="E"><vh>Animation</vh>
<v t="cog.20080203193930.1" a="E"><vh>Interactions</vh>
<v t="cog.20080203120414"><vh>Create waves for animation</vh>
<v t="cog.20080203120235.1"><vh>Short waves</vh></v>
<v t="cog.20080203120235.2"><vh>Long waves</vh></v>
</v>
<v t="cog.20080203124947"><vh>Zoom</vh></v>
<v t="cog.20080203122343.1" a="E"><vh>Zero temperature = ground state</vh>
<v t="cog.20080203132537"><vh>Initialization</vh></v>
<v t="cog.20080203132537.1"><vh>First part</vh></v>
<v t="cog.20080203132537.2"><vh>Thermometer</vh></v>
<v t="cog.20080203132537.3"><vh>Second part</vh></v>
<v t="cog.20080203132537.4"><vh>Cleanup</vh></v>
</v>
<v t="cog.20080203132740"><vh>New sites match the old</vh>
<v t="cog.20080203130300"><vh>Add a new site</vh></v>
<v t="cog.20080203132907" a="E"><vh>Let it reach equilibrium</vh>
<v t="cog.20080203135754"><vh>Create a new set of waves</vh></v>
<v t="cog.20080203135754.1"><vh>Animate</vh></v>
</v>
</v>
<v t="cog.20080203143825"><vh>Simulate the environment</vh>
<v t="cog.20080203143859.1"><vh>Add a new site</vh></v>
<v t="cog.20080203144224"><vh>Replace sites with environment</vh></v>
<v t="cog.20080203151959"><vh>Move site into slot</vh></v>
<v t="cog.20080203151558"><vh>Interact site with environment</vh></v>
<v t="cog.20080203152654"><vh>Take site away</vh></v>
</v>
<v t="cog.20080203152336" a="E"><vh>Suppose we don't have environment</vh>
<v t="cog.20080203152654.1"><vh>Change shade of environment</vh></v>
<v t="cog.20080203153419" a="E"><vh>Add and interact new site</vh></v>
<v t="cog.20080203154946" a="E"><vh>Converge!</vh>
<v t="cog.20080203154946.1"><vh>Add site</vh></v>
<v t="cog.20080203154952"><vh>Interact site</vh></v>
<v t="cog.20080203155254"><vh>Absorb site</vh></v>
<v t="cog.20080203155529"><vh>Remove and reset site</vh></v>
</v>
</v>
</v>
<v t="cog.20080203193930.2"><vh>Signals</vh>
<v t="cog.20080203194441"><vh>Transition to signal drawing</vh></v>
<v t="cog.20080204103008"><vh>Highlight top and bottom rows</vh></v>
<v t="gcross.20080205151538"><vh>Highlight center site</vh></v>
<v t="gcross.20080205151651"><vh>Show example of wrong configuration</vh></v>
<v t="gcross.20080205153207"><vh>Zoom out to emphasize size of state</vh></v>
<v t="cog.20080205184010"><vh>Dot dot dots</vh></v>
<v t="cog.20080205194051"><vh>Signals</vh>
<v t="cog.20080205194051.1"><vh>Upper signal</vh></v>
<v t="cog.20080205195225"><vh>Lower signal</vh></v>
</v>
<v t="cog.20080205195954.1"><vh>Fade in everything else</vh></v>
<v t="cog.20080205202511"><vh>Fade it all out</vh></v>
</v>
<v t="cog.20080205202511.1"><vh>W state</vh>
<v t="cog.20080205203215"><vh>Fade in W state</vh></v>
<v t="cog.20080205211049"><vh>Rectangle around 3rd site</vh></v>
<v t="cog.20080205211049.1"><vh>Highlight regions</vh></v>
<v t="cog.20080205211602"><vh>Fade out W state</vh></v>
</v>
<v t="cog.20080205222004" a="E"><vh>W state wiring</vh>
<v t="cog.20080206111833"><vh>Fade in new diagram</vh></v>
<v t="cog.20080206121251"><vh>Wire connections</vh>
<v t="cog.20080206122604"><vh>Upper port</vh></v>
<v t="cog.20080206122604.1"><vh>Lower port</vh></v>
</v>
<v t="cog.20080206111833.1"><vh>Zoom out to show matrix</vh></v>
<v t="cog.20080206114238"><vh>Fill in matrix</vh></v>
<v t="cog.20080206111905"><vh>Zoom out to show labels</vh></v>
<v t="cog.20080207000444"><vh>Point out meaning of sub/superscripts.</vh></v>
<v t="cog.20080206112012"><vh>Fade in outer sites</vh></v>
<v t="cog.20080206111917"><vh>Zoom out to show equation</vh></v>
<v t="gcross.20080207164423"><vh>Replace qubits with operators</vh></v>
<v t="cog.20080209123403"><vh>Fade in environment picture</vh></v>
<v t="cog.20080209114750.3"><vh>Display operator chain</vh></v>
<v t="cog.20080209140327"><vh>Display state chain</vh></v>
<v t="cog.20080209142243"><vh>Connect expectation network</vh></v>
<v t="cog.20080209150019"><vh>ENVIRONMONSTER!!!</vh></v>
<v t="cog.20080209162206.1" a="E"><vh>Converge!</vh>
<v t="cog.20080209162206.3"><vh>Interact site</vh></v>
<v t="cog.20080209162206.4"><vh>Absorb site</vh></v>
<v t="cog.20080209162206.5"><vh>Remove and reset site</vh></v>
<v t="cog.20080209162206.2"><vh>Add site</vh></v>
</v>
<v t="cog.20080210223736"><vh>Absorb environment into middle</vh></v>
</v>
</v>
<v t="cog.20080211004454"><vh>Results Slide</vh></v>
<v t="cog.20080210222140"><vh>Transverse Ising Model</vh></v>
<v t="cog.20080210214717"><vh>Visualization Guide</vh></v>
<v t="cog.20080210133850"><vh>Demonstration</vh>
<v t="cog.20080210173147"><vh>class Result Cache</vh>
<v t="cog.20080210173147.1"><vh>__init__</vh></v>
<v t="cog.20080210173147.2"><vh>matrix fetching routines</vh></v>
<v t="cog.20080210185340"><vh>energy fetching routines</vh></v>
<v t="cog.20080210173147.3"><vh>ensure_in_cache</vh></v>
</v>
<v t="cog.20080210134812"><vh>&lt;&lt; Initialize system &gt;&gt;</vh>
<v t="cog.20080210134812.3"><vh>&lt;&lt; Dense operators &gt;&gt;</vh></v>
</v>
<v t="cog.20080210134840"><vh>Functions</vh>
<v t="cog.20080210134840.9"><vh>my_eigen_schur</vh></v>
<v t="cog.20080210134840.10"><vh>infinite_energy_limit</vh></v>
<v t="cog.20080210134840.1"><vh>function infinite_energy_limit</vh>
<v t="cog.20080210134840.2"><vh>Initialization</vh></v>
<v t="cog.20080210134840.3"><vh>Calculate left and right environment tensors</vh></v>
<v t="cog.20080210134840.4"><vh>Compute Z term</vh></v>
<v t="cog.20080210134840.5"><vh>Compute XX term</vh></v>
<v t="cog.20080210134840.6"><vh>Compute Z normalization</vh></v>
<v t="cog.20080210134840.7"><vh>Compute XX normalization</vh></v>
<v t="cog.20080210134840.8"><vh>Compute energy</vh></v>
</v>
<v t="cog.20080210134840.11"><vh>function display_result</vh></v>
<v t="cog.20080210134840.12"><vh>function infinite_energy_residual</vh></v>
<v t="cog.20080210134840.13"><vh>callback</vh></v>
<v t="cog.20080210134840.14"><vh>xcallback</vh></v>
</v>
<v t="cog.20080210180720"><vh>Initialization</vh></v>
<v t="cog.20080210164632"><vh>def run_site</vh></v>
<v t="cog.20080210140005"><vh>Belabor first two sites</vh></v>
<v t="cog.20080210165252"><vh>Run through a couple more</vh></v>
<v t="cog.20080210182948"><vh>Introduce meters</vh></v>
<v t="cog.20080210194351"><vh>Run through up to ten</vh></v>
<v t="cog.20080210174137"><vh>def increase_to_reflect_chi</vh></v>
<v t="cog.20080210165945"><vh>Increase the number of ports</vh></v>
<v t="cog.20080210174231"><vh>Run though more sites, getting faster</vh></v>
<v t="cog.20080210180641"><vh>Increase and do run with 6 ports</vh></v>
<v t="cog.20080210203604"><vh>Increase and do run with 10 ports</vh></v>
<v t="cog.20080210205214"><vh>Increase and do run with 15 ports</vh></v>
</v>
<v t="cog.20080211004821"><vh>Haldane-Shastry Model</vh></v>
<v t="cog.20080211004535"><vh>Remarks</vh></v>
<v t="cog.20080211012358" a="TV"><vh>Conclusions</vh></v>
</v>
</v>
</v>
<v t="cog.20080209114750.4"><vh>@chapter Presentation</vh>
<v t="gcross.20080205144112" tnodeList="gcross.20080205144112"><vh>@file presentation.py</vh></v>
</v>
<v t="cog.20080209114750.5"><vh>@chapter Miscellaneous</vh>
<v t="cog.20080203151444" tnodeList="cog.20080203151444"><vh>@file fonts.py</vh></v>
<v t="cog.20080202234611"><vh>Junkyard</vh></v>
<v t="cog.20080202221727.2"><vh>Sine wave</vh></v>
</v>
<v t="cog.20080210105032" a="E"><vh>@chapter Model</vh>
<v t="cog.20080210171852" a="E" tnodeList="cog.20080210171852,cog.20080210171852.1,cog.20080210171852.2,cog.20080210171852.3,cog.20080210171852.4,cog.20080210171852.5,cog.20080210171852.6,cog.20080210171852.7,cog.20080210171852.8,cog.20080210171852.9,cog.20080210171852.10,cog.20080210171852.11,cog.20080210171852.12,cog.20080210171852.13,cog.20080210171852.14,cog.20080210171852.15,cog.20080210171852.16,cog.20080210171852.17,cog.20080210171852.18,cog.20080210171852.19,cog.20080210171852.20,cog.20080210171852.21,cog.20080210171852.22,cog.20080210171852.23,cog.20080210171852.24,cog.20080210171852.25,cog.20080210171852.26,cog.20080210171852.27,cog.20080210171852.28,cog.20080210171852.29,cog.20080210171852.30,cog.20080210171852.31,cog.20080210171852.32,cog.20080210171852.33,cog.20080210171852.34,cog.20080210171852.35,cog.20080210171852.36,cog.20080210171852.37,cog.20080210171852.38,cog.20080210171852.39,cog.20080210171852.40,cog.20080210171852.41,cog.20080210171852.42,cog.20080210171852.43,cog.20080210171852.44,cog.20080210171852.45,cog.20080210171852.46,cog.20080210171852.47,cog.20080210171852.48,cog.20080210171852.49,cog.20080210171852.50,cog.20080210171852.51,cog.20080210171852.52,cog.20080210171852.53,cog.20080210171852.54,cog.20080210171852.55,cog.20080210171852.56,cog.20080210171852.57,cog.20080210171852.58,cog.20080210171852.59,cog.20080210171852.60,cog.20080210171852.61,cog.20080210171852.62,cog.20080210171852.63,cog.20080210171852.64,cog.20080210171852.65,cog.20080210171852.66,cog.20080210171852.67,cog.20080210171852.68,cog.20080210171852.69,cog.20080210171852.70,cog.20080210171852.71,cog.20080210171852.72,cog.20080210171852.73,cog.20080210171852.74,cog.20080210171852.75,cog.20080210171852.76,cog.20080210171852.77,cog.20080210171852.78,cog.20080210171852.79,cog.20080210171852.80,cog.20080210171852.81,cog.20080210171852.82,cog.20080210171852.83,cog.20080210171852.84,cog.20080210171852.85,cog.20080210171852.86,cog.20080210171852.87,cog.20080210171852.88,cog.20080210171852.89,cog.20080210171852.90,cog.20080210171852.91,cog.20080210171852.92,cog.20080210171852.93,cog.20080210171852.94,cog.20080210171852.95,cog.20080210171852.96,cog.20080210171852.97,cog.20080210171852.98,cog.20080210171852.99,cog.20080210171852.100,cog.20080210171852.101,cog.20080210171852.102,cog.20080210171852.103,cog.20080210171852.104,cog.20080210171852.105,cog.20080210171852.106,cog.20080210171852.107,cog.20080210171852.108,cog.20080210171852.109,cog.20080210171852.110,cog.20080210171852.111,cog.20080210171852.112,cog.20080210171852.113,cog.20080210171852.114,cog.20080210171852.115,cog.20080210171852.116,cog.20080210171852.117,cog.20080210171852.118,cog.20080210171852.119,cog.20080210171852.120,cog.20080210171852.121,cog.20080210171852.122,cog.20080210171852.123,cog.20080210171852.124,cog.20080210171852.125,cog.20080210171852.126,cog.20080210171852.127,cog.20080210171852.128,cog.20080210171852.129,cog.20080210171852.130,cog.20080210171852.131,cog.20080210171852.132,cog.20080210171852.133,cog.20080210171852.134,cog.20080210171852.135"><vh>@file InfiniteOpenProductState.py</vh>
<v t="cog.20080210171852.1"><vh>Import needed modules</vh></v>
<v t="cog.20080210171852.2"><vh>Constants</vh></v>
<v t="cog.20080210171852.3" a="E"><vh>Functions</vh>
<v t="cog.20080210171852.4"><vh>Normalization functions</vh>
<v t="cog.20080210171852.5"><vh>function compute_normalizer</vh></v>
<v t="cog.20080210171852.6"><vh>function apply_normalizer</vh></v>
<v t="cog.20080210171852.7"><vh>function compute_and_apply_normalizer</vh></v>
</v>
<v t="cog.20080210171852.8"><vh>my_eigen</vh></v>
<v t="cog.20080210171852.9"><vh>normalize</vh></v>
<v t="cog.20080210171852.10"><vh>compute_optimized_site_matrix</vh></v>
<v t="cog.20080210171852.11"><vh>function kill_phase</vh></v>
<v t="cog.20080210171852.12"><vh>multiply_tensor_by_matrix_at_index</vh></v>
<v t="cog.20080210171852.13"><vh>ensure_dimensions_greater_than_one</vh></v>
</v>
<v t="cog.20080210171852.14" a="E"><vh>Classes</vh>
<v t="cog.20080210171852.15"><vh>class ConvergenceError</vh></v>
<v t="cog.20080210171852.16" a="E"><vh>class System</vh>
<v t="cog.20080210171852.17"><vh>__init__</vh></v>
<v t="cog.20080210171852.18"><vh>absorb_site</vh></v>
<v t="cog.20080210171852.19"><vh>repeat_alternating_site_run</vh></v>
<v t="cog.20080210171852.20"><vh>single_site_run</vh></v>
<v t="cog.20080210171852.21"><vh>compute_energy_given_site_matrix</vh></v>
<v t="cog.20080210171852.22"><vh>get_matvec</vh></v>
<v t="cog.20080210171852.23"><vh>compute_energy</vh></v>
</v>
</v>
<v t="cog.20080210171852.24" a="E"><vh>One Dimension</vh>
<v t="cog.20080210171852.25"><vh>Special multiplication functions</vh></v>
<v t="cog.20080210171852.26" a="E"><vh>class OneDimensionalSystem</vh>
<v t="cog.20080210171852.27"><vh>__init__</vh></v>
<v t="cog.20080210171852.28"><vh>normalize_and_absorb_site</vh></v>
<v t="cog.20080210171852.29"><vh>increase_auxiliary_dimension_by</vh></v>
<v t="cog.20080210171852.30"><vh>update_quantities_derivative_from_auxiliary_dimension</vh></v>
</v>
<v t="cog.20080210171852.31" a="E"><vh>Terms</vh>
<v t="cog.20080210171852.32" a="E"><vh>class MatrixProductOperatorTerm</vh>
<v t="cog.20080210171852.33"><vh>__init__</vh></v>
<v t="cog.20080210171852.34"><vh>get_matvec</vh></v>
<v t="cog.20080210171852.35"><vh>get_imatvec</vh></v>
<v t="cog.20080210171852.36"><vh>get_rmatvec</vh></v>
<v t="cog.20080210171852.37"><vh>get_expectation_value</vh></v>
<v t="cog.20080210171852.38"><vh>get_optimization_matrix_at_site</vh></v>
<v t="cog.20080210171852.39"><vh>absorb_site</vh></v>
<v t="cog.20080210171852.40"><vh>absorb_unitary</vh></v>
</v>
</v>
</v>
<v t="cog.20080210171852.41"><vh>Two Dimensions</vh>
<v t="cog.20080210171852.42"><vh>Special multiplication functions</vh></v>
<v t="cog.20080210171852.43"><vh>class TwoDimensionalSystem</vh>
<v t="cog.20080210171852.44"><vh>__init__</vh></v>
<v t="cog.20080210171852.45"><vh>absorb_site</vh></v>
<v t="cog.20080210171852.46"><vh>normalize_and_absorb_site</vh></v>
<v t="cog.20080210171852.47"><vh>normalize_site</vh></v>
<v t="cog.20080210171852.48"><vh>increase_horizontal_auxiliary_dimension_by</vh></v>
<v t="cog.20080210171852.49"><vh>update_quantities_derivative_from_auxiliary_dimension</vh></v>
<v t="cog.20080210171852.50"><vh>compute_energy_per_term</vh></v>
<v t="cog.20080210171852.51"><vh>absorb_row</vh></v>
<v t="cog.20080210171852.52"><vh>replace_boundaries_with_infinite_limit</vh></v>
</v>
<v t="cog.20080210171852.53"><vh>class ProtoPEPSOperatorTerm</vh>
<v t="cog.20080210171852.54"><vh>__init__</vh></v>
<v t="cog.20080210171852.55"><vh>get_matvec</vh></v>
<v t="cog.20080210171852.56"><vh>get_imatvec</vh></v>
<v t="cog.20080210171852.57"><vh>get_rmatvec</vh></v>
<v t="cog.20080210171852.58"><vh>get_expectation_value</vh></v>
<v t="cog.20080210171852.59" a="M"><vh>get_optimization_matrix_at_site</vh></v>
<v t="cog.20080210171852.60"><vh>absorb_site</vh></v>
<v t="cog.20080210171852.61"><vh>absorb_unitary</vh></v>
</v>
<v t="cog.20080210171852.62"><vh>class PEPSOperatorTerm</vh>
<v t="cog.20080210171852.63"><vh>__init__</vh></v>
<v t="cog.20080210171852.64"><vh>get_matvec</vh></v>
<v t="cog.20080210171852.65"><vh>get_imatvec</vh></v>
<v t="cog.20080210171852.66"><vh>get_rmatvec</vh></v>
<v t="cog.20080210171852.67"><vh>get_expectation_value</vh></v>
<v t="cog.20080210171852.68" a="M"><vh>get_optimization_matrix_at_site</vh></v>
<v t="cog.20080210171852.69"><vh>absorb_site</vh></v>
<v t="cog.20080210171852.70"><vh>absorb_unitary</vh></v>
<v t="cog.20080210171852.71" a="M"><vh>absorb_row</vh></v>
</v>
<v t="cog.20080210171852.72"><vh>class MagneticFieldTerm</vh>
<v t="cog.20080210171852.73"><vh>__init__</vh></v>
<v t="cog.20080210171852.74"><vh>get_optimization_matrix</vh></v>
<v t="cog.20080210171852.75"><vh>get_matvec</vh></v>
<v t="cog.20080210171852.76"><vh>get_matvec</vh></v>
<v t="cog.20080210171852.77"><vh>get_expectation_value</vh></v>
<v t="cog.20080210171852.78"><vh>absorb_site</vh></v>
<v t="cog.20080210171852.79"><vh>absorb_unitary</vh></v>
<v t="cog.20080210171852.80"><vh>absorb_row</vh></v>
<v t="cog.20080210171852.81"><vh>update_multiplication_functions</vh>
<v t="cog.20080210171852.82"><vh>Special magnetic field multiplication functions</vh></v>
</v>
<v t="cog.20080210171852.83"><vh>replace_boundaries_with</vh></v>
<v t="cog.20080210171852.84"><vh>get_energy_per_term</vh></v>
</v>
<v t="cog.20080210171852.85"><vh>class TwoDimensionalNormalizerTerm</vh>
<v t="cog.20080210171852.86"><vh>__init__</vh></v>
<v t="cog.20080210171852.87"><vh>get_optimization_matrix</vh></v>
<v t="cog.20080210171852.88"><vh>get_matvec</vh></v>
<v t="cog.20080210171852.89"><vh>get_matvec</vh></v>
<v t="cog.20080210171852.90"><vh>get_imatvec</vh></v>
<v t="cog.20080210171852.91"><vh>get_imatvec</vh></v>
<v t="cog.20080210171852.92"><vh>get_imatvec</vh></v>
<v t="cog.20080210171852.93"><vh>get_rmatvec</vh></v>
<v t="cog.20080210171852.94"><vh>get_expectation_value</vh></v>
<v t="cog.20080210171852.95"><vh>get_infinite_limit_boundary</vh></v>
<v t="cog.20080210171852.96"><vh>update_multiplication_functions</vh>
<v t="cog.20080210171852.97"><vh>Special normalizer multiplication functions</vh></v>
<v t="cog.20080210171852.98"><vh>Boundary extender function</vh></v>
</v>
<v t="cog.20080210171852.99"><vh>absorb_site</vh></v>
<v t="cog.20080210171852.100"><vh>absorb_row</vh>
<v t="cog.20080210171852.101"><vh>reduce_dimension</vh></v>
</v>
<v t="cog.20080210171852.102"><vh>absorb_unitary</vh></v>
<v t="cog.20080210171852.103"><vh>replace_boundaries_with</vh></v>
</v>
<v t="cog.20080210171852.104"><vh>class SpinCouplingTerm</vh>
<v t="cog.20080210171852.105"><vh>__init__</vh>
<v t="cog.20080210171852.106"><vh>&lt;&lt; One site boundary &gt;&gt;</vh></v>
<v t="cog.20080210171852.107"><vh>&lt;&lt; Two site boundary &gt;&gt;</vh></v>
</v>
<v t="cog.20080210171852.108"><vh>get_optimization_matrix</vh></v>
<v t="cog.20080210171852.109"><vh>get_matvec</vh></v>
<v t="cog.20080210171852.110"><vh>get_matvec</vh></v>
<v t="cog.20080210171852.111"><vh>get_expectation_value</vh></v>
<v t="cog.20080210171852.112"><vh>get_energy_per_term</vh></v>
<v t="cog.20080210171852.113"><vh>update_multiplication_functions</vh>
<v t="cog.20080210171852.114"><vh>Special 2 body multiplication functions - one site</vh></v>
<v t="cog.20080210171852.115"><vh>Special 2 body multiplication functions - two sites</vh></v>
</v>
<v t="cog.20080210171852.116"><vh>absorb_row</vh></v>
<v t="cog.20080210171852.117"><vh>absorb_site</vh></v>
<v t="cog.20080210171852.118"><vh>absorb_unitary</vh></v>
<v t="cog.20080210171852.119"><vh>replace_boundaries_with</vh></v>
</v>
<v t="cog.20080210171852.120"><vh>class OldSpinCouplingTerm</vh>
<v t="cog.20080210171852.121"><vh>__init__</vh>
<v t="cog.20080210171852.122"><vh>&lt;&lt; One site boundary &gt;&gt;</vh></v>
<v t="cog.20080210171852.123"><vh>&lt;&lt; Two site boundary &gt;&gt;</vh></v>
<v t="cog.20080210171852.124"><vh>&lt;&lt; Three site boundary &gt;&gt;</vh></v>
</v>
<v t="cog.20080210171852.125"><vh>get_matvec</vh></v>
<v t="cog.20080210171852.126"><vh>get_expectation_value</vh></v>
<v t="cog.20080210171852.127"><vh>get_energy_per_term</vh></v>
<v t="cog.20080210171852.128"><vh>update_multiplication_functions</vh>
<v t="cog.20080210171852.129"><vh>Special 2 body multiplication functions - one site</vh></v>
<v t="cog.20080210171852.130"><vh>Special 2 body multiplication functions - two sites</vh></v>
<v t="cog.20080210171852.131"><vh>Special 2 body multiplication functions - three sites</vh></v>
</v>
<v t="cog.20080210171852.132"><vh>absorb_row</vh></v>
<v t="cog.20080210171852.133"><vh>absorb_site</vh></v>
<v t="cog.20080210171852.134"><vh>absorb_unitary</vh></v>
<v t="cog.20080210171852.135"><vh>replace_boundaries_with</vh></v>
</v>
</v>
</v>
<v t="cog.20080210105134" tnodeList="cog.20080210105134,cog.20080210105134.1,cog.20080210105134.2,cog.20080210105134.3,cog.20080210105345,cog.20080210105345.1,cog.20080210110019.2,cog.20080210105134.4,cog.20080210105134.6,cog.20080210105134.5,cog.20080210105134.7,cog.20080210105134.8,cog.20080210105134.9,cog.20080210105134.10,cog.20080210105134.11,cog.20080210105134.12,cog.20080210105134.13,cog.20080210105134.14,cog.20080210105134.15,cog.20080210105134.16,cog.20080210105134.17,cog.20080210105134.18,cog.20080210105134.19,cog.20080210105134.20,cog.20080210105134.21,cog.20080210105134.22,cog.20080210105134.23"><vh>@file InfiniteTransverseIsingModelSimulator.py</vh>
<v t="cog.20080210105134.1"><vh>Import needed modules</vh></v>
<v t="cog.20080210105134.2"><vh>Setup display options</vh></v>
<v t="cog.20080210105134.3"><vh>Obtain parameters for run</vh></v>
<v t="cog.20080210105345" a="E"><vh>Classes</vh>
<v t="cog.20080210105345.1" a="E"><vh>class ModelStack</vh>
<v t="cog.20080210110019.2"><vh>__init__</vh></v>
</v>
</v>
<v t="cog.20080210105134.4"><vh>Initialize system</vh>
<v t="cog.20080210105134.5"><vh>&lt;&lt; Sparse operators &gt;&gt;</vh></v>
<v t="cog.20080210105134.6"><vh>&lt;&lt; Super Sparse operators &gt;&gt;</vh></v>
<v t="cog.20080210105134.7"><vh>&lt;&lt; Dense operators &gt;&gt;</vh></v>
</v>
<v t="cog.20080210105134.8"><vh>Functions</vh>
<v t="cog.20080210105134.9"><vh>function infinite_energy_limit</vh>
<v t="cog.20080210105134.10"><vh>Initialization</vh></v>
<v t="cog.20080210105134.11"><vh>Calculate left and right environment tensors</vh></v>
<v t="cog.20080210105134.12"><vh>Compute Z term</vh></v>
<v t="cog.20080210105134.13"><vh>Compute XX term</vh></v>
<v t="cog.20080210105134.14"><vh>Compute Z normalization</vh></v>
<v t="cog.20080210105134.15"><vh>Compute XX normalization</vh></v>
<v t="cog.20080210105134.16"><vh>Compute energy</vh></v>
</v>
<v t="cog.20080210105134.17"><vh>my_eigen_schur</vh></v>
<v t="cog.20080210105134.18"><vh>infinite_energy_limit</vh></v>
<v t="cog.20080210105134.19"><vh>function display_result</vh></v>
<v t="cog.20080210105134.20"><vh>function infinite_energy_residual</vh></v>
<v t="cog.20080210105134.21"><vh>callback</vh></v>
<v t="cog.20080210105134.22"><vh>xcallback</vh></v>
</v>
<v t="cog.20080210105134.23" a="M"><vh>Do run</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="cog.20080202171431">from __future__ import division

from random import random, randrange, randint, choice as random_choice

from fonts import fonts

from slithy.library import *
from slithy.transition import *

from math import *

from numpy import arange

@others

</t>
<t tx="cog.20080202221727">from math import exp, log

class _ExponentialTransition(TransitionStyle):
    def __init__( self, starttime, duration, start, end, params, type ):
        TransitionStyle.__init__( self, starttime, duration, start, end, params, type )
        self.s = params.get("s",0.1)
        self.l = log((1+self.s)/self.s)

    def __call__( self, t ):
        if self.duration == 0.0:
            f = 1
        else:
            f = (t - self.starttime) / self.duration

        f = self.s * exp(self.l * f) - self.s

        if hasattr( self, 'range' ):
            return self.start + self.range * f
        else:
            return self.start.interp( self.end, f )

Transition.styles["exp"] = _ExponentialTransition

exponential = Transition(style="exp")
</t>
<t tx="cog.20080202221727.1"></t>
<t tx="cog.20080202221727.2">def create_sine_wave_drawer(number_of_waves):

    sine_path = Path().moveto(0,0)

    for i in xrange(number_of_waves):
        sine_path.rcurveto(0.125, 0.375,0.375, 0.375,0.5,0)
        sine_path.rcurveto(0.125,-0.375,0.375,-0.375,0.5,0)

    def draw_sine_wave(
            x=(SCALAR,-5,5,0),
            y=(SCALAR,-5,5,0),
            angle=(SCALAR,0,360,0),
            wavelength=(SCALAR,0,5,0.1),
            window_position=(SCALAR,-100,100,0),
            window_width=(SCALAR,0,100,number_of_waves)
        ):
        set_camera(Rect(0,0,width=5,height=5*(3/4)))
        translate(x,y)
        rotate(angle)
        scale(wavelength)
        clip(Rect(window_position,0,width=window_width,height=1,anchor="w"))
        widestroke(sine_path,0.1)

    return draw_sine_wave

draw_long_sine_wave = create_sine_wave_drawer(25)
draw_short_sine_wave = create_sine_wave_drawer(10)

def test_sine_wave():
    sine = Drawable(get_camera(),draw_long_sine_wave)

    start_animation(sine)

    pause()

    linear(5,sine.window_position,10)

    return end_animation()

test_sine_wave = test_sine_wave()

</t>
<t tx="cog.20080202223407">@others

test_objects(draw_W_state_wirings, clear_color=blue)
</t>
<t tx="cog.20080202223726">bg = Fill( style = 'horz', color = black, color2 = blue )
</t>
<t tx="cog.20080202234611">
class ConvertingRect(Rect):

    def convert_x(self,x):
        return self[0] + (x/5 + 1/2)*self.width()

    def convert_y(self,y):
        return self[1] + (y/5 + 1/2)*self.height()

    def convert_width(self,width):
        return width/5*self.width()

    def convert_height(self,height):
        return height/5*self.height()


def create_sine_wave_object(x,y,angle,converter):

    #viewport_x = camera_x + (x/5 + 1/2)*camera_width*cos(camera_angle) + (y/5 + 1/2)*camera_width/camera_aspect*sin(camera_angle)
    #viewport_y = camera_y - (x/5 + 1/2)*camera_width*sin(camera_angle) + (y/5 + 1/2)*camera_width/camera_aspect*sin(camera_angle)

    viewport_x = converter.convert_x(x)
    viewport_y = converter.convert_y(y)

    viewport_width = converter.convert_width(0.1*number_of_waves)
    viewport_y -= viewport_width/(2*number_of_waves)

    return Drawable(Rect(viewport_x,viewport_y,viewport_width,angle,number_of_waves),draw_sine_wave,window_width=number_of_waves)

def create_sine_wave_object(x,y,angle):
    set_camera(Rect(0,0,width=5,height=5*(3/4)))
    embed_object(camera(),draw_sine_wave,window_width=number_of_waves



</t>
<t tx="cog.20080203111120">tang = asin(0.5/0.75)/pi*180
thermometer_path = Path().moveto(0.5,0).arc(0,3,0,180,0.5).arc(0,-3.5,90+tang,90-tang,0.75).closepath()

mark = Path().moveto(0,0).rqcurveto(0,-0.125,0.6,-0.125)

meniscus = Path().moveto(-0.35,0).rqcurveto(0,-0.1,0.35,-0.1).rqcurveto(0.35,0,0.35,0.1).rlineto(0,0.1).rlineto(-0.7,0).closepath()

def draw_thermometer(temperature=(SCALAR,0,1,1)):

    set_camera(Rect(0,0,height=8.5,width=1.5))

    color(white)
    fill(thermometer_path)

    color(red)
    dot(0.6,0,-3.5)
    rectangle(-0.35,-3.5,0.35,-2.95+5.95*temperature)

    push()
    translate(0,-2.95+5.95*temperature)
    color(white)
    fill(meniscus)
    pop()

    push()
    color(black)
    translate(-0.5,3)
    widestroke(mark,0.05)
    for i in xrange(4):
        translate(0,-1.25)
        widestroke(mark,0.05)
    pop()

    color(black)
    widestroke(thermometer_path,0.1)


def test_thermometer():

    thermometer = Drawable(get_camera().left(0.2).top(0.3),draw_thermometer)

    start_animation(bg,thermometer)

    pause()

    linear(3,thermometer.temperature,0)

    return end_animation()

test_thermometer = test_thermometer()
</t>
<t tx="cog.20080203120235">start_animation(bg)

@others

crazy_interaction_animation = end_animation()


#test_objects(crazy_interaction_animation)
</t>
<t tx="cog.20080203120235.1">short_wave_lag_times = 8/wave_speed

short_waves = []
for i in xrange(crazy_interaction_duration*short_wave_density):
    short_waves.append((
        randint(-2,2),
        random()*0.3-0.15,
        random_choice((0,180)),
        random()*(crazy_interaction_duration-4)*wave_speed,
        Color(random(),random(),random())
    ))
</t>
<t tx="cog.20080203120235.2">long_waves = []
for i in xrange((crazy_interaction_duration-wait_before_long_waves_start)*long_wave_density):

    dot_number = randint(-2,2)
    start_time = (wait_before_long_waves_start+random()*(crazy_interaction_duration-wait_before_long_waves_start-10))*wave_speed
    angle = random()*90+random_choice((45,225))
    wave_color = Color(random(),random(),random())

    if random_choice((True,False)):
        long_waves.append((
            dot_number,
            0,
            angle,
            start_time,
            wave_color
        ))
    else:
        angle_in_radians = angle/180*pi
        r = abs(sin(angle_in_radians)/((5/2)*(3/4))) + 0.3
        long_waves.append((
            dot_number+2.5*cos(angle_in_radians),
            2.5*sin(angle_in_radians),
            angle-180,
            start_time-(2.5-r),
            wave_color
        ))
</t>
<t tx="cog.20080203120414">crazy_interaction_duration = 25
wait_before_long_waves_start = 8
pause_to_show_thermometer = 15

wave_speed = 3

short_wave_density = 3
long_wave_density = 3

</t>
<t tx="cog.20080203122007">def create_sine_path(number_of_waves):

    sine_path = Path().moveto(0,0)

    for i in xrange(number_of_waves):
        sine_path.rcurveto(0.125, 0.375,0.375, 0.375,0.5,0)
        sine_path.rcurveto(0.125,-0.375,0.375,-0.375,0.5,0)

    return sine_path

long_sine_path = create_sine_path(25)
short_sine_path = create_sine_path(8)
</t>
<t tx="cog.20080203122007.1">thousand_colors = []
for i in xrange(1000):
    thousand_colors.append(Color(random(),random(),random()))

initial_five_colors = thousand_colors[498:503]
</t>
<t tx="cog.20080203122007.2">def draw_thousand_circles():
    set_camera(Rect(0,0,width=1000,height=1,anchor="w"))

    for i in xrange(1000):
        color(thousand_colors[i])
        dot(0.3,i,0)</t>
<t tx="cog.20080203122007.3">def draw_five_circles(
    short_waves=(OBJECT,[]),
    long_waves=(OBJECT,[]),
    wave_time=(SCALAR,0,1000,0),
    color0=(COLOR,initial_five_colors[0]),
    color1=(COLOR,initial_five_colors[1]),
    color2=(COLOR,initial_five_colors[2]),
    color3=(COLOR,initial_five_colors[3]),
    color4=(COLOR,initial_five_colors[4]),
    color5=(COLOR,hsv(random(),1,0.5+0.5*random(),0)),
    color6=(COLOR,hsv(random(),1,0.5+0.5*random(),0)),
    x0=(SCALAR,-10,10,-2),
    x1=(SCALAR,-10,10,-1),
    x2=(SCALAR,-10,10, 0),
    x3=(SCALAR,-10,10, 1),
    x4=(SCALAR,-10,10, 2),
    x5=(SCALAR,-10,10, 0),
    y5=(SCALAR,-5,5,1.5),
    x6=(SCALAR,-10,10, 0),
    y6=(SCALAR,-5,5,1.5),
    environment_alpha=(SCALAR,0,1,0),
    left_environment_background=(COLOR,Color(0.5,0.5,0.5)),
    right_environment_background=(COLOR,Color(0.5,0.5,0.5)),
    ):
    set_camera(Rect(0,0,width=5,height=5*(3/4)))

    for (waves,path,full_wavelength) in [(short_waves,short_sine_path,8),(long_waves,long_sine_path,25)]:
        for (x,y,angle,start_time,wave_color) in waves:
            #if start_time &gt; wave_time or (wave_time-start_time) &gt; full_wavelength:
            #    continue
            push()
            translate(x,y)
            rotate(angle)
            scale(0.1)
            token = clip(Rect(wave_time-start_time,0,width=3,height=1,anchor="w"))
            color(wave_color)
            widestroke(path,0.1)
            unclip(token)
            pop()

    y0 = y1 = y2 = y3 = y4 = 0

    v = vars()

    for (x,y,color_) in ([v["%s%i"%(s,i)] for s in ["x","y","color"]] for i in xrange(7)):
        color(color_)
        dot(0.3,x,y)

    if environment_alpha &gt; 0:
        color(left_environment_background, environment_alpha)
        rectangle(-3,-0.5,-0.5,0.5)
        color(right_environment_background, environment_alpha)
        rectangle(0.5,-0.5,3,0.5)

        thickness(0.01)
        color(left_environment_background.interp(white,0.5), environment_alpha)
        frame(-3,-0.5,-0.5,0.5)
        color(right_environment_background.interp(white,0.5), environment_alpha)
        frame(0.5,-0.5,3,0.5)

        color(black,environment_alpha)
        text(-1.5+0.01,0-0.01,"Left",fonts['big'],size=0.5)
        text( 1.5+0.01,0-0.01,"Right",fonts['big'],size=0.5)

        color(white,environment_alpha)
        text(-1.5-0.01,0+0.01,"Left",fonts['big'],size=0.5)
        text( 1.5-0.01,0+0.01,"Right",fonts['big'],size=0.5)
</t>
<t tx="cog.20080203122343.1"></t>
<t tx="cog.20080203124947">starting_circles_rect = get_camera().restrict_aspect(1000)
ending_circles_rect = starting_circles_rect.outset(99.5)

circle_v = viewport.interp(starting_circles_rect,ending_circles_rect)

thousand_circles = Drawable(circle_v,draw_thousand_circles)

pause()

enter(thousand_circles)

exponential( 5, circle_v.x, 1, s=0.1 )

pause()

exit(thousand_circles)

del starting_circles_rect, ending_circles_rect, circle_v, thousand_circles
</t>
<t tx="cog.20080203130300">@
Fade in the additional site.
@c

linear(0.5,circles.color5,Color(get(circles.color5),1))

@
Make room for it!
@c

parallel()

for i in xrange(3):
    serial()
    wait(0.2*(2-i))
    smooth(1,getattr(circles,"x%i"%i),i-3,e=-0.5)
    end()

@
Move it into the newly available slot.
@c

serial()
wait(1.2)
smooth(0.5,circles.y5,0)
end()

end()

pause()

</t>
<t tx="cog.20080203132537">@
Create the five circles and put them on the screen.
@c

circles = Drawable(get_camera(),draw_five_circles)

enter(circles)

@
Attach the waves to the circle drawing.
@c

set(circles.short_waves,short_waves)
set(circles.long_waves,long_waves)</t>
<t tx="cog.20080203132537.1">@
Do the first part of the interaction animation.
@c

parallel()
linear(
    pause_to_show_thermometer,
    circles.wave_time,
    pause_to_show_thermometer*wave_speed
)
for i in xrange(5):
    serial()
    for j in xrange(pause_to_show_thermometer//5):
        linear(
            5,
            getattr(circles,"color%i"%i),
            Color(random(),random(),random())
        )
    end()
end()

pause()</t>
<t tx="cog.20080203132537.2">@
Create and fade in the thermometer.
@c

thermometer = Drawable(get_camera().right(0.2).top(0.3).inset(0.05),draw_thermometer,_alpha=0)
enter(thermometer)
fade_in(1,thermometer)

pause()

@
Lower the temperature.
@c

smooth(2,thermometer.temperature,0)

pause()</t>
<t tx="cog.20080203132537.3">@
Finish up the interaction animation, ending in the equilibrium state.
@c

parallel()
linear(
    crazy_interaction_duration-pause_to_show_thermometer,
    circles.wave_time,
    crazy_interaction_duration*wave_speed
)

n = (crazy_interaction_duration-pause_to_show_thermometer)//5
for i in xrange(5):
    serial()
    for j in xrange(n):
        linear(
            crazy_interaction_duration*(1/2)*(1/4),
            getattr(circles,"color%i"%i),
            Color(*[random()*(n-(j+1))/n+(j+1)/n*0.5 for dummy in xrange(3)])
        )
    end()
end()

pause()


</t>
<t tx="cog.20080203132537.4">@
We don't need the waves any more, so stop redrawing them.
@c

set(circles.short_waves,[])
set(circles.long_waves,[])
</t>
<t tx="cog.20080203132740"></t>
<t tx="cog.20080203132907"></t>
<t tx="cog.20080203135754">@
Create new set of waves
@c

duration = 10

short_waves = []

def create_wave_centered_at(dot_number,start_time_offset,start_time_range):
    x, angle = random_choice([(dot_number-1,0),(dot_number,0),(dot_number,180),(dot_number+1,180)])

    short_waves.append((
        x,
        random()*0.3-0.15,
        angle,
        (start_time_offset+random()*start_time_range)*wave_speed,
        Color(random(),random(),random())
    ))

for i in xrange(3):
    for dummy in xrange((i+1)*10):
        create_wave_centered_at(randint(-i,i),(duration-4)/3*i,(duration-4)/3)

@
Attach the waves to the diagram, and reset the time.
@c

set(circles.short_waves,short_waves)
set(circles.wave_time,0)</t>
<t tx="cog.20080203135754.1">@
Animate the waves and the relaxation of the site.
@c

parallel()

linear(duration,circles.wave_time,duration*wave_speed)

serial()
linear(3,circles.color5,Color(*[0.125 + 0.75*random() for dummy in xrange(3)]))
linear(3,circles.color5,Color(*[0.25 + 0.5*random() for dummy in xrange(3)]))
linear(4,circles.color5,Color(0.5,0.5,0.5))
end()

serial()
wait(2)
linear(2,circles.color2,Color(*[0.125 + 0.75*random() for dummy in xrange(3)]))
linear(3,circles.color2,Color(*[0.25 + 0.5*random() for dummy in xrange(3)]))
linear(3,circles.color2,Color(0.5,0.5,0.5))
end()

serial()
wait(2)
linear(2,circles.color3,Color(*[0.125 + 0.75*random() for dummy in xrange(3)]))
linear(3,circles.color3,Color(*[0.25 + 0.5*random() for dummy in xrange(3)]))
linear(3,circles.color3,Color(0.5,0.5,0.5))
end()

serial()
wait(4)
linear(3,circles.color1,Color(*[0.25 + 0.5*random() for dummy in xrange(3)]))
linear(3,circles.color1,Color(0.5,0.5,0.5))
end()

serial()
wait(4)
linear(3,circles.color4,Color(*[0.25 + 0.5*random() for dummy in xrange(3)]))
linear(3,circles.color4,Color(0.5,0.5,0.5))
end()

end()

pause()</t>
<t tx="cog.20080203143825"></t>
<t tx="cog.20080203143859.1">@
Fade in the additional site.
@c

linear(0.5,circles.color6,Color(get(circles.color6),1))

@
Make room for it!
@c

parallel()

wait_time = 0
for i in [5,3,4]:
    serial()
    wait(wait_time)
    wait_time += 0.2
    smooth(1,getattr(circles,"x%i"%i),get(getattr(circles,"x%i"%i))+1,e=-0.5)
    end()

end()

pause()

</t>
<t tx="cog.20080203144224">@
Replace the left and right sites with boexes denoting the environment.
@c

linear(1,circles.environment_alpha,1)

pause()
</t>
<t tx="cog.20080203151444">from slithy.library import *

print "LOADING FONTS..."

fontpath.append( '.' )
fontpath.append( '/Users/gcross/Projects/QC/Communications/SQuInT' )

create_slithy_fonts( ('wmr.pfb', 50, 'myriad.slf'),
                     ('wmb.pfb', 50, 'myriad_b.slf'),
                     ('wmbi.pfb', 50, 'myriad_bi.slf'),
                     ('wingding.ttf', 50, 'wingding.slf'),
                     ('courbd.ttf', 50, 'courier_b.slf'),
                     ('georgiab.ttf', 50, 'georgia_b.slf'),
                     )

myriad = search_font( 'myriad.slf' )
myriad_bold = search_font( 'myriad_b.slf' )
myriad_bolditalic = search_font( 'myriad_bi.slf' )
wingding = search_font( 'wingding.slf' )
courier_bold = search_font( 'courier_b.slf' )
georgia_bold = search_font( 'georgia_b.slf' )

fonts = { 'roman' : myriad,
          'big' : load_font('Chalkboard.ttf',120),
          'bold' : myriad_bold,
          'bolditalic' : myriad_bolditalic,
          'title' : myriad_bold,
          'text' : myriad,
          'mono' : courier_bold,
          'dingbats' : wingding,

          'altbold' : myriad,

          'fancy' : georgia_bold,

          }

imagepath.append( '.' )
</t>
<t tx="cog.20080203151558">@
Create and attach new set of short waves.
@c

short_waves = []

for dummy in xrange(10):
    create_wave_centered_at(0,0,3)

set(circles.short_waves,short_waves)
set(circles.wave_time,0)


@
Animate!
@c

parallel()

linear(7,circles.wave_time,7*wave_speed)

serial()
linear(3,circles.color6,Color(*([0.25 + 0.5*random() for dummy in xrange(3)])))
linear(4,circles.color6,Color(0.5))
end()

end()

pause()
</t>
<t tx="cog.20080203151959">@
Move it into the newly available slot.
@c

smooth(0.5,circles.y6,0)

pause()
</t>
<t tx="cog.20080203152336"></t>
<t tx="cog.20080203152654">@
Fade the site out.
@c

linear(1,circles.color6,Color(0.5,0))

@
Move it to the starting position and reset its color so that it appears to be a new site.
@c

set(circles.color6,Color(random(),random(),random(),0))
set(circles.x6,0)
set(circles.y6,1.5)

pause()</t>
<t tx="cog.20080203152654.1">@
Change the shade of the environment to indicate a "guess".
@c

parallel()
linear(1,circles.left_environment_background,Color(0.75,0.75,0))
linear(1,circles.right_environment_background,Color(0.75,0,0.75))
end()

pause()

</t>
<t tx="cog.20080203153419">@
Fade site in.
@c

linear(0.5,circles.color6,Color(get(circles.color6),1))

@
Move it into the slot.
@c

smooth(0.5,circles.y6,0)

@
Interact!
@c

@
Create and attach new set of short waves.
@c

short_waves = []

for dummy in xrange(4):
    create_wave_centered_at(0,0,1)

set(circles.short_waves,short_waves)
set(circles.wave_time,0)


@
Animate!
@c

parallel()

linear(4,circles.wave_time,7*wave_speed)

linear(4,circles.color6,Color(random(),random(),random()))

end()

pause()


@
Slide to left and update environment.
@c

parallel()

smooth(1,circles.x6,-1)

grey = Color(0.5)

serial()
wait(0.5)
linear(1,circles.left_environment_background,get(circles.left_environment_background).interp(grey,0.4))
end()

end()

pause()

@
Move site to the starting position and reset its color so that it appears to be a new site.
@c

set(circles.color6,Color(random(),random(),random(),0))
set(circles.x6,0)
set(circles.y6,1.5)

@
Kill sine waves.
@c

set(circles.short_waves,[])

</t>
<t tx="cog.20080203154946">current_left = 0.4
current_right = 0

def add_interact_and_move(absorb_direction):
    @others

add_interact_and_move(+1)

for i in xrange(3):
  add_interact_and_move(-1)
  add_interact_and_move(+1)

add_interact_and_move(0)

pause()
</t>
<t tx="cog.20080203154946.1">@
Fade site in while moving it into the slot.
@c

parallel()

linear(0.5,circles.color6,Color(get(circles.color6),1))
smooth(0.5,circles.y6,0)

end()
</t>
<t tx="cog.20080203154952">@
Change the site's color to show how it relaxes.
@c

global current_left, current_right

width = 1-(current_left+current_right)/2

if width &lt; 0:
    width = 0

linear(0.5,circles.color6,Color(*[(1-width)/2+width*random() for dummy in xrange(3)]))

wait(0.25)
</t>
<t tx="cog.20080203155254">@
Slide to left/right and update environment.
@c

if absorb_direction == -1:
    environment_background = circles.left_environment_background
    current_left += 0.4
    current = current_left
elif absorb_direction == +1:
    environment_background = circles.right_environment_background
    current_right += 0.4
    current = current_right
else:
    return

parallel()

smooth(0.5,circles.x6,absorb_direction)

grey = Color(0.5)

serial()
wait(0.25)

linear(0.5,environment_background,get(environment_background).interp(grey,current))
end()

end()

</t>
<t tx="cog.20080203155529">@
Move site to the starting position and reset its color so that it appears to be a new site.
@c

set(circles.color6,Color(random(),random(),random(),0))
set(circles.x6,0)
set(circles.y6,1.5)
</t>
<t tx="cog.20080203165722"></t>
<t tx="cog.20080203165722.1">def logo(
    circle_position=(SCALAR,-10,10,-2),
    circle_width=(SCALAR,0,2,0.5),
    line_1_x1=(SCALAR,-10,10,0),
    line_1_y1=(SCALAR,-2,2,0.75),
    line_1_x2=(SCALAR,-10,10,0),
    line_1_y2=(SCALAR,-2,2,-0.75),
    line_2_x1=(SCALAR,-10,10,0.75),
    line_2_y1=(SCALAR,-2,2,0),
    line_2_x2=(SCALAR,-10,10,-0.75),
    line_2_y2=(SCALAR,-2,2,-0),
    line_3_x1=(SCALAR,-10,10,2),
    line_3_y1=(SCALAR,-2,2,1),
    line_3_x2=(SCALAR,-10,10,2),
    line_3_y2=(SCALAR,-2,2,-1),
    line_4_x1=(SCALAR,-10,10,-1),
    line_4_y1=(SCALAR,-2,2,0),
    line_4_x2=(SCALAR,-10,10,-1),
    line_4_y2=(SCALAR,-2,2,0),
    dot_x=(SCALAR,-10,10,-1),
    dot_y=(SCALAR,0,0,0),
    dot_radius=(SCALAR,0,0.5,0),
    dot_color=(COLOR,Color(3/4,0,0,0)),
    bracket_position=(SCALAR,-10,10,5.5),
    path_alpha=(SCALAR,0,1,0),
    ):
    set_camera(Rect(0,0,width=10,height=4))
    color(white)
    thickness(0.2)

    def drawit():
        push()
        scale(circle_width,1,circle_position,0)
        circle(1,circle_position,0)
        pop()
        line(line_1_x1,line_1_y1,line_1_x2,line_1_y2)
        line(line_2_x1,line_2_y1,line_2_x2,line_2_y2)
        line(line_3_x1,line_3_y1,line_3_x2,line_3_y2)
        line(line_4_x1,line_4_y1,line_4_x2,line_4_y2)

    path = (
        Path()
            .moveto(line_4_x1,line_4_y1)
            .lineto(line_4_x2,line_4_y2)
            .lineto(line_2_x1,line_2_y1)
            .lineto(line_2_x2,line_2_y2)
            .lineto(line_3_x2,line_3_y2)
    )

    push()
    translate(0.1,0.1)
    color(black)
    drawit()
    color(black,path_alpha)
    widestroke(path,0.2)
    pop()

    color(1,0,1)
    drawit()
    color(1,1/8,1,path_alpha)
    widestroke(path,0.2)        

    color(dot_color)
    dot(dot_radius,dot_x,dot_y)

    color(1,1/2,1)

    line(-bracket_position,1.5,-bracket_position,-1.5)

    widestroke(
        Path()
            .moveto(bracket_position,1.5)
            .lineto(bracket_position+1,0)
            .lineto(bracket_position,-1.5)
        ,
        0.2
        )

bg = Fill( style = 'horz', color = black, color2 = blue )

def animate_logo():
    c = get_camera().restrict_aspect(10.0/4)

    my_logo = Drawable(c,logo)

    start_animation(my_logo)

    parallel()
    dt=1/2
    linear(dt,my_logo.circle_position,-1)
    linear(dt,my_logo.circle_width,0.8)
    linear(dt,my_logo.line_1_x1,-0.25)
    linear(dt,my_logo.line_1_y1,-1)
    linear(dt,my_logo.line_1_x2,0.5)
    linear(dt,my_logo.line_1_y2,1)
    linear(dt,my_logo.line_2_x1,0.5)
    linear(dt,my_logo.line_2_y1,1)
    linear(dt,my_logo.line_2_x2,1.25)
    linear(dt,my_logo.line_2_y2,-1)
    linear(dt,my_logo.line_3_x1,1.25)
    linear(dt,my_logo.line_3_y1,-1)
    linear(dt,my_logo.line_3_x2,2)
    linear(dt,my_logo.line_3_y2,1)
    end()

    parallel()
    dt=0.6/2
    smooth(dt,my_logo.dot_radius,0.15,e=-1.5)

    serial()
    wait(dt/2)
    smooth(dt/2,my_logo.dot_color,Color(3/4,1/4,0,1),e=-1.5)
    end()

    end()

    wait(0.2)

    parallel()
    dt=0.3/2
    linear(dt,my_logo.dot_x,-0.25)
    linear(dt,my_logo.dot_y,-1)
    linear(dt,my_logo.line_4_x2,-0.25)
    linear(dt,my_logo.line_4_y2,-1)
    end()

    parallel()

    dt=0.6/2

    parallel()
    linear(dt,my_logo.dot_x,0)
    linear(dt,my_logo.dot_y,0)
    linear(dt,my_logo.dot_radius,2)
    end()

    serial()
    wait(dt/4)
    parallel()
    linear(3*dt/4,my_logo.dot_color,Color(1,1/8,1,0))
    linear(3*dt/4,my_logo.path_alpha,1)
    end()
    end()

    end()

    smooth(1/2,my_logo.bracket_position,2.5,e=-0.5)

    return end_animation()

animate_logo = animate_logo()

</t>
<t tx="cog.20080203193930">def draw_wires(
     height=(SCALAR,0,1,0),
     top_highlight=(SCALAR,0,1,0),
     bottom_highlight=(SCALAR,0,1,0),
     top_alpha=(SCALAR,0,1,1),
     bottom_alpha=(SCALAR,0,1,1),
     outer_alpha=(SCALAR,0,1,1),
     center_rectangle_alpha=(SCALAR,0,1,0),
     center_site_alpha=(SCALAR,0,1,1),
     middle_alpha=(SCALAR,0,1,0),
     horribly_wrong_alpha=(SCALAR,0,1,0),
     window=(SCALAR,1,100,1),
     dot_slider=(SCALAR,0,1,1),
     dot_alpha=(SCALAR,0,1,0),
     upper_connection_length=(SCALAR,0,1,0),
     lower_connection_length=(SCALAR,0,1,0),
     upper_connection_color=(COLOR,red),
     lower_connection_color=(COLOR,red),
     upper_input_port_signal_color=(COLOR,Color(red,0)),
     lower_input_port_signal_color=(COLOR,Color(red,0)),
     upper_output_port_signal_color=(COLOR,Color(red,0)),
     lower_output_port_signal_color=(COLOR,Color(red,0)),
     upper_input_port_signal_radius=(SCALAR,0,0.3,0),
     lower_input_port_signal_radius=(SCALAR,0,0.3,0),
     upper_output_port_signal_radius=(SCALAR,0,0.3,0.15),
     lower_output_port_signal_radius=(SCALAR,0,0.3,0.15),
     everything_else_alpha=(SCALAR,0,1,0),
     ):
    set_camera(Rect(0,0,width=5*window,height=5*(3/4)*window))

    @others
</t>
<t tx="cog.20080203193930.1"></t>
<t tx="cog.20080203193930.2"></t>
<t tx="cog.20080203194441">wires = Drawable(get_camera(),draw_wires,_alpha=0)

wheres_the_cat = Text(get_camera(),text="Where's the cat???",color=yellow,justify=0.5,vjustify=0.5,_alpha=0,font=fonts['big'],size=32)

enter(wires,wheres_the_cat)

parallel()
linear(1,wires._alpha,1)
linear(1,wires.height,1)
linear(1,wheres_the_cat._alpha,1)
linear(1,circles._alpha,0)
linear(1,thermometer._alpha,0)
end()

exit(circles,thermometer)

pause()
</t>
<t tx="cog.20080204102848">push()
translate(-2,height)
for i in xrange(5):

    push()

    scale(0.75,0.75)

    push()
    color(black,(1-top_highlight)*top_alpha*(outer_alpha if i != 2 else center_site_alpha))
    translate(0.03*(1-top_highlight),-0.03*(1-top_highlight))
    widestroke(qubit,0.1)
    arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))
    pop()

    scale(1+(3/2-1)*top_highlight)

    color(white,top_alpha*(outer_alpha if i != 2 else center_site_alpha))
    widestroke(qubit,0.1)
    arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))

    pop()

    translate(1,0)
pop()
</t>
<t tx="cog.20080204102848.1">push()
scale(1,-1)
translate(-2,height)
for i in xrange(5):

    push()

    scale(0.75,0.75)

    push()
    color(black,(1-bottom_highlight)*bottom_alpha*(outer_alpha if i != 2 else center_site_alpha))
    translate(0.03*(1-bottom_highlight),+0.03*(1-bottom_highlight))
    widestroke(qubit,0.1)
    arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))
    pop()

    scale(1+(3/2-1)*bottom_highlight)

    color(white,bottom_alpha*(outer_alpha if i != 2 else center_site_alpha))
    widestroke(qubit,0.1)
    arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))

    pop()

    translate(1,0)
pop()
</t>
<t tx="cog.20080204103008">@
Highlight the top row as I mention it.
@c

parallel()
linear(0.5,wires.top_highlight,1)
linear(0.5,wires.bottom_alpha,0)
end()

pause()

@
Now highlight the bottom row.
@c


parallel()
linear(0.5,wires.top_highlight,0)
linear(0.5,wires.top_alpha,0)
linear(0.5,wires.bottom_alpha,1)
linear(0.5,wires.bottom_highlight,1)
end()

pause()

@
Return to the original slide.
@c


parallel()
linear(0.5,wires.top_alpha,1)
linear(0.5,wires.bottom_highlight,0)
end()

pause()
</t>
<t tx="cog.20080205184010">@
Fade in dot-dot-dots.
@c

linear(0.5,wires.dot_alpha,0.5)

pause()

@
Combine dots to form ports.
@c

smooth(1,wires.dot_slider,0)

pause()

</t>
<t tx="cog.20080205193134">push()

def draw_dots(signal_color,signal_radius):
    color(white.interp(grey,(1-dot_slider)*0.5),dot_alpha+(1-dot_slider)*0.5)
    dot(0.05+(1-dot_slider)*0.05,-0.2*dot_slider,0.7*dot_slider)
    dot(0.05+(1-dot_slider)*0.05, 0          ,0.7*dot_slider)
    dot(0.05+(1-dot_slider)*0.05, 0.2*dot_slider,0.7*dot_slider)
    color(black,(1-dot_slider)*dot_alpha)
    circle(0.05+(1-dot_slider)*0.03,-0.2*dot_slider,0.7*dot_slider)
    circle(0.05+(1-dot_slider)*0.03, 0             ,0.7*dot_slider)
    circle(0.05+(1-dot_slider)*0.03, 0.2*dot_slider,0.7*dot_slider)
    color(signal_color)
    dot(signal_radius,0,0)

thickness(0.01)
translate(-2.5,0.5)
draw_dots(upper_input_port_signal_color,upper_input_port_signal_radius)

thickness(0.01)
translate(5,0)
draw_dots(upper_output_port_signal_color,upper_output_port_signal_radius)

scale(1,-1)

thickness(0.01)
translate(-5,1)
draw_dots(lower_input_port_signal_color,lower_input_port_signal_radius)

thickness(0.01)
translate(5,0)
draw_dots(lower_output_port_signal_color,lower_output_port_signal_radius)

pop()
</t>
<t tx="cog.20080205193134.1">color(yellow,(1-dot_slider)*(1-everything_else_alpha))
text(-2.5,0,"INPUT\nPORTS",fonts["roman"],size=0.2,justify=0.5)
text( 2.5,0,"OUTPUT\nPORTS",fonts["roman"],size=0.2,justify=0.5)
</t>
<t tx="cog.20080205193134.2">color(upper_connection_color)
rectangle(-2.5, 0.5-0.05,-2.5+upper_connection_length*5, 0.5+0.05)

color(lower_connection_color)
rectangle(-2.5,-0.5-0.05,-2.5+lower_connection_length*5,-0.5+0.05)

color(grey,everything_else_alpha)
rectangle(-3, 0.5-0.05,4, 0.5+0.05)
rectangle(-3,-0.5-0.05,4,-0.5+0.05)
</t>
<t tx="cog.20080205194051"></t>
<t tx="cog.20080205194051.1">@
Incoming signal in upper port!
@c

parallel()
smooth(0.5,wires.upper_input_port_signal_radius,0.1,e=-0.5)
serial()
linear(0.4,wires.upper_input_port_signal_color,yellow)
linear(0.2,wires.upper_input_port_signal_color,red)
end()
end()

pause()

@
Highlight activated state component.
@c

smooth(0.5,wires.top_highlight,1)

pause()

@
Route signal to correspoding outer port.
@c

linear(1,wires.upper_connection_length,1)

@
Send signal out port
@c

parallel()
smooth(0.5,wires.upper_output_port_signal_radius,0.1,e=-0.5)
serial()
linear(0.4,wires.upper_output_port_signal_color,yellow)
linear(0.2,wires.upper_output_port_signal_color,red)
end()
end()

pause()

@
Dehighlight everything.
@c

parallel()
linear(1,wires.upper_connection_color,grey)
linear(1,wires.upper_input_port_signal_color,Color(red,0))
linear(1,wires.upper_output_port_signal_color,Color(red,0))
linear(1,wires.top_highlight,0)
end()

pause()
</t>
<t tx="cog.20080205195225">@
Incoming signal in lower port!
@c

parallel()
smooth(0.5,wires.lower_input_port_signal_radius,0.1,e=-0.5)
serial()
linear(0.4,wires.lower_input_port_signal_color,yellow)
linear(0.2,wires.lower_input_port_signal_color,red)
end()
end()


@
Route signal to correspoding outer port while highlighting the corresponding configuration.
@c

parallel()
smooth(1,wires.bottom_highlight,1)
linear(1,wires.lower_connection_length,1)
end()

@
Send signal out port.
@c

parallel()
smooth(0.5,wires.lower_output_port_signal_radius,0.1,e=-0.5)
serial()
linear(0.4,wires.lower_output_port_signal_color,yellow)
linear(0.2,wires.lower_output_port_signal_color,red)
end()
end()

pause()

@
Dehighlight everything.
@c

parallel()
linear(1,wires.lower_connection_color,grey)
linear(1,wires.lower_input_port_signal_color,Color(red,0))
linear(1,wires.lower_output_port_signal_color,Color(red,0))
linear(1,wires.bottom_highlight,0)
end()

pause()</t>
<t tx="cog.20080205195954">if everything_else_alpha &gt; 0:
    i = -1.5
    while i &lt;= 1.5:
        color(white.interp(grey,0.5),everything_else_alpha)
        dot(0.1,i,0.5)
        dot(0.1,i,-0.5)
        color(black,everything_else_alpha)
        circle(0.08,i,0.5)
        circle(0.08,i,-0.5)
        i += 1

</t>
<t tx="cog.20080205195954.1">@
Fade in the rest of the wires.
@c

linear(1,wires.everything_else_alpha,1)

pause()

@
Put a box around the center.
@c

linear(0.5,wires.center_rectangle_alpha,1)

pause()

</t>
<t tx="cog.20080205202511">@
Take it all away.
@c

fade_out(0.5,wires)
exit(wires)

del wires

pause()
</t>
<t tx="cog.20080205202511.1"></t>
<t tx="cog.20080205202554"></t>
<t tx="cog.20080205202554.1">qubit = Path().moveto(0,0).rlineto(0,0.5)</t>
<t tx="cog.20080205202933">def draw_W_state(
     highlights1=(OBJECT,[]),
     highlight_slider1=(SCALAR,0,1,0),
     highlights2=(OBJECT,[]),
     highlight_slider2=(SCALAR,0,1,0),
     rectangle_alpha=(SCALAR,0,1,0)
    ):
    set_camera(Rect(0,0,width=5,height=5))

    color(white,rectangle_alpha)
    thickness(0.01)
    frame(0,-2,1,2)

    push()

    translate(-1.5,2.5)
    for j in xrange(4):

        translate(0,-1)

        color(white,0.5)
        dot(0.03,-0.375-0.5,0)
        dot(0.03,-0.500-0.5,0)
        dot(0.03,-0.625-0.5,0)

        push()
        for i in xrange(4):

            if (i,j) in highlights1:
                highlight_slider = highlight_slider1
                highlighted = True
            elif (i,j) in highlights2:
                highlight_slider = highlight_slider2
                highlighted = True
            else:
                highlight_slider = 0
                highlighted = False

            push()

            scale_factor = 0.5+(0.125*highlight_slider if highlighted else 0)

            if i == j:
                scale(scale_factor, scale_factor)
            else:
                scale(scale_factor,-scale_factor)

            push()
            color(black,(1-highlight_slider) if highlighted else 1)

            offset = 0.075*((1-highlight_slider) if highlighted else 1)

            if i == j:
                translate(offset,-offset)
            else:
                translate(offset, offset)

            widestroke(qubit,0.1)
            arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))
            pop()

            color(white.interp(yellow,0.5*highlight_slider))
            widestroke(qubit,0.1)
            arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))

            pop()

            translate(1,0)

        translate(-1,0)

        color(white,0.5)
        dot(0.03,0.375+0.5,0)
        dot(0.03,0.500+0.5,0)
        dot(0.03,0.625+0.5,0)

        pop()

    pop()

    color(white,0.5)
    dot(0.03,0,1.875)
    dot(0.03,0,2)
    dot(0.03,0,2.125)
    dot(0.03,0,-1.875)
    dot(0.03,0,-2)
    dot(0.03,0,-2.125)
</t>
<t tx="cog.20080205203215">@
Fade in a picture of the W state.
@c

W_state = Drawable(get_camera(),draw_W_state,_alpha=0)

enter(W_state)
fade_in(0.5,W_state)

pause()
</t>
<t tx="cog.20080205211049">@
Draw a rectangle around the third site.
@c

linear(0.5,W_state.rectangle_alpha,1)

pause()</t>
<t tx="cog.20080205211049.1">r_last = W_state.highlights1
h_last = W_state.highlight_slider1

r_current = W_state.highlights2
h_current = W_state.highlight_slider2

for region in [
    [(0,0),(0,1),(1,0),(1,1)],
    [(0,2),(0,3),(1,2),(1,3)],
    [(3,0),(3,1),(3,2)],
    [(3,3)]
    ]:

    set(r_last,get(r_current))
    set(h_last,get(h_current))

    set(r_current,region)
    set(h_current,0)

    parallel()
    linear(0.5,h_last,0)
    linear(0.5,h_current,1)
    end()

    pause()
</t>
<t tx="cog.20080205211602">fade_out(0.5,W_state)

exit(W_state)
</t>
<t tx="cog.20080205220726">def draw_W_state_wirings(
        window=(SCALAR,0,4.5,1.75),
        outer_sites_alpha=(SCALAR,0,1,0),
        center_matrix_alpha=(SCALAR,0,1,0),
        center_label_alpha=(SCALAR,0,1,0),
        equation_alpha=(SCALAR,0,1,0),
        top_qubit_alpha=(SCALAR,0,1,0),
        top_qubit_highlight=(SCALAR,0,1,0),
        top_connection_length=(SCALAR,0,1,0),
        top_connection_color=(COLOR,red),
        middle_qubit_alpha=(SCALAR,0,1,0),
        middle_qubit_highlight=(SCALAR,0,1,0),
        middle_connection_length=(SCALAR,0,1,0),
        middle_connection_color=(COLOR,red),
        bottom_qubit_alpha=(SCALAR,0,1,0),
        bottom_qubit_highlight=(SCALAR,0,1,0),
        bottom_connection_length=(SCALAR,0,1,0),
        bottom_connection_color=(COLOR,red),
        center_matrix_element_alpha_00=(SCALAR,0,1,0),
        center_matrix_element_highlight_00=(SCALAR,0,1,0),
        center_matrix_element_alpha_01=(SCALAR,0,1,0),
        center_matrix_element_highlight_01=(SCALAR,0,1,0),
        center_matrix_element_alpha_10=(SCALAR,0,1,0),
        center_matrix_element_highlight_10=(SCALAR,0,1,0),
        center_matrix_element_alpha_11=(SCALAR,0,1,0),
        center_matrix_element_highlight_11=(SCALAR,0,1,0),
        signal_color_00=(COLOR,Color(red,0)),
        signal_radius_00=(SCALAR,0,0.3,0.03),
        signal_color_01=(COLOR,Color(red,0)),
        signal_radius_01=(SCALAR,0,0.3,0.03),
        signal_color_10=(COLOR,Color(red,0)),
        signal_radius_10=(SCALAR,0,0.3,0.15),
        signal_color_11=(COLOR,Color(red,0)),
        signal_radius_11=(SCALAR,0,0.3,0.15),
        row_1_highlight=(SCALAR,0,1,0),
        row_2_highlight=(SCALAR,0,1,0),
        column_1_highlight=(SCALAR,0,1,0),
        column_2_highlight=(SCALAR,0,1,0),
        matrix_index_labels_alpha=(SCALAR,0,1,0),
        arrow_alpha=(SCALAR,0,1,0),
        upper_index_highlight=(SCALAR,0,1,0),
        lower_index_highlight=(SCALAR,0,1,0),
        vector_alpha=(SCALAR,0,1,0),
        operator_slider=(SCALAR,0,1,0),
        operator_chain_alpha=(SCALAR,0,1,0),
        label_slider=(SCALAR,0,1,0),
        outer_label_alpha=(SCALAR,0,1,0),
        connection_index_label_alpha=(SCALAR,0,1,0),
        diagram_alpha=(SCALAR,0,1,1),
        environment_alpha=(SCALAR,0,1,0),
        draw_matrices=(BOOLEAN,True),
        center_circle_color=(COLOR,initial_five_colors[2]),
        center_circle_alpha=(SCALAR,0,1,1),
        center_circle_x=(SCALAR,-3,3,0),
        center_circle_y=(SCALAR,-1,1,1),
        operator_label_alpha=(SCALAR,0,1,1),
        uniform_operator_label_alpha=(SCALAR,0,1,0),
        state_chain_alpha=(SCALAR,0,1,0),
        state_chain_height=(SCALAR,0,1.375,1.375),
        left_environmonster_position=(SCALAR,-5,0,-5),
        left_environmonster_jaw_angle=(SCALAR,0,90,45),
        left_environmonster_alpha=(SCALAR,0,1,1),
        right_environmonster_position=(SCALAR,0,5,5),
        right_environmonster_jaw_angle=(SCALAR,0,90,45),
        right_environmonster_alpha=(SCALAR,0,1,1),
        left_environment_alpha=(SCALAR,0,1,0),
        right_environment_alpha=(SCALAR,0,1,0),
        left_environment_color=(COLOR,hsv(96/256,96/256,128/256)),
        right_environment_color=(COLOR,hsv(224/256,96/256,128/256)),
        environment_absorbtion_slider=(SCALAR,0,1,0),
        outer_stuff_visible=(BOOLEAN,True),
        index_merge_slider=(SCALAR,0,1,0),
        ):
    set_camera(Rect(0,-0.2,width=(4/3)*(window-0.2),height=window-0.2,anchor="n"))
    @others
</t>
<t tx="cog.20080205220726.1">thickness(0.01)

signal_colors = [[signal_color_00,signal_color_01,],[signal_color_10,signal_color_11]]

signal_radii = [[signal_radius_00,signal_radius_01,],[signal_radius_10,signal_radius_11]]


for i,x in enumerate([-0.5,0.5]):
    for j,y in enumerate([0.5,1.5]):
        color(white.interp(grey,0.5),diagram_alpha)
        dot(0.1,x,y)
        color(black,diagram_alpha)
        circle(0.08,x,y)

        color(signal_colors[i][j])
        dot(signal_radii[i][j],x,y)

</t>
<t tx="cog.20080205221106">if outer_sites_alpha &gt; 0:

    for x in [-1.5,1.5]:
        for y in [0.5,1.5]:
            color(white.interp(grey,0.5),outer_sites_alpha*diagram_alpha)
            dot(0.1,x,y)
            color(black,outer_sites_alpha*diagram_alpha)
            circle(0.08,x,y)

</t>
<t tx="cog.20080205221252">color(top_connection_color,diagram_alpha)
rectangle(-0.5,0.5-0.05,-0.5+top_connection_length,0.5+0.05)
color(bottom_connection_color,diagram_alpha)
rectangle(-0.5,1.5-0.05,-0.5+bottom_connection_length,1.5+0.05)

push()
color(middle_connection_color,diagram_alpha)
translate(-0.5,0.5)
rotate(45)
rectangle(0,-0.05,sqrt(2)*middle_connection_length,0.05)
pop()

</t>
<t tx="cog.20080205221533">if outer_sites_alpha &gt; 0:

    connection_color = Color(grey,outer_sites_alpha*diagram_alpha)

    color(connection_color)
    rectangle(-2,0.5-0.05,2,0.5+0.05)
    rectangle(-2,1.5-0.05,2,1.5+0.05)

    for x in [-1.5,0.5]:
        push()
        translate(x,0.5)
        rotate(45)
        rectangle(0,-0.05,sqrt(2),0.05)
        pop()

    faded_rectangle(connection_color,-2,-2.25,0.5,0.1)
    faded_rectangle(connection_color,-2,-2.25,1.5,0.1)
    faded_rectangle(connection_color, 2, 2.25,0.5,0.1)
    faded_rectangle(connection_color, 2, 2.25,1.5,0.1)
@
    i = 0.0125
    while i &lt;= 0.25:
        color(grey,(1-4*i)*outer_sites_alpha)
        rectangle(-2-i,0.5-0.05,-2-i+0.0125,0.5+0.05)
        rectangle(-2-i,1.5-0.05,-2-i+0.0125,1.5+0.05)
        rectangle( 2+i-0.0125,0.5-0.05,2+i,0.5+0.05)
        rectangle( 2+i-0.0125,1.5-0.05,2+i,1.5+0.05)
        i += 0.0125
@c
</t>
<t tx="cog.20080205221751">push()
translate(0,0.4)
draw_qubit(+1,alpha=top_qubit_alpha*diagram_alpha,highlight=top_qubit_highlight)
pop()

push()
translate(0,1.4)
draw_qubit(+1,alpha=bottom_qubit_alpha*diagram_alpha,highlight=bottom_qubit_highlight)
pop()


push()
translate(0,1.1)
draw_qubit(-1,alpha=middle_qubit_alpha*diagram_alpha,highlight=middle_qubit_highlight)
pop()
</t>
<t tx="cog.20080205221825">qubit_alpha = 1-operator_slider

def draw_qubit(state,alpha=1,scale_factor=1,highlight=0):
    push()

    scale_factor *= (1+0.5*highlight)

    scale(0.5*scale_factor,state*0.375*scale_factor)

    push()
    color(black,(1-highlight)*alpha*qubit_alpha)
    translate(0.03*(1-highlight),-state*0.03*(1-highlight))
    widestroke(qubit,0.1)
    arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))
    pop()

    color(white,alpha*qubit_alpha)
    widestroke(qubit,0.1)
    arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))

    pop()

    translate(1,0)
</t>
<t tx="cog.20080205222004"></t>
<t tx="cog.20080205223711"></t>
<t tx="cog.20080205223711.1"></t>
<t tx="cog.20080205230828">qubit_alpha = 1-operator_slider</t>
<t tx="cog.20080205230828.1">if outer_sites_alpha &gt; 0:

    push()
    translate(-1,0.4)
    draw_qubit(+1,alpha=outer_sites_alpha*diagram_alpha)
    pop()

    push()
    translate(-1,1.4)
    draw_qubit(+1,alpha=outer_sites_alpha*diagram_alpha)
    pop()


    push()
    translate(-1,1.1)
    draw_qubit(-1,alpha=outer_sites_alpha*diagram_alpha)
    pop()


    push()
    translate(+1,0.4)
    draw_qubit(+1,alpha=outer_sites_alpha*diagram_alpha)
    pop()

    push()
    translate(+1,1.4)
    draw_qubit(+1,alpha=outer_sites_alpha*diagram_alpha)
    pop()


    push()
    translate(+1,1.1)
    draw_qubit(-1,alpha=outer_sites_alpha*diagram_alpha)
    pop()
</t>
<t tx="cog.20080206002656">scale(1,-1)

if draw_matrices:
    @others

scale(1,-1)
</t>
<t tx="cog.20080206002656.1">def draw_matrix(
        alpha=1,
        alpha_00=1,highlight_00=0,
        alpha_01=1,highlight_01=0,
        alpha_10=1,highlight_10=0,
        alpha_11=1,highlight_11=0,
    ):
    color(white,alpha)
    thickness(0.01)
    line(-0.125,2,-0.375,2,-0.375,2.75,-0.125,2.75)
    line(+0.125,2,+0.375,2,+0.375,2.75,+0.125,2.75)

    push()
    translate(-0.175,2.15)
    draw_qubit(+1,alpha_00,highlight=highlight_00,scale_factor=0.5)
    pop()

    push()
    translate(+0.175,2.50)
    draw_qubit(+1,alpha_11,highlight=highlight_11,scale_factor=0.5)
    pop()

    push()
    translate(+0.175,2.25)
    draw_qubit(-1,alpha_10,highlight=highlight_10,scale_factor=0.5)
    pop()

    color(white,alpha_01)
    text(-0.175,2.55,"0",fonts["roman"],size=0.3+0.1*highlight_01,justify=0.25)

    push()
    scale(1,-1)

    push()
    translate(0.02,-0.02)
    color(black,operator_slider)
    text(+0.175,-2.20,"Z",fonts["bold"],size=0.3,justify=0.25)
    text(+0.175,-2.55,"I",fonts["bold"],size=0.3,justify=0.25)
    text(-0.175,-2.20,"I",fonts["bold"],size=0.3,justify=0.25)
    pop()

    color(white,operator_slider)
    text(+0.175,-2.20,"Z",fonts["bold"],size=0.3,justify=0.25)
    text(+0.175,-2.55,"I",fonts["bold"],size=0.3,justify=0.25)
    text(-0.175,-2.20,"I",fonts["bold"],size=0.3,justify=0.25)
    pop()


</t>
<t tx="cog.20080206003855">draw_matrix(
    center_matrix_alpha,
    center_matrix_element_alpha_00,
    center_matrix_element_highlight_00,
    center_matrix_element_alpha_01,
    center_matrix_element_highlight_01,
    center_matrix_element_alpha_10,
    center_matrix_element_highlight_10,
    center_matrix_element_alpha_11,
    center_matrix_element_highlight_11,
)
</t>
<t tx="cog.20080206003855.1">if outer_sites_alpha &gt; 0:
    push()
    translate(-1,0)
    draw_matrix(alpha=outer_sites_alpha)
    translate(+2,0)
    draw_matrix(alpha=outer_sites_alpha)
    pop()

    color(white,1*outer_sites_alpha)
    dot(0.02,-0.5,2.375)
    dot(0.02,+0.5,2.375)

    color(white,0.8*outer_sites_alpha)
    dot(0.02,-1.5,2.375)
    dot(0.02,+1.5,2.375)

    color(white,0.6*outer_sites_alpha)
    dot(0.02,-1.6,2.375)
    dot(0.02,+1.6,2.375)

    color(white,0.4*outer_sites_alpha)
    dot(0.02,-1.7,2.375)
    dot(0.02,+1.7,2.375)
</t>
<t tx="cog.20080206102219"></t>
<t tx="cog.20080206102219.1">cyan = Color(0,1,1)
dark_blue = Color(0,0,0.5)

def draw_matrix_label(label,upper_index_label,lower_index_label,alpha=1,upper_index_highlight=0,lower_index_highlight=0,c1=cyan,c2=dark_blue):
    color(c1.interp(c2,label_slider),alpha)
    text(0,0,label,font=fonts["big"],size=0.5,anchor="cr")
    text(0.05,0.05,upper_index_label,font=fonts["big"],size=0.25+0.125*upper_index_highlight,anchor="bl")
    text(0.05,-0.05,lower_index_label,font=fonts["big"],size=0.25+0.125*lower_index_highlight,anchor="tl")
</t>
<t tx="cog.20080206102633">push()

if center_label_alpha &gt; 0:

    translate(0,-3.125+0.75*label_slider)
    draw_matrix_label("B","b","jk",
        center_label_alpha*(1-operator_slider),
        upper_index_highlight=upper_index_highlight,
        lower_index_highlight=lower_index_highlight
        )

    if outer_sites_alpha &gt; 0:

        translate(-1,0)
        draw_matrix_label("A","a","ij",outer_sites_alpha*(1-operator_slider))

        translate(2,0)
        draw_matrix_label("C","c","kl",outer_sites_alpha*(1-operator_slider))

    if operator_slider &gt; 0:

        translate(-2,0)
        draw_matrix_label("A","aa'","ij",outer_sites_alpha*operator_slider*operator_label_alpha)

        translate(1,0)
        draw_matrix_label("B","bb'","jk",outer_sites_alpha*operator_slider*operator_label_alpha)

        translate(1,0)
        draw_matrix_label("C","cc'","kl",outer_sites_alpha*operator_slider*operator_label_alpha)

    if outer_label_alpha &gt; 0:
        translate(-3,0.75*(1-label_slider))
        draw_matrix_label("Z","zz'","hi",outer_label_alpha*operator_label_alpha)

        translate(+4,0)
        draw_matrix_label("D","dd'","lm",outer_label_alpha*operator_label_alpha)

        translate(-2,0)

    if uniform_operator_label_alpha &gt; 0:

        color(dark_blue,uniform_operator_label_alpha)

        if outer_stuff_visible:
            for x in xrange(-2,3):
                if x == 0:
                    continue
                else:
                    text(x,0,"H",font=fonts["big"],size=0.5)

        color(dark_blue,uniform_operator_label_alpha*center_circle_alpha)
        text(center_circle_x,0,"H",font=fonts["big"],size=0.5)

pop()

</t>
<t tx="cog.20080206105228">if equation_alpha &gt; 0:
    image(0,-4,mps_equation,height=0.8,alpha=equation_alpha*(1-operator_slider))

    if operator_slider &gt; 0:
        image(0,-4,mpo_equation,height=0.7,alpha=equation_alpha*operator_slider)

</t>
<t tx="cog.20080206105306">mps_equation = load_image("mps.png")
mpo_equation = load_image("mpo.png")
</t>
<t tx="cog.20080206111833">@
Fade in W state with wiring
@c

W_state_wirings = Drawable(get_camera(),draw_W_state_wirings,_alpha=0)

enter(W_state_wirings)
fade_in(1,W_state_wirings)

pause()
</t>
<t tx="cog.20080206111833.1">@
Zoom out to show the matrix under the wirings.
@c

smooth(1,W_state_wirings.window,2.9)
linear(0.5,W_state_wirings.center_matrix_alpha,1)

pause()
</t>
<t tx="cog.20080206111905">@
Zoom out to show the matrix label.
@c

smooth(1,W_state_wirings.window,3.55)
linear(0.5,W_state_wirings.center_label_alpha,1)

pause()
</t>
<t tx="cog.20080206111917">@
Zoom out to show the equation
@c

smooth(1,W_state_wirings.window,4.5)
linear(0.5,W_state_wirings.equation_alpha,1)

pause()
</t>
<t tx="cog.20080206112012">@
Fade in the outer sites.
@c

linear(1,W_state_wirings.outer_sites_alpha,1)

pause()

</t>
<t tx="cog.20080206114238">@
Highlight and fade in each matrix element.
@c

set(W_state_wirings.signal_radius_00,0.05)
set(W_state_wirings.signal_radius_01,0.05)
set(W_state_wirings.signal_radius_10,0.05)
set(W_state_wirings.signal_radius_11,0.05)

set(W_state_wirings.signal_color_00,Color(purple,0))
set(W_state_wirings.signal_color_01,Color(purple,0))
set(W_state_wirings.signal_color_10,Color(purple,0))
set(W_state_wirings.signal_color_11,Color(purple,0))

linear(0.5,W_state_wirings.matrix_index_labels_alpha,1)

pause()

parallel()
smooth(0.5,W_state_wirings.top_qubit_highlight,1)
linear(0.5,W_state_wirings.center_matrix_element_alpha_00,1)
smooth(0.5,W_state_wirings.center_matrix_element_highlight_00,1)
linear(0.5,W_state_wirings.signal_color_00,purple)
linear(0.5,W_state_wirings.signal_color_10,purple)
linear(0.5,W_state_wirings.top_connection_color,purple)
smooth(0.5,W_state_wirings.row_1_highlight,1)
smooth(0.5,W_state_wirings.column_1_highlight,1)
end()

pause()


parallel()
smooth(0.5,W_state_wirings.top_qubit_highlight,0)
smooth(0.5,W_state_wirings.center_matrix_element_highlight_00,0)
smooth(0.5,W_state_wirings.middle_qubit_highlight,1)
linear(0.5,W_state_wirings.center_matrix_element_alpha_10,1)
smooth(0.5,W_state_wirings.center_matrix_element_highlight_10,1)
linear(0.5,W_state_wirings.signal_color_10,Color(purple,0))
linear(0.5,W_state_wirings.signal_color_11,purple)
linear(0.5,W_state_wirings.top_connection_color,grey)
linear(0.5,W_state_wirings.middle_connection_color,purple)
smooth(0.5,W_state_wirings.column_1_highlight,0)
smooth(0.5,W_state_wirings.column_2_highlight,1)
end()

pause()


parallel()
smooth(0.5,W_state_wirings.middle_qubit_highlight,0)
smooth(0.5,W_state_wirings.center_matrix_element_highlight_10,0)
smooth(0.5,W_state_wirings.bottom_qubit_highlight,1)
linear(0.5,W_state_wirings.center_matrix_element_alpha_11,1)
smooth(0.5,W_state_wirings.center_matrix_element_highlight_11,1)
linear(0.5,W_state_wirings.signal_color_00,Color(purple,0))
linear(0.5,W_state_wirings.signal_color_01,purple)
linear(0.5,W_state_wirings.middle_connection_color,grey)
linear(0.5,W_state_wirings.bottom_connection_color,purple)
smooth(0.5,W_state_wirings.row_1_highlight,0)
smooth(0.5,W_state_wirings.row_2_highlight,1)
end()

pause()



parallel()
smooth(0.5,W_state_wirings.bottom_qubit_highlight,0)
smooth(0.5,W_state_wirings.center_matrix_element_highlight_11,0)
linear(0.5,W_state_wirings.center_matrix_element_alpha_01,1)
smooth(0.5,W_state_wirings.center_matrix_element_highlight_01,1)
linear(0.5,W_state_wirings.signal_color_11,Color(purple,0))
linear(0.5,W_state_wirings.signal_color_10,purple)
linear(0.5,W_state_wirings.bottom_connection_color,grey)
smooth(0.5,W_state_wirings.column_2_highlight,0)
smooth(0.5,W_state_wirings.column_1_highlight,1)
end()

pause()


parallel()
smooth(0.5,W_state_wirings.center_matrix_element_highlight_01,0)
linear(0.5,W_state_wirings.signal_color_10,Color(purple,0))
linear(0.5,W_state_wirings.signal_color_01,Color(purple,0))
smooth(0.5,W_state_wirings.column_1_highlight,0)
smooth(0.5,W_state_wirings.row_2_highlight,0)
linear(0.5,W_state_wirings.matrix_index_labels_alpha,0)
end()

pause()
</t>
<t tx="cog.20080206121251">
</t>
<t tx="cog.20080206122604">@
Incoming signal in upper port!
@c

parallel()
smooth(0.5,W_state_wirings.signal_radius_00,0.1,e=-0.5)
serial()
linear(0.4,W_state_wirings.signal_color_00,yellow)
linear(0.2,W_state_wirings.signal_color_00,red)
end()
end()

pause()


@
Choice:  spin down here.
@c

parallel()
linear(1,W_state_wirings.top_qubit_alpha,1)
smooth(1,W_state_wirings.top_qubit_highlight,1)
linear(1,W_state_wirings.top_connection_length,1)
end()

parallel()
smooth(0.5,W_state_wirings.signal_radius_10,0.1,e=-0.5)
serial()
linear(0.4,W_state_wirings.signal_color_10,yellow)
linear(0.2,W_state_wirings.signal_color_10,red)
end()
end()

pause()

parallel()
linear(0.5,W_state_wirings.signal_color_10,Color(red,0))
linear(0.5,W_state_wirings.top_connection_color,grey)
smooth(0.5,W_state_wirings.top_qubit_highlight,0)
end()

pause()



@
Choice:  spin up here.
@c

parallel()
linear(1,W_state_wirings.middle_qubit_alpha,1)
smooth(1,W_state_wirings.middle_qubit_highlight,1)
linear(1,W_state_wirings.middle_connection_length,1)
end()

parallel()
smooth(0.5,W_state_wirings.signal_radius_11,0.1,e=-0.5)
serial()
linear(0.4,W_state_wirings.signal_color_11,yellow)
linear(0.2,W_state_wirings.signal_color_11,red)
end()
end()

pause()

parallel()
linear(0.5,W_state_wirings.signal_color_11,Color(red,0))
linear(0.5,W_state_wirings.signal_color_00,Color(red,0))
linear(0.5,W_state_wirings.middle_connection_color,grey)
smooth(0.5,W_state_wirings.middle_qubit_highlight,0)
end()

set(W_state_wirings.signal_radius_11,0.2)

pause()

</t>
<t tx="cog.20080206122604.1">@
Incoming signal in lower port!
@c

parallel()
smooth(0.5,W_state_wirings.signal_radius_01,0.1,e=-0.5)
serial()
linear(0.4,W_state_wirings.signal_color_01,yellow)
linear(0.2,W_state_wirings.signal_color_01,red)
end()
end()

pause()


@
Choice:  spin down here.
@c

parallel()
linear(1,W_state_wirings.bottom_qubit_alpha,1)
smooth(1,W_state_wirings.bottom_qubit_highlight,1)
linear(1,W_state_wirings.bottom_connection_length,1)
end()

parallel()
smooth(0.5,W_state_wirings.signal_radius_11,0.1,e=-0.5)
serial()
linear(0.4,W_state_wirings.signal_color_11,yellow)
linear(0.2,W_state_wirings.signal_color_11,red)
end()
end()

pause()

parallel()
linear(0.5,W_state_wirings.signal_color_11,Color(red,0))
linear(0.5,W_state_wirings.signal_color_01,Color(red,0))
linear(0.5,W_state_wirings.bottom_connection_color,grey)
smooth(0.5,W_state_wirings.bottom_qubit_highlight,0)
end()

pause()


</t>
<t tx="cog.20080206214555">if arrow_alpha &gt; 0:
    def draw_arrow(alpha=1):
        color(yellow,alpha)
        thickness(0.05)
        line(0,-0.375,0,+0.375)
        polygon(-0.1, 0.375,0, 0.5,+0.1, 0.375)
        polygon(-0.1,-0.375,0,-0.5,+0.1,-0.375)


    push()
    translate(-0.5,-2.375)
    scale(0.75,0.75)
    draw_arrow(arrow_alpha)
    pop()


    push()
    translate(0,-1.85)
    scale(0.75,0.75)
    rotate(90)
    draw_arrow(arrow_alpha)
    pop()

</t>
<t tx="cog.20080207000444">@
Highlight subscript and associated arrows.
@c

parallel()
smooth(0.5,W_state_wirings.lower_index_highlight,1)
linear(0.5,W_state_wirings.arrow_alpha,1)
end()

pause()

@
Highlight superscript and matrix elements.
@c

parallel()
smooth(0.5,W_state_wirings.lower_index_highlight,0)
smooth(0.5,W_state_wirings.upper_index_highlight,1)
linear(0.5,W_state_wirings.arrow_alpha,0)
smooth(0.5,W_state_wirings.center_matrix_element_highlight_00,1)
smooth(0.5,W_state_wirings.center_matrix_element_highlight_01,1)
smooth(0.5,W_state_wirings.center_matrix_element_highlight_10,1)
smooth(0.5,W_state_wirings.center_matrix_element_highlight_11,1)
end()

pause()

@
Replace matrix elements with vectors.
@c

parallel()
linear(0.5,W_state_wirings.center_matrix_element_alpha_00,0)
linear(0.5,W_state_wirings.center_matrix_element_alpha_01,0)
linear(0.5,W_state_wirings.center_matrix_element_alpha_10,0)
linear(0.5,W_state_wirings.center_matrix_element_alpha_11,0)
linear(0.5,W_state_wirings.top_qubit_alpha,0)
linear(0.5,W_state_wirings.middle_qubit_alpha,0)
linear(0.5,W_state_wirings.bottom_qubit_alpha,0)
linear(0.5,W_state_wirings.vector_alpha,1)
end()

set(W_state_wirings.center_matrix_element_highlight_00,0)
set(W_state_wirings.center_matrix_element_highlight_01,0)
set(W_state_wirings.center_matrix_element_highlight_10,0)
set(W_state_wirings.center_matrix_element_highlight_11,0)

pause()

@
Dehighlight everything and fade labels back in.
@c

parallel()
linear(0.5,W_state_wirings.vector_alpha,0)
linear(0.5,W_state_wirings.center_matrix_element_alpha_00,1)
linear(0.5,W_state_wirings.center_matrix_element_alpha_01,1)
linear(0.5,W_state_wirings.center_matrix_element_alpha_10,1)
linear(0.5,W_state_wirings.center_matrix_element_alpha_11,1)
linear(0.5,W_state_wirings.top_qubit_alpha,1)
linear(0.5,W_state_wirings.middle_qubit_alpha,1)
linear(0.5,W_state_wirings.bottom_qubit_alpha,1)
smooth(0.5,W_state_wirings.upper_index_highlight,0)
end()

pause()

</t>
<t tx="cog.20080209113402">color(white,operator_chain_alpha)
thickness(0.1)

if outer_stuff_visible:
    line(-2,-2.375,2,-2.375)

    faded_rectangle(Color(white,operator_chain_alpha),-2.375,-2.375-0.25,-2.375,0.1)
    faded_rectangle(Color(white,operator_chain_alpha),+2.375,+2.375+0.25,-2.375,0.1)
else:
    line(-1.625*(1-environment_absorbtion_slider),-2.375,+1.625*(1-environment_absorbtion_slider),-2.375)

def draw_line_with_cave(x,y,thickness,height):
    push()
    translate(x,y)
    scale(thickness/2,height/2)
    polygon(0,0,-1,0,-1,1,0,2/3,1,1,1,0)
    pop()

border_color = Color(white,operator_chain_alpha)
fill_color = Color(grey,operator_chain_alpha)
thickness(0.01)

if outer_stuff_visible:
    for x in xrange(-2,3):
        if x == 0:
            continue
        draw_centered_rectangle(x,-2.375,.75,.75,border_color,fill_color)
        draw_line_with_cave(x,-2,0.1,0.25)
        draw_line_with_cave(x,-2.75,0.1,-0.25)

draw_centered_rectangle(center_circle_x,-2.375,.75,.75,Color(border_color,operator_chain_alpha*center_circle_alpha),Color(fill_color,operator_chain_alpha*center_circle_alpha))
draw_line_with_cave(center_circle_x,-2,0.1,0.25)
draw_line_with_cave(center_circle_x,-2.75,0.1,-0.25)
</t>
<t tx="cog.20080209114750"></t>
<t tx="cog.20080209114750.1"></t>
<t tx="cog.20080209114750.2">from __future__ import division
from timetracker import *

from objects import *

from numpy import arange, array, complex128, zeros, argsort, dot as dot_product, real, trace, identity, conj
from numpy.linalg import norm
from numpy.random import rand

from Graph import Graph, Subgraph

from random import shuffle

from InfiniteOpenProductState import multiply_tensor_by_matrix_at_index, special_left_multiply, special_right_multiply, my_eigen

@others
</t>
<t tx="cog.20080209114750.3">@
Fade in the chain of operators atop the matrices.
@c

linear(0.5,W_state_wirings.operator_chain_alpha,1)

set(W_state_wirings.draw_matrices,False)

pause()

@
Slide the labels into the operator chain
@c

smooth(0.5,W_state_wirings.label_slider,1)
linear(0.5,W_state_wirings.outer_label_alpha,1)

pause()

@
Label the connections.
@c

linear(0.5,W_state_wirings.connection_index_label_alpha,1)

pause()

@
Fade out connection labels.
@c

linear(0.5,W_state_wirings.connection_index_label_alpha,0)

pause()

@
Replace tensor notation with "O"
@c


linear(0.5,W_state_wirings.operator_label_alpha,0)
linear(0.5,W_state_wirings.uniform_operator_label_alpha,1)

pause()
</t>
<t tx="cog.20080209114750.4"></t>
<t tx="cog.20080209114750.5"></t>
<t tx="cog.20080209114911"></t>
<t tx="cog.20080209114911.1"></t>
<t tx="cog.20080209114911.2"></t>
<t tx="cog.20080209121118"></t>
<t tx="cog.20080209121350">scale(1,-1)

if diagram_alpha &gt; 0:

    @others

scale(1,-1)

</t>
<t tx="cog.20080209121350.1">def draw_connection_labels():
    for x, index in [
         (-1.5,"i"),
         (-0.5,"j"),
         (+0.5,"k"),
         (+1.5,"l"),
         ]:

        text(x,0,index,fonts["big"],anchor="cc",size=0.3)

    for x, index in [
         (-2,"z"),
         (-1,"a"),
         (-0,"b"),
         (+1,"c"),
         (+2,"d"),
         ]:

        text(x, 0.625,index,fonts["big"],anchor="cc",size=0.3)
        text(x,-0.625,index+"'",fonts["big"],anchor="cc",size=0.3)


draw_with_shadows(0,-2.375,0.015,draw_connection_labels,Color(0.25,0.5,1),connection_index_label_alpha)
</t>
<t tx="cog.20080209123403">@
Fade in the old environment picture.
@c

linear(0.5,W_state_wirings.diagram_alpha,0)
linear(0.5,W_state_wirings.environment_alpha,1)

pause()

@
Remind audience of earlier animation.
@c

def drop_and_absorb(direction):
    smooth(0.5,W_state_wirings.center_circle_y,-1)
    linear(0.5,W_state_wirings.center_circle_color,grey)
    smooth(0.5,W_state_wirings.center_circle_x,direction)
    set(W_state_wirings.center_circle_color,Color(random(),random(),random()))
    set(W_state_wirings.center_circle_x,0)
    set(W_state_wirings.center_circle_y,1)

direction = -1
for i in xrange(4):
    drop_and_absorb(direction)
    direction *= -1

smooth(0.5,W_state_wirings.center_circle_y,-1)
linear(0.5,W_state_wirings.center_circle_color,grey)

pause()
</t>
<t tx="cog.20080209124808">if environment_alpha &gt; 0:

    color(center_circle_color, environment_alpha)
    dot(0.375,center_circle_x,center_circle_y)

    border_color = Color(white,environment_alpha)
    fill_color = Color(grey,environment_alpha)

    thickness(0.01)
    draw_centered_rectangle(-1.5,-1,2,0.75,border_color,fill_color)
    draw_centered_rectangle(+1.5,-1,2,0.75,border_color,fill_color)

@
    color(grey, environment_alpha)
    rectangle(-2.5,-1.5,-0.5,-0.5)
    rectangle(+0.5,-1.5,+2.5,-0.5)

    color(white, environment_alpha)
    thickness(0.01)
    frame(-2.5,-1.5,-0.5,-0.5)
    frame(+0.5,-1.5,+2.5,-0.5)
@c

    def draw_environment_labels():
        t = text(-1.5,0,"Left",fonts["big"],size=0.5,anchor="cc")
        text(+1.5,t['bottom'],"Right",fonts["big"],size=0.5,anchor="lc")

    draw_with_shadows(0,-1,0.025,draw_environment_labels,white,environment_alpha)
</t>
<t tx="cog.20080209125111"></t>
<t tx="cog.20080209125617">def faded_rectangle(c,x1,x2,y,height):
    dx = (x2-x1)/20
    x = x1
    y1 = y-height/2
    y2 = y+height/2
    c_final = Color(c,0)
    for i in xrange(20):
        color(c.interp(c_final,i/20))
        rectangle(x,y1,x+dx,y2)
        x += dx
</t>
<t tx="cog.20080209130316">def draw_with_shadows(x,y,offset,f,top_color,alpha=1):
    push()
    translate(x+offset/2,y-offset/2)
    color(black,alpha)
    f()
    translate(-offset,offset)
    color(top_color,alpha)
    f()
    pop()
</t>
<t tx="cog.20080209135843">def draw_line_with_protrusion(x,y,thickness,height):
    push()
    translate(x,y)
    scale(thickness/2,height/2)
    polygon(0,0,-1,0,-1,1,0,1+1/3,1,1,1,0)
    pop()

if state_chain_alpha &gt; 0:

    push()

    translate(0,-2.375)

    connection_color = Color(white,state_chain_alpha)

    if outer_stuff_visible:

        for y in [+state_chain_height,-state_chain_height]:
            push()
            translate(0,y)
            color(connection_color)
            thickness(0.1)
            line(-2,0,2,0)
            faded_rectangle(connection_color,-2.375,-2.375-0.25,0,0.1)
            faded_rectangle(connection_color,+2.375,+2.375+0.25,0,0.1)
            pop()

    else:
        offset = 0.25*(1-index_merge_slider)+0.05*index_merge_slider
        x = 1.625*(1-environment_absorbtion_slider) + offset*environment_absorbtion_slider
        y = state_chain_height*(1-environment_absorbtion_slider)
        thickness(0.1)
        line(-offset,-state_chain_height,-x,-y)
        line(+offset,-state_chain_height,+x,-y)
        line(-offset,+state_chain_height,-x,+y)
        line(+offset,+state_chain_height,+x,+y)

    def draw_circle(direction,c):
        color(c,state_chain_alpha*center_circle_alpha)
        dot(0.375,0,0)
        color(dark_blue,state_chain_alpha*center_circle_alpha)
        if direction == -1:
            text(0,0,"S",fonts["big"],anchor="cc",size=0.5)
        else:
            text(0,0,"S*",fonts["big"],anchor="cc",size=0.5)
        color(white,state_chain_alpha*center_circle_alpha)
        circle(0.375,0,0)
        draw_line_with_protrusion(0,direction*0.375,0.1,direction*0.25)

    thickness(0.01)

    if outer_stuff_visible:
        for x in xrange(-2,3):
            if x == 0:
                continue

            c = initial_five_colors[x+2]

            push()
            translate(x,+state_chain_height)
            draw_circle(-1,c)
            pop()

            push()
            translate(x,-state_chain_height)
            draw_circle(+1,c)
            pop()

    push()
    translate(center_circle_x,+state_chain_height)
    draw_circle(-1,center_circle_color)
    pop()

    push()
    translate(center_circle_x,-state_chain_height)
    draw_circle(+1,center_circle_color)
    pop()

    pop()

</t>
<t tx="cog.20080209140327">@
Replace tensor notation with "O"
@c

set(W_state_wirings.center_circle_color,Color(random(),random(),random()))

parallel()
linear(0.5,W_state_wirings.equation_alpha,0)
linear(0.5,W_state_wirings.environment_alpha,0)
linear(0.5,W_state_wirings.state_chain_alpha,1)
end()

pause()</t>
<t tx="cog.20080209142243">@
Connect the states and operators together to form an expectation network.
@c

smooth(0.5,W_state_wirings.state_chain_height,1)

pause()
</t>
<t tx="cog.20080209145629">monster_width = 2
monster_height = 3

number_of_teeth = 4
tooth_width = monster_width/(number_of_teeth+1)
tooth_height = tooth_width*1.25

dx = tooth_width/2
x = tooth_width

tooth_points = [0,0,dx,0]

for i in xrange(number_of_teeth):
    tooth_points.extend([x,tooth_height])
    x += dx
    tooth_points.extend([x,0])
    x += dx

tooth_points.extend([x,0])

upper_jaw_points = [monster_width,monster_height/2,0,monster_height/2]
lower_jaw_points = [monster_width,-monster_height/2,0,-monster_height/2]

def draw_environmonster(x,jaw_angle,direction,alpha,color_):

    push()
    translate(x,-2.375)

    push()
    scale(direction,1)

    push()
    rotate(-jaw_angle)
    color(color_,alpha)
    polygon(*(tooth_points+lower_jaw_points))
    pop()

    push()
    rotate(jaw_angle)
    color(color_,alpha)
    polygon(*(tooth_points+upper_jaw_points))
    translate(monster_width*3/4,monster_height*1/4)
    rotate(-30)
    token = clip(Rect(-0.5,-0.5,0.5,0))
    push()
    scale(1,0.75)
    color(white,alpha)
    dot(0.5)
    pop()

    push()
    translate(0.2,0)
    color(black,alpha)
    dot(0.2)
    pop()
    unclip(token)
    pop()

    pop()

    pop()

draw_environmonster(left_environmonster_position,left_environmonster_jaw_angle,+1,left_environmonster_alpha,left_environment_color)
draw_environmonster(right_environmonster_position,right_environmonster_jaw_angle,-1,right_environmonster_alpha,right_environment_color)

</t>
<t tx="cog.20080209150019">@
Have the environmonster eat the left and right sites.
@c

parallel()
smooth(1.5,W_state_wirings.left_environmonster_position,-2.625)

serial()
wait(0.75)
linear(0.75,W_state_wirings.left_environmonster_jaw_angle,0)
end()

end()

pause()

linear(0.5,W_state_wirings.left_environment_alpha,1)

set(W_state_wirings.left_environmonster_alpha,0)

pause()


parallel()
smooth(1.5,W_state_wirings.right_environmonster_position,2.625)

serial()
wait(0.75)
linear(0.75,W_state_wirings.right_environmonster_jaw_angle,0)
end()

end()

pause()

linear(0.5,W_state_wirings.right_environment_alpha,1)

set(W_state_wirings.right_environmonster_alpha,0)

pause()


</t>
<t tx="cog.20080209154613">draw_centered_rectangle(
    -1.625*(1-environment_absorbtion_slider),
    -2.375,
    monster_width*(1-environment_absorbtion_slider) + 0.75*environment_absorbtion_slider,
    monster_height*(1-environment_absorbtion_slider) + 0.75*environment_absorbtion_slider,
    Color(white,left_environment_alpha),
    Color(left_environment_color,left_environment_alpha)
    )

color(dark_blue,left_environment_alpha)
t = text(-1.625*(1-environment_absorbtion_slider),-2.375,"Left",fonts["big"],size=0.5*(1-environment_absorbtion_slider)+0.2*environment_absorbtion_slider,anchor="cc")

draw_centered_rectangle(
    +1.625*(1-environment_absorbtion_slider),
    -2.375,
    monster_width*(1-environment_absorbtion_slider) + 0.75*environment_absorbtion_slider,
    monster_height*(1-environment_absorbtion_slider) + 0.75*environment_absorbtion_slider,
    Color(white,right_environment_alpha),
    Color(right_environment_color,right_environment_alpha)
    )

color(dark_blue,right_environment_alpha)
text(1.625*(1-environment_absorbtion_slider),t['bottom'],"Right",fonts["big"],size=0.5*(1-environment_absorbtion_slider)+0.2*environment_absorbtion_slider,anchor="lc")

</t>
<t tx="cog.20080209154832">def draw_centered_rectangle(x,y,width,height,border_color,fill_color):
    color(fill_color)
    rectangle(x-width/2,y-height/2,x+width/2,y+height/2)
    color(border_color)
    frame(x-width/2,y-height/2,x+width/2,y+height/2)
</t>
<t tx="cog.20080209162206.1">left_hue = 96/256
right_hue = 224/256
current_left = 96/256
current_right = 96/256

ds = current_left/2

def add_interact_and_move(absorb_direction,with_pauses=False):
    @others

add_interact_and_move(-1,with_pauses=True)
add_interact_and_move(+1)
add_interact_and_move(-1)
add_interact_and_move(+1)

linear(0.5,W_state_wirings.center_circle_color,grey)

pause()
</t>
<t tx="cog.20080209162206.2">@
Fade site in while moving it into the slot.
@c

linear(0.5,W_state_wirings.center_circle_alpha,1)

if with_pauses:
    pause()
else:
    wait(0.25)
</t>
<t tx="cog.20080209162206.3">@
Change the site's color to show how it relaxes.
@c

global current_left, current_right

width = (current_left+current_right)/2

if width &lt; 0:
    width = 0

linear(0.5,W_state_wirings.center_circle_color,hsv(random(),random()*width,0.5+(random()-0.5)*width))

if with_pauses:
    pause()
else:
    wait(0.25)
</t>
<t tx="cog.20080209162206.4">@
Slide to left/right and update environment.
@c

if absorb_direction == -1:
    environment_background = W_state_wirings.left_environment_color
    current_left -= ds
    current_color = hsv(left_hue,current_left,0.5)
elif absorb_direction == +1:
    environment_background = W_state_wirings.right_environment_color
    current_right -= ds
    current_color = hsv(right_hue,current_right,0.5)
else:
    return

parallel()

smooth(0.5,W_state_wirings.center_circle_x,absorb_direction)

grey = Color(0.5)

serial()
wait(0.25)

linear(0.5,environment_background,current_color)
end()

end()

if with_pauses:
    pause()

</t>
<t tx="cog.20080209162206.5">@
Move site to the starting position and reset its color so that it appears to be a new site.
@c

set(W_state_wirings.center_circle_alpha,0)
set(W_state_wirings.center_circle_color,Color(random(),random(),random()))
set(W_state_wirings.center_circle_x,0)
</t>
<t tx="cog.20080210105032"></t>
<t tx="cog.20080210105134">"""Calculates the ground state energy of the transverse ising model."""

#import sys
#sys.stdout = open("log","w")

@others

</t>
<t tx="cog.20080210105134.1">@
Import the needed modules.  Just for kicks, we time this process since sometimes it takes longer than the actual computation!
@c
from timetracker import *
uber_timestamp = start_timing_event("Importing modules...")

from dequeue import dequeue

import numpy
from numpy import set_printoptions,array
import sys


#from numpy import multiply
from numpy.linalg import norm
from numpy.random import rand
from numpy import exp, log, imag, isfinite

import scipy
import scipy.linalg
from scipy.linalg.matfuncs import logm, expm

finished_timing_event(uber_timestamp,"done; %i seconds taken.")

try:
    #import psyco
    #print "Using Psyco!"
    #psyco.full()
    #psyco.profile()
    #psyco.log()
    pass
except ImportError:
    pass

from InfiniteOpenProductState import *

from time import time

@
import hotshot
prof = hotshot.Profile("stones.prof")
prof.start()

@c

from copy import copy, deepcopy

from scipy.linalg import svd, eigvals, schur

</t>
<t tx="cog.20080210105134.2">@
Tell the system that it's okay to put more than 72 characters on a line...
@c
set_printoptions(precision=4,linewidth=120)</t>
<t tx="cog.20080210105134.3">@
Parameters are read from the command line;  if one or more are omitted, hard-coded defaults are used instead.

First we setup a table with the names and types of parameters, as well as their default values.
@c

parameters = [
    ("lam","lambda",float,0.5),
    ("auxiliary_dimension","auxiliary dimension",int,5),
    ]


@
If the user does not specify any parameters, then it might be because he or she does not know what the command-line
arguments are.  Display a help message just in case.
@c
print
if len(sys.argv) == 1:
    print "Usage:  %s %s" % (sys.argv[0],' '.join(map(lambda p: "[%s]"%p,zip(*parameters)[1])))
    print 
    print "When one or more of these parameters is omitted, defaults are employed in their stead."
    print
    print "(Even though no parameters were specified, this program will continue to run using the defaults.)"
    print

@
First parse whatever arguments are given by the user.
@c
i = 1
while len(sys.argv) &gt; i and i &lt;= len(parameters):
    parameter_variable, parameter_name, parameter_type, default_value = parameters[i-1]
    parameter_value = parameter_type(sys.argv[i])
    print parameter_name,"=",parameter_value
    globals()[parameter_variable] = parameter_value
    i += 1

@
Now fill in the rest of the parameters with the defaults.
@c
while i &lt;= len(parameters):
    parameter_variable, parameter_name, parameter_type, default_value = parameters[i-1]
    print "Using default value",default_value,"for %s." % parameter_name
    globals()[parameter_variable] = default_value
    i += 1

</t>
<t tx="cog.20080210105134.4">number_of_sites=10

timestamp = start_timing_event("Initializing configuration (including pre-normalization of sites array)...")

open_site_boundary = rand(auxiliary_dimension)
#open_site_boundary = array([1,]+[1,]*(auxiliary_dimension-1))

system = OneDimensionalSystem(
    site_dimension=2,
    auxiliary_dimension=auxiliary_dimension,
    initial_left_site_boundary=open_site_boundary,
    initial_right_site_boundary=open_site_boundary,
    )

finished_timing_event(timestamp,"done; %i seconds taken.")

@
Create the Hamiltonian.
@c

Z = array([1,0,0,-1],complex128).reshape(2,2)
Y = array([0,1j,-1j, 0],complex128).reshape(2,2)
X = array([0,1,1, 0],complex128).reshape(2,2)
I = array([1,0,0, 1],complex128).reshape(2,2)


if False:
    &lt;&lt; Super Sparse operators &gt;&gt;
elif False:
    &lt;&lt; Sparse operators &gt;&gt;
else:
    &lt;&lt; Dense operators &gt;&gt;

system.terms.append(spin_coupling_term)
</t>
<t tx="cog.20080210105134.5">from sparse_tensor import sparse_tensor

sparse_magnetic_left = sparse_tensor((2,),())
sparse_magnetic_left[0] = 1

sparse_magnetic_right = sparse_tensor((2,),())
sparse_magnetic_right[1] = 1

magnetic_field_operator_matrix = sparse_tensor((2,2,),(2,2))
magnetic_field_operator_matrix[0,0] =  I
magnetic_field_operator_matrix[1,1] =  I
magnetic_field_operator_matrix[0,1] = -Z
magnetic_field_term = MatrixProductOperatorTermWithOpenBoundaryConditions(
    system,
    magnetic_field_operator_matrix,
    sparse_magnetic_left,
    sparse_magnetic_right,
    )


sparse_spin_coupling_left = sparse_tensor((3,),())
sparse_spin_coupling_left[0] = 1

sparse_spin_coupling_right = sparse_tensor((3,),())
sparse_spin_coupling_right[2] = 1

spin_coupling_operator_matrix = sparse_tensor((3,3),(2,2))
spin_coupling_operator_matrix[0,0] =  I
spin_coupling_operator_matrix[2,2] =  I
spin_coupling_operator_matrix[0,1] =  X*(-lam)
spin_coupling_operator_matrix[1,2] =  X
spin_coupling_term = MatrixProductOperatorTermWithOpenBoundaryConditions(
    system,
    spin_coupling_operator_matrix,
    sparse_spin_coupling_left,
    sparse_spin_coupling_right,
    )


</t>
<t tx="cog.20080210105134.6">from sparse_tensor import sparse_tensor

sparse_spin_coupling_left = sparse_tensor((3,),())
sparse_spin_coupling_left[0] = 1

sparse_spin_coupling_right = sparse_tensor((3,),())
sparse_spin_coupling_right[2] = 1

spin_coupling_operator_matrix = sparse_tensor((3,3),(2,2))
spin_coupling_operator_matrix[0,0] =  I
spin_coupling_operator_matrix[2,2] =  I
spin_coupling_operator_matrix[0,1] =  X*(-lam)
spin_coupling_operator_matrix[1,2] =  X
spin_coupling_operator_matrix[0,2] = -Z
spin_coupling_term = MatrixProductOperatorTermWithOpenBoundaryConditions(
    system,
    spin_coupling_operator_matrix,
    sparse_spin_coupling_left,
    sparse_spin_coupling_right,
    )

</t>
<t tx="cog.20080210105134.7">spin_coupling_operator_matrix = zeros((3,3,2,2),complex128)
spin_coupling_operator_matrix[0,0] =  I
spin_coupling_operator_matrix[2,2] =  I
spin_coupling_operator_matrix[0,1] =  X*(-lam)
spin_coupling_operator_matrix[1,2] =  X
spin_coupling_operator_matrix[0,2] = -Z
spin_coupling_term = MatrixProductOperatorTerm(
    system,
    spin_coupling_operator_matrix,
    array([1,0,0]),
    array([0,0,1])
    )
</t>
<t tx="cog.20080210105134.8"></t>
<t tx="cog.20080210105134.9">def infinite_energy_limit(site_matrix):
    @others
</t>
<t tx="cog.20080210105134.10">A = site_matrix

site_dimension = site_matrix.shape[0]
auxiliary_dimension = site_matrix.shape[1]

I = identity(2)

#X = array([[0,1],[1,0]])
#Z = array([[1,0],[0,-1]])
</t>
<t tx="cog.20080210105134.11">S = site_matrix
O = identity(site_dimension).reshape(1,1,site_dimension,site_dimension)

def compute_environment(S,O):

    O_auxiliary_dimension = O.shape[0]

    retries = 0
    n = 0

    while n &lt; 1e-10 and retries &lt; 1:
        if retries &gt; 0:
            print "REPEAT!!!"

        right_evals, right_evecs = my_eigen(
            lambda R: special_left_multiply(R.reshape(auxiliary_dimension,auxiliary_dimension,O_auxiliary_dimension),S,O).ravel(),
            O_auxiliary_dimension*auxiliary_dimension**2,k=4,ncv=11,which='LM')

        n = norm(right_evecs)

        #OO = compute_transfer_matrix(S,O).reshape((auxiliary_dimension**2,)*2)

        #print "REV:",right_evals
        #print [norm(right_evec) for right_evec in right_evecs.transpose()]

        #for eval in eigvals(OO):
        #    print eval

        #OO = compute_transfer_matrix(S,O).reshape((auxiliary_dimension,)*4).transpose(0,2,1,3).reshape((auxiliary_dimension**2,)*2)

        retries += 1

    retries = 0
    n = 0

    while n &lt; 1e-10 and retries &lt; 1:
        if retries &gt; 0:
            print "REPEAT!!!"

        left_evals, left_evecs = my_eigen(
            lambda L: special_right_multiply(L.reshape(auxiliary_dimension,auxiliary_dimension,O_auxiliary_dimension),S,O).ravel(),
            O_auxiliary_dimension*auxiliary_dimension**2,k=4,ncv=11,which='LM')

        n = norm(left_evecs)
        retries += 1

        #print "LEV:",left_evals
        #print [norm(left_evec) for left_evec in left_evecs.transpose()]

    L = left_evecs[:,0].reshape((auxiliary_dimension,auxiliary_dimension,O_auxiliary_dimension))
    R = right_evecs[:,0].reshape((auxiliary_dimension,auxiliary_dimension,O_auxiliary_dimension))

    #print "EVALS:",left_evals,left_evecs.transpose(),dot(left_evecs[:,0],left_evecs[:,1])

    return L, R

L, R = compute_environment(S,O)
L = L.reshape((auxiliary_dimension,)*2)
R = R.reshape((auxiliary_dimension,)*2)

#compute_environment(S,magnetic_field_operator_matrix.to_array())
#compute_environment(S,spin_coupling_operator_matrix.to_array())

</t>
<t tx="cog.20080210105134.12">g = Graph()

g.add_node(L)
g.add_node(R)

g.add_node(A)
g.add_node(-Z)
g.add_node(conj(A))

g.connect(0,0,2,1)
g.connect(0,1,4,1)
g.connect(2,0,3,0)
g.connect(4,0,3,1)
g.connect(1,0,2,2)
g.connect(1,1,4,2)

s = Subgraph(g)
s.add_node(0)
s.add_node(1)
s.add_node(2)
s.add_node(3)
s.add_node(4)

Z_exp = s.merge_all().matrices[0]

#print "Z_exp=",Z_exp

</t>
<t tx="cog.20080210105134.13">g = Graph()

g.add_node(L)
g.add_node(R)

g.add_node(A)
g.add_node(-lam*X)
g.add_node(conj(A))

g.add_node(A)
g.add_node(X)
g.add_node(conj(A))

g.connect(0,0,2,1)
g.connect(0,1,4,1)
g.connect(2,0,3,0)
g.connect(4,0,3,1)

g.connect(2,2,5,1)
g.connect(4,2,7,1)
g.connect(5,0,6,0)
g.connect(7,0,6,1)

g.connect(1,0,5,2)
g.connect(1,1,7,2)

s = Subgraph(g)
s.add_node(0)
s.add_node(1)
s.add_node(2)
s.add_node(3)
s.add_node(4)
s.add_node(5)
s.add_node(6)
s.add_node(7)

XX_exp = s.merge_all().matrices[0]

#print "XX_exp=",XX_exp

</t>
<t tx="cog.20080210105134.14">g = Graph()

g.add_node(L)
g.add_node(R)

g.add_node(A)
g.add_node(I)
g.add_node(conj(A))

g.connect(0,0,2,1)
g.connect(0,1,4,1)
g.connect(2,0,3,0)
g.connect(4,0,3,1)
g.connect(1,0,2,2)
g.connect(1,1,4,2)

s = Subgraph(g)
s.add_node(0)
s.add_node(1)
s.add_node(2)
s.add_node(3)
s.add_node(4)

NZ_exp = s.merge_all().matrices[0]

#print "NZ_exp=",NZ_exp

</t>
<t tx="cog.20080210105134.15">g = Graph()

g.add_node(L)
g.add_node(R)

g.add_node(A)
g.add_node(I)
g.add_node(conj(A))

g.add_node(A)
g.add_node(I)
g.add_node(conj(A))

g.connect(0,0,2,1)
g.connect(0,1,4,1)
g.connect(2,0,3,0)
g.connect(4,0,3,1)

g.connect(2,2,5,1)
g.connect(4,2,7,1)
g.connect(5,0,6,0)
g.connect(7,0,6,1)

g.connect(1,0,5,2)
g.connect(1,1,7,2)

s = Subgraph(g)
s.add_node(0)
s.add_node(1)
s.add_node(2)
s.add_node(3)
s.add_node(4)
s.add_node(5)
s.add_node(6)
s.add_node(7)

NXX_exp = s.merge_all().matrices[0]

#print "NXX_exp=",NXX_exp

</t>
<t tx="cog.20080210105134.16">#print (Z_exp+XX_exp)/N_exp
#print Z_exp/NZ_exp+XX_exp/NXX_exp

E = Z_exp/NZ_exp+XX_exp/NXX_exp

#assert abs(imag(E)) &lt; 1e-10

return E

#print real(E), "%.2f" % (-log(abs(E-correct_answer))/log(10))

</t>
<t tx="cog.20080210105134.17">import arpack
import numpy as sb

def my_eigen_schur(matvec,n,k=2,ncv=5,
          maxiter=None,tol=0,guess=None,which='LM'):

    # some defaults
    if ncv is None:
        ncv=2*k+1
    ncv=min(ncv,n)
    if maxiter==None:
        maxiter=n*10

    typ = 'D'

    # some sanity checks
    if k &lt;= 0:
        raise ValueError("k must be positive, k=%d"%k)
    if k &gt;= n:
        raise ValueError("k must be less than rank(A), k=%d"%k)
    if maxiter &lt;= 0:
        raise ValueError("maxiter must be positive, maxiter=%d"%maxiter)
    if ncv &gt; n or ncv &lt; k:
        raise ValueError("ncv must be k&lt;=ncv&lt;=n, ncv=%s"%ncv)

    eigsolver = arpack._arpack.znaupd
    eigextract = arpack._arpack.zneupd

    v = sb.zeros((n,ncv),typ) # holds Ritz vectors
    if guess is not None:
        guess = guess.copy().ravel()
        if guess.shape != (n,):
            raise ValueError, "guess has invalid dimensions [%s!=(%i,)]" % (guess.shape,n)
        resid = guess
        info = 1
    else:
        resid = sb.zeros(n,typ) # residual
        info = 0
    workd = sb.zeros(3*n,typ) # workspace
    workl = sb.zeros(3*ncv*ncv+6*ncv,typ) # workspace
    iparam = sb.zeros(11,'int') # problem parameters
    ipntr = sb.zeros(14,'int') # pointers into workspaces
    ido = 0

    rwork = sb.zeros(ncv,typ.lower())

    bmat = 'I'
    mode1 = 1

    ishfts = 1
    iparam[0] = ishfts
    iparam[2] = maxiter
    iparam[6] = mode1

    while ido != 99:

        ido,resid,v,iparam,ipntr,info =\
            eigsolver(ido,bmat,which,k,tol,resid,v,iparam,ipntr,
                      workd,workl,rwork,info)
        #if ido == 99:
        #    break
        #else:
        #source_slice      = slice(ipntr[0]-1, ipntr[0]-1+n)
        #destination_slice = slice(ipntr[1]-1, ipntr[1]-1+n)
        #workd[destination_slice]=matvec(workd[source_slice])
        workd[ipntr[1]-1:ipntr[1]-1+n] = matvec(workd[ipntr[0]-1:ipntr[0]-1+n])

    if info &lt; -1 :
        raise RuntimeError("Error info=%d in arpack"%info)
        return None
    if info == -1:
        warnings.warn("Maximum number of iterations taken: %s"%iparam[2])

    # now extract eigenvalues and (optionally) eigenvectors        
    rvec = True #return_eigenvectors
    ierr = 0
    howmny = 'P' # return all eigenvectors
    sselect = sb.zeros(ncv,'int') # unused
    sigmai = 0
    sigmar = 0

    workev = sb.zeros(3*ncv,typ) 

    d,z,info =\
          eigextract(rvec,howmny,sselect,sigmar,workev,
                     bmat,which,k,tol,resid,v,iparam,ipntr,
                     workd,workl,rwork,ierr)   

    if ierr != 0:
        raise RuntimeError("Error info=%d in arpack"%info)
        return None

    my_eigen_schur.number_of_iterations = iparam[2]
    my_eigen_schur.resid = resid

    return d,z

</t>
<t tx="cog.20080210105134.18">
def infinite_energy_limit(site_matrix):

    auxiliary_dimension = system.auxiliary_dimension

    evals, evecs = my_eigen_schur(
        lambda R: special_left_multiply(R.reshape(auxiliary_dimension,auxiliary_dimension,3),site_matrix,spin_coupling_operator_matrix).ravel(),
        auxiliary_dimension**2 * 3,
        k=4,
        ncv=9,
        maxiter=1000,
        #tol=1e-13
        )

    sorted_indices = argsort(abs(evals))

    #print evals

    evecs = evecs[:,sorted_indices[-2:]]

    matrix = zeros((2,2),complex128)

    for i in xrange(2):
        for j in xrange(2):
            matrix[i,j] = dot(evecs[:,i].conj(),special_left_multiply(evecs[:,j].reshape(auxiliary_dimension,auxiliary_dimension,3),site_matrix,spin_coupling_operator_matrix).ravel())

    epsilon = sqrt(trace(dot(matrix,matrix.transpose().conj()))-2)



    new_right_evecs = [dot(evecs[:,i].reshape(auxiliary_dimension,auxiliary_dimension,1,3),array([0,0,1])) for i in [0,1]]
    new_left_evecs = [dot(evecs[:,i].reshape(auxiliary_dimension,auxiliary_dimension,1,3),array([1,0,0])) for i in [0,1]]

    #print matrix

    matrix = zeros((2,2),complex128)

    for i in xrange(2):
        for j in xrange(2):
            matrix[i,j] = dot(new_left_evecs[i].conj().ravel(),special_left_multiply(new_right_evecs[j],site_matrix,identity(2).reshape(1,1,2,2)).ravel())

    #print matrix

    epsilon_norm = sqrt(trace(dot(matrix,matrix.transpose().conj())))

    #print epsilon, epsilon_norm, epsilon/epsilon_norm

    return -real(epsilon/epsilon_norm)
</t>
<t tx="cog.20080210105134.19">def display_result(final_A,residual=None):
    print
    print
    print "...and the peasants rejoiced."
    print

    limit_energy_timestamp = start_timing_event("Calculating final energy...")

    E = infinite_energy_limit(final_A)

    finished_timing_event(limit_energy_timestamp,"done!  Took %.2f second.")
    print
    if abs(imag(E)) &gt; 1e-10:
        print "Energy:",E
    else:
        print "Energy:",real(E)

    correct_answers = {
        1.1:-1.34286402273,
        1.01:-1.27970376371,
        1:-1.273239544735,
        0.99:-1.266972193465,
        0.95:-1.2432657042699999,
        0.9:-1.2160009141099999,
        0.5:-1.063544409975,
        }

    if lam in correct_answers:
        correct_answer = correct_answers[lam]

        print "This agrees to %.2f digits with expected answer. (residual=%.3g)" % (-log(abs(E-correct_answer))/log(10),abs(E-correct_answer))

    time_taken = (time()-uber_timestamp)/60
    print 
    print "%.1f minutes taken so far;  average rate is %.2f minutes/site" % (time_taken,time_taken/total_number_of_sites)


</t>
<t tx="cog.20080210105134.20">def infinite_energy_residual(final_A):

    E = infinite_energy_limit(final_A)
    #print "ENERGY=",E
    if not isfinite(E):
        print E
        print "NOOOOOOOOOOOOOOOOOOOOOO!!!!"
    #    verbose_infinite_energy_limit(final_A)

    E = real(E)

    correct_answers = {
        1.1:-1.34286402273,
        1.01:-1.27970376371,
        1.001:-1.27387751469,
        1.0001:-1.27330322388,
        1:-1.273239544735,
        0.9999:-1.27317589993,
        0.999:-1.27260427634,
        0.99:-1.266972193465,
        0.95:-1.2432657042699999,
        0.9:-1.2160009141099999,
        0.5:-1.063544409975,
        }

    assert lam in correct_answers

    return abs(E-correct_answers[lam])
    #return -log(abs(E-correct_answer))/log(10)

</t>
<t tx="cog.20080210105134.21">def callback(iteration_number,number_of_iterations,current_A,diff,time_elapsed):
    global total_time_elapsed
    global total_time_elapsed_this_run

    if not iteration_number % 500 == 0 or diff &gt; 1e8:
        total_time_elapsed += time_elapsed
        total_time_elapsed_this_run += time_elapsed
        return

    converge_time_elapsed = time_elapsed

    residual_timestamp = time()
    residual = infinite_energy_residual(current_A)
    residual_time_elapsed = time()-residual_timestamp

    time_elapsed = converge_time_elapsed+residual_time_elapsed

    total_time_elapsed += time_elapsed
    total_time_elapsed_this_run += time_elapsed
    string = "Iteration %i/%i -- %.2fs+%.1fs, %.1fm tot, %i sites/minute; " % (iteration_number,number_of_iterations,converge_time_elapsed,residual_time_elapsed,total_time_elapsed/60.0,iteration_number/total_time_elapsed_this_run*60)


    energy_digits = -log(residual)/log(10)
    string +=  "energy ~ **%.2f digits**; site ~ %.2f digits" % (energy_digits,-log(diff)/log(10))
    global last_energy_digits
    last_energy_digits = energy_digits
    #string += str(residual)
    print string

    stdout.flush()

    udiffs.append(diff)
    number_of_sites.append(system.total_number_of_sites)
    residuals.append(residual)

</t>
<t tx="cog.20080210105134.22">def xcallback(iteration_number,number_of_iterations,current_A,diff,time_elapsed):
    global total_time_elapsed
    global total_time_elapsed_this_run

    converge_time_elapsed = time_elapsed

    residual_timestamp = time()
    residual = infinite_energy_residual(current_A)
    residual_time_elapsed = time()-residual_timestamp

    time_elapsed = converge_time_elapsed+residual_time_elapsed

    total_time_elapsed += time_elapsed
    total_time_elapsed_this_run += time_elapsed
    string = "Iteration %i/%i -- %.2fs+%.1fs, %.1fm tot, %i sites/minute; " % (iteration_number,number_of_iterations,converge_time_elapsed,residual_time_elapsed,total_time_elapsed/60.0,iteration_number/total_time_elapsed_this_run*60)


    energy_digits = -log(residual)/log(10)
    string +=  "energy ~ **%.2f digits**; site ~ %.2f digits" % (energy_digits,-log(diff)/log(10))
    global last_energy_digits
    last_energy_digits = energy_digits
    #string += str(residual)
    print string

    stdout.flush()

    udiffs.append(diff)
    number_of_sites.append(system.total_number_of_sites)
    residuals.append(residual)

</t>
<t tx="cog.20080210105134.23">number_of_sites = []
residuals = []
udiffs = []
times = []

last_energy_digits = 0

total_time_elapsed_this_run = 0
total_time_elapsed = time()-uber_timestamp

from sys import stdout

try:
    for i in xrange(4):
        system.repeat_alternating_site_run(
            number_of_iterations=20,
            tol=1e-8,
            callback=xcallback,
            number_of_times_to_absorb=1,
            energy_raise_threshold=1e-6,
            promise_keeper_threshold=None,
        )
        system.repeat_alternating_site_run(
            number_of_iterations=2000,
            tol=1e-8,
            callback=callback,
            number_of_times_to_absorb=1,
        )

        tstamp = start_timing_event("Increasing auxiliary dimension to %i..." % (system.auxiliary_dimension+5))
        system.increase_auxiliary_dimension_by(5)
        finished_timing_event(tstamp,"done!  Took %.1f seconds.")
except KeyboardInterrupt:
    pass
</t>
<t tx="cog.20080210105345"></t>
<t tx="cog.20080210105345.1">class ModelStack(OneDimensionalSystem, dequeue):
    @others


</t>
<t tx="cog.20080210110019"></t>
<t tx="cog.20080210110019.1">separation = -0.3
width_scale = 0.1

def draw_lines_in_list(draw_list):
    draw_list.sort(reverse=True)
    for thickness_, color_, coordinates in draw_list:
        thickness(thickness_)
        color(color_)
        line(*coordinates)

def draw_matrix(matrix,alpha=1):
    draw_list = []

    for i in xrange(matrix.shape[1]):
        for j in xrange(matrix.shape[2]):
            UP, DOWN = abs(matrix[:,i,j])
            draw_list.append((
                (UP**2+DOWN**2)*width_scale,
                Color(UP,DOWN,0,alpha),
                (0,i*separation,1,j*separation),
            ))
    draw_lines_in_list(draw_list)

def draw_left_twisted_matrix(matrix,left_y_heights,alpha=1):
    draw_list = []

    for i in xrange(matrix.shape[1]):
        for j in xrange(matrix.shape[2]):
            UP, DOWN = abs(matrix[:,i,j])
            draw_list.append((
                (UP**2+DOWN**2)*width_scale,
                Color(UP,DOWN,0,alpha),
                (0,left_y_heights[i],1,j*separation),
            ))
    draw_lines_in_list(draw_list)

def draw_right_twisted_matrix(matrix,right_y_heights,alpha=1):
    draw_list = []

    for i in xrange(matrix.shape[1]):
        for j in xrange(matrix.shape[2]):
            UP, DOWN = abs(matrix[:,i,j])
            draw_list.append((
                (UP**2+DOWN**2)*width_scale,
                Color(UP,DOWN,0,alpha),
                (0,i*separation,1,right_y_heights[j]),
            ))
    draw_lines_in_list(draw_list)


</t>
<t tx="cog.20080210110019.2">def __init__(self,*args,**keywords):
    OneDimensionalSystem.__init__(self,*args,**keywords)
    dequeue.__init__(self)
</t>
<t tx="cog.20080210110458">

radius = 0.075

def draw_port(x,y,alpha=1):
    color(port_fill_color,alpha)
    dot(radius,x,y)
    color(black,alpha)
    thickness(radius*.1)
    circle(radius*.8,x,y)

def draw_ports(x,y_list,alpha=1):
    for y in y_list:
        draw_port(x,y,alpha)

def draw_ports_automatically_separated(number_of_ports,alpha=1):
    draw_ports(0,arange(number_of_ports)*separation,alpha)
</t>
<t tx="cog.20080210110827">S100 = (SCALAR,0,1,0)

def draw_visualizer(
        cache=(OBJECT,None),
        old_slider=S100,
        old_shuffled_ports=(OBJECT,None),
        unnormalized_slider=S100,
        unnormalized_shuffled_ports=(OBJECT,None),
        left_shift=S100,
        right_shift=S100,
        break_left=(BOOLEAN,True),
        middle_matrix_index=(INTEGER,0,100000,0),
        left_matrix_indices=(OBJECT,[]),
        right_matrix_indices=(OBJECT,[]),
        middle_matrix_alpha=(SCALAR,0,1),
        middle_port_alpha=(SCALAR,0,1,1),
        height=(SCALAR,1,5,1)
        ):
    set_camera(Rect(0,0,width=5,height=5*(3/4)*height,anchor="n"))
    @others
</t>
<t tx="cog.20080210110827.1">@
Draw left sites
@c

push()
translate(-1.5-left_shift,-0.5)
first = True
for index in left_matrix_indices:
    if first:
        fetch_and_draw_old_matrix_blend(index,draw_right_twisted_matrix)
        first = False
    else:
        draw_matrix(cache.get_matrix(index))
    translate(-1,0)
pop()

@
Draw right sites
@c

push()
translate(0.5+right_shift,-0.5)
first = True
for index in right_matrix_indices:
    if first:
        fetch_and_draw_old_matrix_blend(index,draw_left_twisted_matrix)
        first = False
    else:
        draw_matrix(cache.get_matrix(index))
    translate(+1,0)
pop()

@
Draw middle
@c

if middle_matrix_alpha &gt; 0:
    push()
    if break_left:
        translate(-0.5-left_shift,-0.5)
        fetch_and_draw_unnormalized_matrix_blend(middle_matrix_index,draw_right_twisted_matrix,middle_matrix_alpha)
    else:
        translate(-0.5+right_shift,-0.5)
        fetch_and_draw_unnormalized_matrix_blend(middle_matrix_index,draw_left_twisted_matrix,middle_matrix_alpha)
    pop()

</t>
<t tx="cog.20080210124109">if old_slider &gt; 0:
    old_slider_twisted_heights = (arange(len(old_shuffled_ports))*old_slider + old_shuffled_ports*(1-old_slider))*separation

if unnormalized_slider &gt; 0:
    unnormalized_slider_twisted_heights = (arange(len(unnormalized_shuffled_ports))*unnormalized_slider + unnormalized_shuffled_ports*(1-unnormalized_slider))*separation


</t>
<t tx="cog.20080210130554">def draw_matrix_blend(old_matrix,new_matrix,draw_twisted_matrix,heights,slider,alpha=1):
    draw_twisted_matrix(old_matrix,heights,slider*alpha)
    draw_matrix(new_matrix,alpha=(1-slider)*alpha)
</t>
<t tx="cog.20080210130554.1">def fetch_and_draw_old_matrix_blend(index,draw_twisted_matrix):
    if old_slider &gt; 0:
        old_matrix = cache.get_old_matrix(index)
        new_matrix = cache.get_matrix(index)
        draw_matrix_blend(old_matrix,new_matrix,draw_twisted_matrix,old_slider_twisted_heights,old_slider)
    else:
        draw_matrix(cache.get_matrix(index))

def fetch_and_draw_unnormalized_matrix_blend(index,draw_twisted_matrix,alpha=1):
    if unnormalized_slider &gt; 0:
        old_matrix = cache.get_unnormalized_matrix(index)
        new_matrix = cache.get_matrix(index)
        draw_matrix_blend(old_matrix,new_matrix,draw_twisted_matrix,unnormalized_slider_twisted_heights,unnormalized_slider,alpha)
    else:
        draw_matrix(cache.get_matrix(index),alpha)
</t>
<t tx="cog.20080210133850">print "Initializing simulation..."
print "Faking data... (heh heh heh, the audience will NEVER know...)"
print "\t[TODO:  Delete above line before giving presentation!]"

&lt;&lt; Initialize system &gt;&gt;

start_animation(bg)

@others

demonstration = end_animation()
</t>
<t tx="cog.20080210134812">from InfiniteOpenProductState import OneDimensionalSystem, MatrixProductOperatorTerm

auxiliary_dimension = 2
lam = 0.9

number_of_sites=10

#timestamp = start_timing_event("Initializing configuration (including pre-normalization of sites array)...")

open_site_boundary = rand(auxiliary_dimension)
#open_site_boundary = array([1,]+[1,]*(auxiliary_dimension-1))

system = OneDimensionalSystem(
    site_dimension=2,
    auxiliary_dimension=auxiliary_dimension,
    initial_left_site_boundary=open_site_boundary,
    initial_right_site_boundary=open_site_boundary,
    )

#finished_timing_event(timestamp,"done; %i seconds taken.")

@
Create the Hamiltonian.
@c

Z = array([1,0,0,-1],complex128).reshape(2,2)
Y = array([0,1j,-1j, 0],complex128).reshape(2,2)
X = array([0,1,1, 0],complex128).reshape(2,2)
I = array([1,0,0, 1],complex128).reshape(2,2)

&lt;&lt; Dense operators &gt;&gt;

system.terms.append(spin_coupling_term)
</t>
<t tx="cog.20080210134812.3">spin_coupling_operator_matrix = zeros((3,3,2,2),complex128)
spin_coupling_operator_matrix[0,0] =  I
spin_coupling_operator_matrix[2,2] =  I
spin_coupling_operator_matrix[0,1] =  X*(-lam)
spin_coupling_operator_matrix[1,2] =  X
spin_coupling_operator_matrix[0,2] = -Z
spin_coupling_term = MatrixProductOperatorTerm(
    system,
    spin_coupling_operator_matrix,
    array([1,0,0]),
    array([0,0,1])
    )
</t>
<t tx="cog.20080210134840"></t>
<t tx="cog.20080210134840.1">def infinite_energy_limit(site_matrix):
    @others
</t>
<t tx="cog.20080210134840.2">A = site_matrix

site_dimension = site_matrix.shape[0]
auxiliary_dimension = site_matrix.shape[1]

I = identity(2)

#X = array([[0,1],[1,0]])
#Z = array([[1,0],[0,-1]])
</t>
<t tx="cog.20080210134840.3">S = site_matrix
O = identity(site_dimension).reshape(1,1,site_dimension,site_dimension)

def compute_environment(S,O):

    O_auxiliary_dimension = O.shape[0]

    retries = 0
    n = 0

    while n &lt; 1e-10 and retries &lt; 1:
        if retries &gt; 0:
            print "REPEAT!!!"

        right_evals, right_evecs = my_eigen(
            lambda R: special_left_multiply(R.reshape(auxiliary_dimension,auxiliary_dimension,O_auxiliary_dimension),S,O).ravel(),
            O_auxiliary_dimension*auxiliary_dimension**2,k=1,ncv=3,which='LM')

        n = norm(right_evecs)

        #OO = compute_transfer_matrix(S,O).reshape((auxiliary_dimension**2,)*2)

        #print "REV:",right_evals
        #print [norm(right_evec) for right_evec in right_evecs.transpose()]

        #for eval in eigvals(OO):
        #    print eval

        #OO = compute_transfer_matrix(S,O).reshape((auxiliary_dimension,)*4).transpose(0,2,1,3).reshape((auxiliary_dimension**2,)*2)

        retries += 1

    retries = 0
    n = 0

    while n &lt; 1e-10 and retries &lt; 1:
        if retries &gt; 0:
            print "REPEAT!!!"

        left_evals, left_evecs = my_eigen(
            lambda L: special_right_multiply(L.reshape(auxiliary_dimension,auxiliary_dimension,O_auxiliary_dimension),S,O).ravel(),
            O_auxiliary_dimension*auxiliary_dimension**2,k=1,ncv=3,which='LM')

        n = norm(left_evecs)
        retries += 1

        #print "LEV:",left_evals
        #print [norm(left_evec) for left_evec in left_evecs.transpose()]

    L = left_evecs[:,0].reshape((auxiliary_dimension,auxiliary_dimension,O_auxiliary_dimension))
    R = right_evecs[:,0].reshape((auxiliary_dimension,auxiliary_dimension,O_auxiliary_dimension))

    #print "EVALS:",left_evals,left_evecs.transpose(),dot(left_evecs[:,0],left_evecs[:,1])

    return L, R

L, R = compute_environment(S,O)
L = L.reshape((auxiliary_dimension,)*2)
R = R.reshape((auxiliary_dimension,)*2)

#compute_environment(S,magnetic_field_operator_matrix.to_array())
#compute_environment(S,spin_coupling_operator_matrix.to_array())

</t>
<t tx="cog.20080210134840.4">g = Graph()

g.add_node(L)
g.add_node(R)

g.add_node(A)
g.add_node(-Z)
g.add_node(conj(A))

g.connect(0,0,2,1)
g.connect(0,1,4,1)
g.connect(2,0,3,0)
g.connect(4,0,3,1)
g.connect(1,0,2,2)
g.connect(1,1,4,2)

s = Subgraph(g)
s.add_node(0)
s.add_node(1)
s.add_node(2)
s.add_node(3)
s.add_node(4)

Z_exp = s.merge_all().matrices[0]

#print "Z_exp=",Z_exp

</t>
<t tx="cog.20080210134840.5">g = Graph()

g.add_node(L)
g.add_node(R)

g.add_node(A)
g.add_node(-lam*X)
g.add_node(conj(A))

g.add_node(A)
g.add_node(X)
g.add_node(conj(A))

g.connect(0,0,2,1)
g.connect(0,1,4,1)
g.connect(2,0,3,0)
g.connect(4,0,3,1)

g.connect(2,2,5,1)
g.connect(4,2,7,1)
g.connect(5,0,6,0)
g.connect(7,0,6,1)

g.connect(1,0,5,2)
g.connect(1,1,7,2)

s = Subgraph(g)
s.add_node(0)
s.add_node(1)
s.add_node(2)
s.add_node(3)
s.add_node(4)
s.add_node(5)
s.add_node(6)
s.add_node(7)

XX_exp = s.merge_all().matrices[0]

#print "XX_exp=",XX_exp

</t>
<t tx="cog.20080210134840.6">g = Graph()

g.add_node(L)
g.add_node(R)

g.add_node(A)
g.add_node(I)
g.add_node(conj(A))

g.connect(0,0,2,1)
g.connect(0,1,4,1)
g.connect(2,0,3,0)
g.connect(4,0,3,1)
g.connect(1,0,2,2)
g.connect(1,1,4,2)

s = Subgraph(g)
s.add_node(0)
s.add_node(1)
s.add_node(2)
s.add_node(3)
s.add_node(4)

NZ_exp = s.merge_all().matrices[0]

#print "NZ_exp=",NZ_exp

</t>
<t tx="cog.20080210134840.7">g = Graph()

g.add_node(L)
g.add_node(R)

g.add_node(A)
g.add_node(I)
g.add_node(conj(A))

g.add_node(A)
g.add_node(I)
g.add_node(conj(A))

g.connect(0,0,2,1)
g.connect(0,1,4,1)
g.connect(2,0,3,0)
g.connect(4,0,3,1)

g.connect(2,2,5,1)
g.connect(4,2,7,1)
g.connect(5,0,6,0)
g.connect(7,0,6,1)

g.connect(1,0,5,2)
g.connect(1,1,7,2)

s = Subgraph(g)
s.add_node(0)
s.add_node(1)
s.add_node(2)
s.add_node(3)
s.add_node(4)
s.add_node(5)
s.add_node(6)
s.add_node(7)

NXX_exp = s.merge_all().matrices[0]

#print "NXX_exp=",NXX_exp

</t>
<t tx="cog.20080210134840.8">#print (Z_exp+XX_exp)/N_exp
#print Z_exp/NZ_exp+XX_exp/NXX_exp

E = Z_exp/NZ_exp+XX_exp/NXX_exp

#assert abs(imag(E)) &lt; 1e-10

return E

#print real(E), "%.2f" % (-log(abs(E-correct_answer))/log(10))

</t>
<t tx="cog.20080210134840.9">import arpack
import numpy as sb

def my_eigen_schur(matvec,n,k=2,ncv=5,
          maxiter=None,tol=0,guess=None,which='LM'):

    # some defaults
    if ncv is None:
        ncv=2*k+1
    ncv=min(ncv,n)
    if maxiter==None:
        maxiter=n*10

    typ = 'D'

    # some sanity checks
    if k &lt;= 0:
        raise ValueError("k must be positive, k=%d"%k)
    if k &gt;= n:
        raise ValueError("k must be less than rank(A), k=%d"%k)
    if maxiter &lt;= 0:
        raise ValueError("maxiter must be positive, maxiter=%d"%maxiter)
    if ncv &gt; n or ncv &lt; k:
        raise ValueError("ncv must be k&lt;=ncv&lt;=n, ncv=%s"%ncv)

    eigsolver = arpack._arpack.znaupd
    eigextract = arpack._arpack.zneupd

    v = sb.zeros((n,ncv),typ) # holds Ritz vectors
    if guess is not None:
        guess = guess.copy().ravel()
        if guess.shape != (n,):
            raise ValueError, "guess has invalid dimensions [%s!=(%i,)]" % (guess.shape,n)
        resid = guess
        info = 1
    else:
        resid = sb.zeros(n,typ) # residual
        info = 0
    workd = sb.zeros(3*n,typ) # workspace
    workl = sb.zeros(3*ncv*ncv+6*ncv,typ) # workspace
    iparam = sb.zeros(11,'int') # problem parameters
    ipntr = sb.zeros(14,'int') # pointers into workspaces
    ido = 0

    rwork = sb.zeros(ncv,typ.lower())

    bmat = 'I'
    mode1 = 1

    ishfts = 1
    iparam[0] = ishfts
    iparam[2] = maxiter
    iparam[6] = mode1

    while ido != 99:

        ido,resid,v,iparam,ipntr,info =\
            eigsolver(ido,bmat,which,k,tol,resid,v,iparam,ipntr,
                      workd,workl,rwork,info)
        #if ido == 99:
        #    break
        #else:
        #source_slice      = slice(ipntr[0]-1, ipntr[0]-1+n)
        #destination_slice = slice(ipntr[1]-1, ipntr[1]-1+n)
        #workd[destination_slice]=matvec(workd[source_slice])
        workd[ipntr[1]-1:ipntr[1]-1+n] = matvec(workd[ipntr[0]-1:ipntr[0]-1+n])

    if info &lt; -1 :
        raise RuntimeError("Error info=%d in arpack"%info)
        return None
    if info == -1:
        warnings.warn("Maximum number of iterations taken: %s"%iparam[2])

    # now extract eigenvalues and (optionally) eigenvectors        
    rvec = True #return_eigenvectors
    ierr = 0
    howmny = 'P' # return all eigenvectors
    sselect = sb.zeros(ncv,'int') # unused
    sigmai = 0
    sigmar = 0

    workev = sb.zeros(3*ncv,typ) 

    d,z,info =\
          eigextract(rvec,howmny,sselect,sigmar,workev,
                     bmat,which,k,tol,resid,v,iparam,ipntr,
                     workd,workl,rwork,ierr)   

    if ierr != 0:
        raise RuntimeError("Error info=%d in arpack"%info)
        return None

    my_eigen_schur.number_of_iterations = iparam[2]
    my_eigen_schur.resid = resid

    return d,z

</t>
<t tx="cog.20080210134840.10">
def infinite_energy_limit(site_matrix):

    auxiliary_dimension = system.auxiliary_dimension

    evals, evecs = my_eigen_schur(
        lambda R: special_left_multiply(R.reshape(auxiliary_dimension,auxiliary_dimension,3),site_matrix,spin_coupling_operator_matrix).ravel(),
        auxiliary_dimension**2 * 3,
        k=2,
        ncv=5,
        maxiter=1000,
        #tol=1e-13
        )

    sorted_indices = argsort(abs(evals))

    #print evals

    evecs = evecs[:,sorted_indices[-2:]]

    matrix = zeros((2,2),complex128)

    for i in xrange(2):
        for j in xrange(2):
            matrix[i,j] = dot(evecs[:,i].conj(),special_left_multiply(evecs[:,j].reshape(auxiliary_dimension,auxiliary_dimension,3),site_matrix,spin_coupling_operator_matrix).ravel())

    epsilon = sqrt(trace(dot(matrix,matrix.transpose().conj()))-2)



    new_right_evecs = [dot(evecs[:,i].reshape(auxiliary_dimension,auxiliary_dimension,1,3),array([0,0,1])) for i in [0,1]]
    new_left_evecs = [dot(evecs[:,i].reshape(auxiliary_dimension,auxiliary_dimension,1,3),array([1,0,0])) for i in [0,1]]

    #print matrix

    matrix = zeros((2,2),complex128)

    for i in xrange(2):
        for j in xrange(2):
            matrix[i,j] = dot(new_left_evecs[i].conj().ravel(),special_left_multiply(new_right_evecs[j],site_matrix,identity(2).reshape(1,1,2,2)).ravel())

    #print matrix

    epsilon_norm = sqrt(trace(dot(matrix,matrix.transpose().conj())))

    #print epsilon, epsilon_norm, epsilon/epsilon_norm

    return -real(epsilon/epsilon_norm)
</t>
<t tx="cog.20080210134840.11">def display_result(final_A,residual=None):
    print
    print
    print "...and the peasants rejoiced."
    print

    limit_energy_timestamp = start_timing_event("Calculating final energy...")

    E = infinite_energy_limit(final_A)

    finished_timing_event(limit_energy_timestamp,"done!  Took %.2f second.")
    print
    if abs(imag(E)) &gt; 1e-10:
        print "Energy:",E
    else:
        print "Energy:",real(E)

    correct_answers = {
        1.1:-1.34286402273,
        1.01:-1.27970376371,
        1:-1.273239544735,
        0.99:-1.266972193465,
        0.95:-1.2432657042699999,
        0.9:-1.2160009141099999,
        0.5:-1.063544409975,
        }

    if lam in correct_answers:
        correct_answer = correct_answers[lam]

        print "This agrees to %.2f digits with expected answer. (residual=%.3g)" % (-log(abs(E-correct_answer))/log(10),abs(E-correct_answer))

    time_taken = (time()-uber_timestamp)/60
    print 
    print "%.1f minutes taken so far;  average rate is %.2f minutes/site" % (time_taken,time_taken/total_number_of_sites)


</t>
<t tx="cog.20080210134840.12">def infinite_energy_residual(E):
    E = real(E)

    correct_answers = {
        1.1:-1.34286402273,
        1.01:-1.27970376371,
        1.001:-1.27387751469,
        1.0001:-1.27330322388,
        1:-1.273239544735,
        0.9999:-1.27317589993,
        0.999:-1.27260427634,
        0.99:-1.266972193465,
        0.95:-1.2432657042699999,
        0.9:-1.2160009141099999,
        0.5:-1.063544409975,
        }

    assert lam in correct_answers

    return abs(E-correct_answers[lam])
    #return -log(abs(E-correct_answer))/log(10)

</t>
<t tx="cog.20080210134840.13">def callback(iteration_number,number_of_iterations,current_A,diff,time_elapsed):
    global total_time_elapsed
    global total_time_elapsed_this_run

    if not iteration_number % 500 == 0 or diff &gt; 1e8:
        total_time_elapsed += time_elapsed
        total_time_elapsed_this_run += time_elapsed
        return

    converge_time_elapsed = time_elapsed

    residual_timestamp = time()
    residual = infinite_energy_residual(current_A)
    residual_time_elapsed = time()-residual_timestamp

    time_elapsed = converge_time_elapsed+residual_time_elapsed

    total_time_elapsed += time_elapsed
    total_time_elapsed_this_run += time_elapsed
    string = "Iteration %i/%i -- %.2fs+%.1fs, %.1fm tot, %i sites/minute; " % (iteration_number,number_of_iterations,converge_time_elapsed,residual_time_elapsed,total_time_elapsed/60.0,iteration_number/total_time_elapsed_this_run*60)


    energy_digits = -log(residual)/log(10)
    string +=  "energy ~ **%.2f digits**; site ~ %.2f digits" % (energy_digits,-log(diff)/log(10))
    global last_energy_digits
    last_energy_digits = energy_digits
    #string += str(residual)
    print string

    stdout.flush()

    udiffs.append(diff)
    number_of_sites.append(system.total_number_of_sites)
    residuals.append(residual)

</t>
<t tx="cog.20080210134840.14">def xcallback(iteration_number,number_of_iterations,current_A,diff,time_elapsed):
    global total_time_elapsed
    global total_time_elapsed_this_run

    converge_time_elapsed = time_elapsed

    residual_timestamp = time()
    residual = infinite_energy_residual(current_A)
    residual_time_elapsed = time()-residual_timestamp

    time_elapsed = converge_time_elapsed+residual_time_elapsed

    total_time_elapsed += time_elapsed
    total_time_elapsed_this_run += time_elapsed
    string = "Iteration %i/%i -- %.2fs+%.1fs, %.1fm tot, %i sites/minute; " % (iteration_number,number_of_iterations,converge_time_elapsed,residual_time_elapsed,total_time_elapsed/60.0,iteration_number/total_time_elapsed_this_run*60)


    energy_digits = -log(residual)/log(10)
    string +=  "energy ~ **%.2f digits**; site ~ %.2f digits" % (energy_digits,-log(diff)/log(10))
    global last_energy_digits
    last_energy_digits = energy_digits
    #string += str(residual)
    print string

    stdout.flush()

    udiffs.append(diff)
    number_of_sites.append(system.total_number_of_sites)
    residuals.append(residual)

</t>
<t tx="cog.20080210140005">enter(visualizer)

pause()

fade_in(0.5,visualizer)

pause()

linear(1,visualizer.middle_matrix_alpha,1)

pause()

smooth(1,visualizer.left_shift,1)

pause()

linear(1,visualizer.unnormalized_slider,0)

pause()

set(visualizer.middle_matrix_alpha,0)
set(visualizer.middle_port_alpha,0)
set(visualizer.middle_matrix_index,1)
set(visualizer.left_matrix_indices,[0])
set(visualizer.break_left,False)
set(visualizer.left_shift,0)
set(visualizer.unnormalized_slider,1)

linear(1,visualizer.middle_port_alpha,1)

pause()

linear(1,visualizer.middle_matrix_alpha,1)

pause()

smooth(1,visualizer.right_shift,1)

pause()

linear(1,visualizer.unnormalized_slider,0)

pause()

set(visualizer.right_shift,0)
set(visualizer.middle_matrix_alpha,0)
set(visualizer.right_matrix_indices,[1])
</t>
<t tx="cog.20080210144002">@
Draw left ports
@c

push()
translate(-1.5-left_shift,-0.5)
for index in left_matrix_indices:
    number_of_ports = cache.get_matrix(index).shape[1]
    draw_ports_automatically_separated(number_of_ports)
    translate(-1,0)
pop()

if len(left_matrix_indices) &gt; 0:
    number_of_ports = cache.get_matrix(left_matrix_indices[0]).shape[2]
    push()
    translate(-0.5-left_shift,-0.5)
    if old_slider &gt; 0:
        draw_port_blend(number_of_ports,old_slider_twisted_heights,old_slider)
    else:
        draw_ports_automatically_separated(number_of_ports)
    pop()


@
Draw right ports
@c

push()
translate(+1.5+right_shift,-0.5)
for index in right_matrix_indices:
    number_of_ports = cache.get_matrix(index).shape[2]
    draw_ports_automatically_separated(number_of_ports)
    translate(+1,0)
pop()

if len(right_matrix_indices) &gt; 0:
    number_of_ports = cache.get_matrix(right_matrix_indices[0]).shape[1]
    push()
    translate(+0.5+right_shift,-0.5)
    if old_slider &gt; 0:
        draw_port_blend(number_of_ports,old_slider_twisted_heights,old_slider)
    else:
        draw_ports_automatically_separated(number_of_ports)
    pop()

@
Draw middle ports
@c

if middle_port_alpha &gt; 0:
    push()
    if break_left:
        translate(-0.5-left_shift,-0.5)
        left_number_of_ports, right_number_of_ports = cache.get_matrix(middle_matrix_index).shape[1:]
        draw_ports_automatically_separated(left_number_of_ports,middle_port_alpha)
        translate(1,0)
        if unnormalized_slider &gt; 0:
            draw_port_blend(right_number_of_ports,unnormalized_slider_twisted_heights,unnormalized_slider,middle_port_alpha)
        else:
            draw_ports_automatically_separated(right_number_of_ports,middle_port_alpha)
    else:
        translate(-0.5+right_shift,-0.5)
        left_number_of_ports, right_number_of_ports = cache.get_matrix(middle_matrix_index).shape[1:]
        if unnormalized_slider &gt; 0:
            draw_port_blend(left_number_of_ports,unnormalized_slider_twisted_heights,unnormalized_slider,middle_port_alpha)
        else:
            draw_ports_automatically_separated(left_number_of_ports,middle_port_alpha)
        translate(1,0)
        draw_ports_automatically_separated(right_number_of_ports,middle_port_alpha)
    pop()

</t>
<t tx="cog.20080210164632">def run_site(direction,index,seconds_per_run=2,port_shuffle_number=None,window=2):

    for meter in meters:
        set(meter.old_index,get(meter.new_index))
        set(meter.new_index,index)
        set(meter.slider,0)

    if direction == -1:
        shift = visualizer.left_shift
        set(visualizer.break_left,True)
    else:
        shift = visualizer.right_shift
        set(visualizer.break_left,False)

    set(visualizer.middle_matrix_index,index)
    set(visualizer.unnormalized_slider,1)

    if port_shuffle_number:
        port_shuffle = range(port_shuffle_number)
        shuffle(port_shuffle)
        port_shuffle = array(port_shuffle)
        set(visualizer.unnormalized_shuffled_ports,port_shuffle)

    parallel()
    linear(seconds_per_run/2,visualizer.middle_matrix_alpha,1)
    for meter in meters:
        smooth(seconds_per_run/2,meter.slider,1)
    end()

    parallel()
    smooth(seconds_per_run/2,shift,1)
    linear(seconds_per_run/2,visualizer.unnormalized_slider,0)
    end()

    def add_index(var,index):
        value = get(var)
        value = [index] + value[:window]
        set(var,value)        

    if direction == -1:
        add_index(visualizer.left_matrix_indices,index)
    else:
        add_index(visualizer.right_matrix_indices,index)

    set(shift,0)
    set(visualizer.middle_matrix_alpha,0)
</t>
<t tx="cog.20080210165252">direction = -1

for index in xrange(2,4):
    run_site(direction,index,2)
    direction *= -1

pause()
</t>
<t tx="cog.20080210165945">increase_to_reflect_chi(2,4)

pause()

</t>
<t tx="cog.20080210171852">@others
</t>
<t tx="cog.20080210171852.1">from numpy import *
from scipy.linalg.iterative import *
from numpy.random import rand
from scipy.linalg import *
import scipy.linalg
from scipy.linalg.basic import LinAlgError
from numpy.linalg import inv
import sys

import warnings

from Graph import Graph, Subgraph, Placeholder, compile_graph

from hooks import outer_product

import arpack
import numpy as sb

try:
    from arpack import eigen
except ImportError:
    pass

from timetracker import *</t>
<t tx="cog.20080210171852.2">LEFT  = -1
RIGHT = +1

UP = 1j
DOWN = -1j
</t>
<t tx="cog.20080210171852.3"></t>
<t tx="cog.20080210171852.4"></t>
<t tx="cog.20080210171852.5">def compute_normalizer(B,index):
    """Computes X such that sum_{s'=s} (BX)^dagger (BX) = I."""

    tensordot_indices = range(B.ndim)
    del tensordot_indices[index]

    M = tensordot(conjugate(B),B,(tensordot_indices,)*2)

    # $\bM^{[i]} = \sum_s \bB^{[i],s\,\,\dagger}\cdot\bB^{[i],s}$;  the \cs{trace} method is what sums over s=s'
    # $\bM \vx^{(i)} = \lambda \vx^{(i)}$;  $U_{ji} = x^{(i)}_j$
    vals, U = scipy.linalg.eigh(M)

    # Replace near-zeros and negative numbers with zero;  note that since $\bM$ is completely positive
    # and Hermitian all eigenvalues should be positive, so any negative eigenvalues should just be
    # small approximations to zero.
    vals[vals&lt;0] = 0

    # $\bX = \bU \bD^{-1/2}$;  note that the pseudo-inverse is used since some eigenvalues might be zero
    dvals = sqrt(vals)
    nonzero_dvals = dvals!=0    
    dvals[nonzero_dvals] = 1/dvals[nonzero_dvals]
    D = diag(dvals)
    X = dot(dot(U,D),U.conj().transpose())

    return X
</t>
<t tx="cog.20080210171852.6">def apply_normalizer(normalizer,matrix,index):
    matrix_new_indices = range(matrix.ndim-1)
    matrix_new_indices.insert(index,matrix.ndim-1)
    return tensordot(matrix,normalizer,(index,0)).transpose(matrix_new_indices)

@
def apply_inverse_normalizer(normalizer,matrix,index):
    matrix_new_indices = range(matrix.ndim-1)
    matrix_new_indices.insert(index,matrix.ndim-1)
    try:
        normalizer_inverse = inv(normalizer)
    except:
        raise
        normalizer_inverse = pinv(normalizer)
    return tensordot(matrix,normalizer_inverse,(index,1)).transpose(matrix_new_indices)
@c
</t>
<t tx="cog.20080210171852.7">def compute_and_apply_normalizer(matrix,index):
    return apply_normalizer(compute_normalizer(matrix,index),matrix,index)
</t>
<t tx="cog.20080210171852.8">def my_eigen(matvec,n,k=1,ncv=None,
          maxiter=None,tol=0,guess=None,which='SR'):
    if n == 1:
        return matvec(array([1])), array([[1]])

    # some defaults
    if ncv is None:
        ncv=2*k+1
    ncv=min(ncv,n)
    if maxiter==None:
        maxiter=n*10

    typ = 'D'

    # some sanity checks
    if k &lt;= 0:
        raise ValueError("k must be positive, k=%d"%k)
    if k &gt;= n:
        raise ValueError("k must be less than rank(A), k=%d"%k)
    if maxiter &lt;= 0:
        raise ValueError("maxiter must be positive, maxiter=%d"%maxiter)
    if ncv &gt; n or ncv &lt; k:
        raise ValueError("ncv must be k&lt;=ncv&lt;=n, ncv=%s"%ncv)

    eigsolver = arpack._arpack.znaupd
    eigextract = arpack._arpack.zneupd

    v = sb.zeros((n,ncv),typ) # holds Ritz vectors
    if guess is not None:
        guess = guess.copy().ravel()
        if guess.shape != (n,):
            raise ValueError, "guess has invalid dimensions [%s!=(%i,)]" % (guess.shape,n)
        resid = guess
        info = 1
    else:
        resid = sb.zeros(n,typ) # residual
        info = 0
    workd = sb.zeros(3*n,typ) # workspace
    workl = sb.zeros(3*ncv*ncv+6*ncv,typ) # workspace
    iparam = sb.zeros(11,'int') # problem parameters
    ipntr = sb.zeros(14,'int') # pointers into workspaces
    ido = 0

    rwork = sb.zeros(ncv,typ.lower())

    bmat = 'I'
    mode1 = 1

    ishfts = 1
    iparam[0] = ishfts
    iparam[2] = maxiter
    iparam[6] = mode1

    while ido != 99:

        ido,resid,v,iparam,ipntr,info =\
            eigsolver(ido,bmat,which,k,tol,resid,v,iparam,ipntr,
                      workd,workl,rwork,info)
        #if ido == 99:
        #    break
        #else:
        #source_slice      = slice(ipntr[0]-1, ipntr[0]-1+n)
        #destination_slice = slice(ipntr[1]-1, ipntr[1]-1+n)
        #workd[destination_slice]=matvec(workd[source_slice])
        workd[ipntr[1]-1:ipntr[1]-1+n] = matvec(workd[ipntr[0]-1:ipntr[0]-1+n])

    if info &lt; -1 :
        raise RuntimeError("Error info=%d in arpack"%info)
        return None
    if info == -1:
        warnings.warn("Maximum number of iterations taken: %s"%iparam[2])

    # now extract eigenvalues and (optionally) eigenvectors        
    rvec = True #return_eigenvectors
    ierr = 0
    howmny = 'A' # return all eigenvectors
    sselect = sb.zeros(ncv,'int') # unused
    sigmai = 0
    sigmar = 0

    workev = sb.zeros(3*ncv,typ) 

    d,z,info =\
          eigextract(rvec,howmny,sselect,sigmar,workev,
                     bmat,which,k,tol,resid,v,iparam,ipntr,
                     workd,workl,rwork,ierr)   

    if ierr != 0:
        raise RuntimeError("Error info=%d in arpack"%info)
        return None

    my_eigen.number_of_iterations = iparam[2]
    my_eigen.resid = resid

    return d,z

</t>
<t tx="cog.20080210171852.9">def normalize(matrix,index):
    new_indices = range(matrix.ndim)
    del new_indices[index]
    new_indices.append(index)

    old_shape = list(matrix.shape)
    del old_shape[index]
    new_shape = (prod(old_shape),matrix.shape[index])
    old_shape.append(matrix.shape[index])

    new_matrix = matrix.transpose(new_indices).reshape(new_shape)

    old_indices = range(matrix.ndim-1)
    old_indices.insert(index,matrix.ndim-1)

    try:
        u, s, v = svd(new_matrix,full_matrices=0)    
        return dot(u,v).reshape(old_shape).transpose(old_indices)
    except LinAlgError:
        M = dot(new_matrix.conj().transpose(),new_matrix)

        vals, U = eigh(M)
        vals[vals&lt;0] = 0

        dvals = sqrt(vals)
        nonzero_dvals = dvals!=0
        dvals[nonzero_dvals] = 1.0/dvals[nonzero_dvals]
        X = dot(U*dvals,U.conj().transpose())

        return dot(new_matrix,X).reshape(old_shape).transpose(old_indices)

</t>
<t tx="cog.20080210171852.10"># \ESC{\subsection{optimize} \index{optimize}}
def compute_optimized_site_matrix(n,matvec,compute_energy,old_energy=None,guess=None,iteration_cap=None,tol=0,energy_raise_threshold=1e-10,k=1,ncv=3):
    """Adjusts the matrix at the site given by *site_number* so that the energy of the system is minimized.  If *next_site* is specified as either LEFT or RIGHT, then it will normalize the site by respectively left- or right- multiplying the site by an operator and then it will take the adjacent site and multiply the opposite side by the inverse of this operator in order to preserve the state."""
    #from time import time

    #uber_timestamp = time()

    #ncv = min(5,n)
    #ncv = min(3,n)
    ncv = min(ncv,n)
    try:
        #timestamp = time()
        eigenvalues, eigenvectors = my_eigen(matvec,n,k=k,ncv=ncv,guess=guess,maxiter=iteration_cap,tol=tol)
        #print (time()-timestamp)/my_eigen.number_of_iterations
    except ValueError, msg: # thrown when the eigenvalue solver does not converge to a solution
        # Signal to the caller that there was a problem.
        raise
        raise ConvergenceError, "Problem converging to solution in eigenvalue solver: "+str(msg)

    eigenvectors = eigenvectors.transpose()

@
It's not enough to simply take the eigenvector corresponding to the lowest eigenvalue as our solution, since sometimes for various reasons (due mainly to numerical instability) some or all of the eigenvalues are bogus.  For example, sometimes the algorithm returns th the equivalent of $-\infty$, which generally corresponds to an eigenvector that is very nearly zero.  Thus, it is important to filter out all of these bogus solutions before declaring victory.

@c
    # Sort the eigenvalues.
    sorted_indices_of_eigenvalues = argsort(real(eigenvalues))

@
A solution $\lambda,\vx$ is acceptable iff:

\begin{itemize}
\item $\|\vx\|_\infty &gt; 1\cdot 10^{-10}$, to rule out erroneous ``nearly zero'' solutions that result in infinitely large eigenvalues
\item $\abs{\text{Im}[\lambda]} &lt; 1\cdot 10^{-10}$, since energies should be \emph{real} as the Hamiltonian is hermitian.  (Small imaginary parts aren't great, but they don't hurt too much as long as they are sufficiently negligible.)
\item $\abs{x_i}&lt;\infty, \abs{\lambda} &lt; \infty$
\item $\abs{\frac{\coip{\vx}{\bD}{\vx}}{\coip{\vx}{\bN}{\vx}} - \lam}&lt;1\cdot 10^{-10}$, since sometimes the returned eigenvalue is actually much different from the energy obtained by using the corresponding eigenvector
\end{itemize}
@c
    def is_acceptable(index):
        evec = eigenvectors[index]
        eval = eigenvalues[index]
        return max(abs(evec)) &gt; 1e-10 and isfinite(evec).all() and isfinite(eval)

    acceptable_indices_of_eigenvalues = filter(is_acceptable,sorted_indices_of_eigenvalues)
    if len(acceptable_indices_of_eigenvalues) == 0:
        print eigenvalues
        print eigenvectors
        raise ConvergenceError, "All eigenvectors had near-vanishing normals, eigenvalues with large imaginary parts, or NaNs and/or infs."

@
If we've reached this point, then we have at least one solution that isn't atrocious.  However, it's possible that our solution has a higher energy than our current state -- either due to a problem in the eigenvalue solver, or because we filtered out all the lower-energy solutions.  Thus, we need compare the energy of the solution we've found to our old energy to make sure that it's higher.
@c    
    index_of_solution = acceptable_indices_of_eigenvalues[0]
    solution = eigenvectors[index_of_solution]

    #new_energy = 0
    #for L, O, R in terms:
    #    new_energy += dot(solution.conj(),special_matvec(L,O,R,A).ravel())

    #new_energy = compute_energy(solution)#dot(solution.conj(),matvec(solution))

    new_energy = eigenvalues[index_of_solution]

    new_energy = real(new_energy)

    if old_energy is not None and real(new_energy) &gt; real(old_energy) and abs(new_energy-old_energy)&gt;energy_raise_threshold and False:
        raise ConvergenceError, "Only found a solution which *raised* the energy. (%.15f &lt; %.15f)" % (new_energy,old_energy)

    #print "time per site = ", (time()-uber_timestamp)/my_eigen.number_of_iterations

    return solution, new_energy
</t>
<t tx="cog.20080210171852.11">def kill_phase(x):
    x_ravel = x.ravel()
    index = argmax(abs(x_ravel))
    x *= (conj(x_ravel[index])/abs(x_ravel[index]))
</t>
<t tx="cog.20080210171852.12">def multiply_tensor_by_matrix_at_index(tensor,matrix,index):
    tensor_new_indices = range(tensor.ndim-1)
    tensor_new_indices.insert(index,tensor.ndim-1)
    return tensordot(tensor,matrix,(index,0)).transpose(tensor_new_indices)</t>
<t tx="cog.20080210171852.13">def ensure_dimensions_greater_than_one(shape):
    return tuple(x if x!=1 else 2 for x in shape)
</t>
<t tx="cog.20080210171852.14"></t>
<t tx="cog.20080210171852.15">class ConvergenceError(Exception):
    pass
</t>
<t tx="cog.20080210171852.16">class System:
    @others
</t>
<t tx="cog.20080210171852.17">def __init__(self):
    self.total_number_of_sites = 0

    self.terms = []
</t>
<t tx="cog.20080210171852.18">def absorb_site(self,direction,number_of_times_to_absorb=1):

    for i in xrange(number_of_times_to_absorb):
        for term in self.terms + [self.normalization_term]:
            term.absorb_site(direction)

    self.total_number_of_sites += 1


</t>
<t tx="cog.20080210171852.19">def repeat_alternating_site_run(self,number_of_iterations,terminate_if_within=0,tol=0,callback=None,number_of_times_to_absorb=1,energy_raise_threshold=1e-10, promise_keeper_threshold=1e-2):

    iterations_so_far = 1
    direction = LEFT
    while iterations_so_far &lt;= number_of_iterations:
        last_unnormalized_site_matrix = self.unnormalized_site_matrix
        self.single_site_run(
            direction,
            tol=tol,
            energy_raise_threshold=energy_raise_threshold,
            promise_keeper_threshold=promise_keeper_threshold,
            number_of_times_to_absorb=number_of_times_to_absorb,
            )
        if last_unnormalized_site_matrix is not None:
            udiff =  norm(last_unnormalized_site_matrix-self.unnormalized_site_matrix)/max(norm(self.unnormalized_site_matrix),norm(last_unnormalized_site_matrix))
            if callback:
                callback(iterations_so_far,number_of_iterations,self.site_matrix,udiff,self.time_elapsed)
            if udiff &lt; terminate_if_within:
                break

        iterations_so_far += 1
        direction *= -1
</t>
<t tx="cog.20080210171852.20">def single_site_run(self, direction_to_absorb, tol=0, number_of_times_to_absorb = 1, energy_raise_threshold = 1e-10, promise_keeper_threshold = 1e-2):
    timestamp = time()
    old_energy = self.compute_energy()
    site_matrix, promised_energy = compute_optimized_site_matrix(self.site_matrix_flattened_dimension,self.get_matvec(),self.compute_energy_given_site_matrix,old_energy,guess=self.unnormalized_site_matrix,tol=tol,energy_raise_threshold=energy_raise_threshold)
    self.site_matrix = site_matrix.reshape(self.shape_of_site_matrix)
    self.unnormalized_site_matrix = self.site_matrix.copy()
    kill_phase(self.unnormalized_site_matrix)
    calculated_energy = self.compute_energy()
    if promise_keeper_threshold is not None:
        difference_between_calculated_and_promised_energy = abs(calculated_energy-promised_energy)/abs(promised_energy)
        if difference_between_calculated_and_promised_energy&gt;promise_keeper_threshold and abs(calculated_energy)+abs(promised_energy)&gt;1e-10: #1e-8: # and abs(promised_energy) &gt; 1e-10
            raise ConvergenceError, "Calculated energy for system (%g) was different from promised energy (%g) by %g%%." % (calculated_energy,promised_energy,difference_between_calculated_and_promised_energy*100)
    if not isfinite(self.compute_energy()):
        raise ConvergenceError, "New state has non-finite answer for energy."
    self.normalize_and_absorb_site(direction_to_absorb)#,number_of_times_to_absorb=number_of_times_to_absorb)
    self.total_number_of_sites += 1
    self.time_elapsed = time()-timestamp
</t>
<t tx="cog.20080210171852.21">def compute_energy_given_site_matrix(self,site_matrix):
    site_matrix = site_matrix.reshape(self.shape_of_site_matrix)
    return sum([dot(site_matrix.ravel().conj(),term.get_matvec()(site_matrix).ravel()) for term in self.terms])/dot(site_matrix.ravel().conj(),self.normalization_term.get_matvec()(site_matrix).ravel())

</t>
<t tx="cog.20080210171852.22">def get_matvec(self):

    norm_imatvec = self.normalization_term.get_imatvec()

    matvec_funcs = [x for x in (term.get_matvec() for term in self.terms) if x is not None]

    number_of_matvec_funcs = len(matvec_funcs)

    shape_of_site_matrix = self.shape_of_site_matrix

    def matvec(A):
        A = A.reshape(shape_of_site_matrix)
        result = matvec_funcs[0](A)
        i = 1
        while i &lt; number_of_matvec_funcs:
            result += matvec_funcs[i](A)
            i += 1

        return norm_imatvec(result).ravel()

    return matvec
</t>
<t tx="cog.20080210171852.23"># \ESC{\subsection{compute\_energy}}
def compute_energy(self):
    """Computes the energy of the system in its current state."""

    # The energy of the system is defined to be
    #
    # $$\exp{E} := \frac{\coip{\psi}{\bH}{\psi}}{\cip{\psi}{\psi}}.$$
    #
    # Note that, as discussed in section \ref{expectation-matrices}, expectations are computed via. computing the
    # trace of the product of expectation matrices -- that is,
    #
    # $\exp{\bO_1\otimes\dots\bO_N} \equiv \tr[\bE_{\bO_1}\cdot\dots\cdot \bE_{\bO_N}].$
    return sum(map(lambda term: term.get_expectation_value(), self.terms)) / self.normalization_term.get_expectation_value()

    energy1 = sum(map(lambda term: term.get_expectation_value(), self.terms)) / self.normalization_term.get_expectation_value()

    energy2 = dot(self.site_matrix.ravel().conj(),self.get_matvec()(self.site_matrix.ravel()))

    if abs(energy1-energy2)&gt;1e-10:
        print abs(energy1-energy2)/abs(energy1+energy2)
        raise RuntimeError
    else:
        print "YAY!"

    return energy1
</t>
<t tx="cog.20080210171852.24"></t>
<t tx="cog.20080210171852.25">g = Graph()

@
Note:

These dimensions are not the actual dimensions;  they are random prime numbers.

This is done so that index checking can be performed (i.e., to make sure that I've
connected all of the indices properly).  The function that is produced at the end
of the day will not depend on these dimensions at all.

@c

L = Placeholder("L",(101,101,3))
A = Placeholder("A",(2,101,111))
O = Placeholder("O",(3,3,2,2))
R = Placeholder("R",(111,111,3))

g.add_node(L)        #L_cc'c''
g.add_node(A)        #A_sab
g.add_node(O)        #O_a''b''ss'
g.add_node(A.conj()) #A*_s'a'b'
g.add_node(R)        #R_dd'd''

g.connect(1,1,0,0) #A_sab &lt;--a=c--&gt; L_cc'c''
g.connect(1,2,4,0) #A_sab &lt;--b=d--&gt; R_dd'd''
g.connect(1,0,2,2) #A_sab &lt;--s=s--&gt; O_a''b''ss'
g.connect(3,1,0,1) #A*_sab &lt;--a'=c'--&gt; L_cc'c''
g.connect(3,2,4,1) #A*_sab &lt;--b'=d'--&gt; R_dd'd''
g.connect(3,0,2,3) #A*_sab &lt;--s'=s'--&gt; O_a''b''ss'
g.connect(2,0,0,2) #O_a''b''ss' &lt;--a''=c''--&gt; L_cc'c''
g.connect(2,1,4,2) #O_a''b''ss' &lt;--b''=d''--&gt; R_dd'd''

L_data = rand(*L.shape)
A_data = rand(*A.shape)+1j*rand(*A.shape)
O_data = rand(*O.shape)
R_data = rand(*R.shape)

special_right_multiply = compile_graph(g,[0,1,2,3],["L","A","O"],function_name="special_right_multiply")
special_left_multiply = compile_graph(g,[1,2,3,4],["R","A","O"],function_name="special_left_multiply")
compute_transfer_matrix = compile_graph(g,[1,2,3],["A","O"],node_ordering=[0,4],function_name="compute_transfer_matrix")
compute_opt_matrix = compile_graph(g,[0,2,4],["L","O","R"],node_ordering=[3,1],function_name="compute_optimization_matrix")

special_matvec = compile_graph(g,[0,1,2,4],["L","O","R","A"],function_name="special_matvec")
special_rmatvec = compile_graph(g,[0,2,3,4],["L","O","R","A"],function_name="special_rmatvec")

s = Subgraph(g)
for i in xrange(5):
    s.add_node(i)

ma = s.merge_all()
special_expectation_value = s.merge_all().matrices[0].compile_with_name("special_expectation_value","L","O","R","A")

#print merge_graph(g,[0,1,2,4])

special_multiplication_graph = g
del s, g, i


g = Graph()
g.add_node(Placeholder("L",(101,101,5)))
g.add_node(Placeholder("N",(101,101)))
g.add_node(Placeholder("R1",(101,)))
g.add_node(Placeholder("R2",(101,)))
g.add_node(Placeholder("R3",(5,)))

g.connect(0,0,2,0)
g.connect(0,1,1,1)
g.connect(0,2,4,0)
g.connect(1,0,3,0)

special_multiply_inverse = compile_graph(g,[0,1],["L","N"],node_ordering=[2,3,4],function_name="special_multiply_inverse")

del g



g = Graph()
g.add_node(Placeholder("IN",(101,101,5)))
g.add_node(Placeholder("OUT",(77,77,5)))
g.add_node(Placeholder("UH",(101,77)))
g.add_node(Placeholder("UHD",(101,77)))

g.connect(0,0,2,0)
g.connect(0,1,3,0)
g.connect(1,0,2,1)
g.connect(1,1,3,1)
g.connect(0,2,1,2)

special_multiply_by_normalizer = compile_graph(g,[0,2,3],["IN","UH","UHD"],function_name="special_multiply_by_normalizer")

del g





g = Graph()
g.add_node(Placeholder("IN",(2,77,77)))
g.add_node(Placeholder("OUT",(2,101,101)))
g.add_node(Placeholder("UH",(101,77)))
g.add_node(Placeholder("VH",(101,77)))

g.connect(0,1,2,1)
g.connect(0,2,3,1)
g.connect(1,1,2,0)
g.connect(1,2,3,0)
g.connect(0,0,1,0)

special_rotate_by_normalizer = compile_graph(g,[0,2,3],["IN","UH","VH"],function_name="special_rotate_by_normalizer")

del g

del L,A,O,R
</t>
<t tx="cog.20080210171852.26">class OneDimensionalSystem(System):
    @others
</t>
<t tx="cog.20080210171852.27">def __init__(self,site_dimension,auxiliary_dimension,initial_left_site_boundary,initial_right_site_boundary,create_normalization_term=True):
    System.__init__(self)
    self.site_dimension = site_dimension
    self.auxiliary_dimension = auxiliary_dimension
    self.initial_left_site_boundary = initial_left_site_boundary
    self.initial_right_site_boundary = initial_right_site_boundary

    self.update_quantities_derivative_from_auxiliary_dimension()

    self.site_matrix = 1-2*rand(site_dimension,auxiliary_dimension,auxiliary_dimension)+1j-2j*rand(site_dimension,auxiliary_dimension,auxiliary_dimension)
    self.unnormalized_site_matrix = None

    if create_normalization_term:
        self.normalization_term = MatrixProductOperatorTerm(self,identity(self.site_dimension).reshape(1,1,self.site_dimension,self.site_dimension),ones((1)),ones((1)))


</t>
<t tx="cog.20080210171852.28">def normalize_and_absorb_site(self,direction,number_of_times_to_absorb=1):
    if direction == LEFT:
        self.site_matrix = normalize(self.site_matrix,2)
    elif direction == RIGHT:
        self.site_matrix = normalize(self.site_matrix,1)
    else:
        raise RuntimeError("direction must either be LEFT (%i) or RIGHT (%i), instead was %i" % (LEFT,RIGHT,direction))

    self.absorb_site(direction,number_of_times_to_absorb=number_of_times_to_absorb)
</t>
<t tx="cog.20080210171852.29">def increase_auxiliary_dimension_by(self,increment):
    u, s, v = svd(2*rand(self.auxiliary_dimension,self.auxiliary_dimension+increment)-1+2j*rand(self.auxiliary_dimension,self.auxiliary_dimension+increment)-1j)

    s = diag(ones(v.shape[0]))[:u.shape[0]]

    unitary = reduce(dot,[u,s,v])
    for term in [self.normalization_term] + self.terms:
        term.absorb_unitary(unitary)

    self.auxiliary_dimension += increment
    self.update_quantities_derivative_from_auxiliary_dimension()

    if self.site_matrix is not None:
        self.site_matrix = multiply_tensor_by_matrix_at_index(self.site_matrix,unitary.conj(),1)
        self.site_matrix = multiply_tensor_by_matrix_at_index(self.site_matrix,unitary,2)

    if self.unnormalized_site_matrix is not None:
        self.unnormalized_site_matrix = multiply_tensor_by_matrix_at_index(self.unnormalized_site_matrix,unitary.conj(),1)
        self.unnormalized_site_matrix = multiply_tensor_by_matrix_at_index(self.unnormalized_site_matrix,unitary,2)

    return unitary


@
    if self.site_matrix is not None:
        self.site_matrix = reduce(dot,[unitary.conj().transpose(),self.site_matrix,unitary]).transpose(1,0,2)

    if self.unnormalized_site_matrix is not None:
        self.unnormalized_site_matrix = reduce(dot,[unitary.conj().transpose(),self.unnormalized_site_matrix,unitary]).transpose(1,0,2)

@c


</t>
<t tx="cog.20080210171852.30">def update_quantities_derivative_from_auxiliary_dimension(self):
    self.site_matrix_flattened_dimension = self.site_dimension*self.auxiliary_dimension**2
    self.shape_of_site_matrix = (self.site_dimension,self.auxiliary_dimension,self.auxiliary_dimension)

</t>
<t tx="cog.20080210171852.31"></t>
<t tx="cog.20080210171852.32">class MatrixProductOperatorTerm:
    @others
</t>
<t tx="cog.20080210171852.33">def __init__(self,system,operator_matrix,left_operator_boundary,right_operator_boundary):
    self.system = system
    self.operator_matrix = operator_matrix

    self.left_operator_boundary = left_operator_boundary
    self.right_operator_boundary = right_operator_boundary

    self.left_boundary = reduce(outer_product,[system.initial_left_site_boundary,conj(system.initial_left_site_boundary),self.left_operator_boundary])
    self.right_boundary = reduce(outer_product,[system.initial_right_site_boundary,conj(system.initial_right_site_boundary),self.right_operator_boundary])

</t>
<t tx="cog.20080210171852.34">def get_matvec(self):
    L = self.left_boundary
    O = self.operator_matrix
    R = self.right_boundary
    return lambda A: special_matvec(L,O,R,A) 
</t>
<t tx="cog.20080210171852.35">def get_imatvec(self):

@
    class Dummy:
        pass

    d = Dummy()

    shape_of_site = (self.system.site_dimension,self.system.auxiliary_dimension,self.system.auxiliary_dimension)

    matvec = self.get_matvec()
    d.matvec = lambda A: matvec(A.reshape(shape_of_site)).ravel()

    #rmatvec = self.get_rmatvec()
    #d.rmatvec = lambda A: rmatvec(A.reshape(shape_of_site)).ravel()

    def imatvec(vector):
        x, info = bicgstab(d,vector.ravel(),tol=10e-10)
        assert info == 0
        return x.reshape(shape_of_site)

    return imatvec
@c


    if self.operator_matrix.shape[0] &gt; 1:
        optimization_matrix = self.get_optimization_matrix()

        inverse_optimization_matrix = pinv2(optimization_matrix)

        return lambda vector:  dot(inverse_optimization_matrix,vector.ravel()).reshape(vector.shape)

    else:

        norm_L = self.left_boundary
        norm_R = self.right_boundary

        norm_L = norm_L.reshape(norm_L.shape[:-1])
        norm_R = norm_R.reshape(norm_R.shape[:-1])

        def compute_inverse(M):
            evals, evecs = eigh(M) 
            evecs = evecs.transpose()

            evals[abs(evals)&lt;1e-13] = 0
            evals[abs(evals)&gt;=1e-13] = 1/evals[abs(evals)&gt;=1e-13]

            return dot(evecs.conj().transpose(),dot(diag(evals),evecs))

        inverse_norm_L = compute_inverse(norm_L.transpose())
        inverse_norm_R = compute_inverse(norm_R.transpose())

        return lambda site_matrix: multiply_tensor_by_matrix_at_index(multiply_tensor_by_matrix_at_index(site_matrix,inverse_norm_L,1),inverse_norm_R,2)


</t>
<t tx="cog.20080210171852.36">def get_rmatvec(self):
    L = self.left_boundary
    O = self.operator_matrix
    R = self.right_boundary
    return lambda A: special_rmatvec(L,O,R,A) 
</t>
<t tx="cog.20080210171852.37">def get_expectation_value(self):
    return special_expectation_value(
        self.left_boundary,
        self.operator_matrix,
        self.right_boundary,
        self.system.site_matrix,
    )

@    
    return  tensordot(
        self.left_boundary,
        special_left_multiply(
            self.right_boundary,
            self.system.site_matrix,
            self.operator_matrix
        ),
        ((0,1,2),(0,1,2))
    )
@c


</t>
<t tx="cog.20080210171852.38">def get_optimization_matrix(self):
    return compute_opt_matrix(self.left_boundary,self.operator_matrix,self.right_boundary).reshape((self.system.auxiliary_dimension**2 * self.system.site_dimension,)*2)

    return tensordot(
             tensordot(self.left_boundary,self.operator_matrix,(2,0)),
                                                    # sum[c''=a''] L_cc'c'' O_a''b''ss' = Y_cc'b''ss'
             self.right_boundary,(2,2)    # sum[b''=d''] Y_cc'b''ss' R_dd'd'' = Z_cc'ss'dd'
           ).transpose(3,1,5,2,0,4).reshape((self.system.auxiliary_dimension**2 * self.system.site_dimension,)*2)

</t>
<t tx="cog.20080210171852.39">def absorb_site(self,direction):
    if direction == RIGHT:
        self.right_boundary = special_left_multiply(self.right_boundary,self.system.site_matrix,self.operator_matrix)
    elif direction == LEFT:
        self.left_boundary = special_right_multiply(self.left_boundary,self.system.site_matrix,self.operator_matrix)
    else:
        raise RuntimeError("direction must either be LEFT (%i) or RIGHT (%i), instead was %i" % (LEFT,RIGHT,direction))

</t>
<t tx="cog.20080210171852.40">def absorb_unitary(self,unitary):

    self.left_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary,0)
    self.left_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary.conj(),1)
    self.right_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary.conj(),0)
    self.right_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary,1)

    return

@
    left_site_matrix = unitary.reshape((1,)+unitary.shape)

    inverse_unitary = unitary.transpose().conj()
    right_site_matrix = inverse_unitary.reshape((1,)+inverse_unitary.shape)

    operator_matrix = identity(self.operator_matrix.shape[0]).reshape(self.operator_matrix.shape[:2]+(1,1))

    self.right_boundary = special_left_multiply(self.right_boundary,right_site_matrix,operator_matrix)
    self.left_boundary  = special_right_multiply(self.left_boundary,left_site_matrix,operator_matrix)
@c
</t>
<t tx="cog.20080210171852.41"></t>
<t tx="cog.20080210171852.42">g = Graph()

@
Note:

These dimensions are not the actual dimensions;  they are random prime numbers.

This is done so that index checking can be performed (i.e., to make sure that I've
connected all of the indices properly).  The function that is produced at the end
of the day will not depend on these dimensions at all.

@c

@
L = Placeholder("L",(7,7,3,101,111))
A = Placeholder("A",(2,5,7,13,17))
O = Placeholder("O",(3,3,3,3,2,2))
R = Placeholder("R",(17,17,3,103,113))
U = Placeholder("U",(101,103,3,5,5))
D = Placeholder("D",(111,113,3,13,13))
@c

L = Placeholder("L",(7,7,3,2,2))
A = Placeholder("A",(2,5,7,13,17))
O = Placeholder("O",(3,3,3,3,2,2))
R = Placeholder("R",(17,17,3,2,2))
U = Placeholder("U",(2,3,2,5,5))
D = Placeholder("D",(3,2,2,13,13))

L_ = g.add_node(L)        #0
A_ = g.add_node(A)        #1
O_ = g.add_node(O)        #2
a_ = g.add_node(A.conj()) #3
R_ = g.add_node(R)        #4
U_ = g.add_node(U)        #5
D_ = g.add_node(D)        #6

# L tensor
g.connect(0,0,1,2) #--&gt;A
g.connect(0,2,2,1) #--&gt;O
g.connect(0,1,3,2) #--&gt;A*
g.connect(0,3,5,0) #--&gt;U
g.connect(0,4,6,1) #--&gt;D

# R tensor
g.connect(4,0,1,4) #--&gt;A
g.connect(4,2,2,3) #--&gt;O
g.connect(4,1,3,4) #--&gt;A*
g.connect(4,3,5,2) #--&gt;U
g.connect(4,4,6,2) #--&gt;D

# U tensor
g.connect(5,1,2,0) #--&gt;O
g.connect(5,3,1,1) #--&gt;A
g.connect(5,4,3,1) #--&gt;A*

# D tensor
g.connect(6,0,2,2) #--&gt;O
g.connect(6,3,1,3) #--&gt;A
g.connect(6,4,3,3) #--&gt;A*

# O tensor
g.connect(2,4,1,0)
g.connect(2,5,3,0)

special_2d_right_multiply = compile_graph(g,[0,1,2,3,5,6],["U","L","D","O","A",],function_name="special_2d_right_multiply")
special_2d_left_multiply = compile_graph(g,[1,2,3,4,5,6],["U","D","R","O","A",],function_name="special_2d_left_multiply")
special_2d_absorb_up = compile_graph(g,[U_,O_,A_,a_],["U","O","A",],node_ordering=[L_,R_,D_],function_name="special_2d_absorb_up")
#compute_transfer_matrix = compile_graph(g,[1,2,3],["A","O"],node_ordering=[0,4],function_name="compute_transfer_matrix")
compute_2d_opt_matrix = compile_graph(g,[0,2,4,5,6],["U","L","D","R","O"],node_ordering=[3,1],function_name="compute_2d_optimization_matrix")

special_2d_matvec = compile_graph(g,[0,1,2,4,5,6],["U","L","D","R","O","A"],function_name="special_2d_matvec")
special_2d_rmatvec = compile_graph(g,[0,2,3,4,5,6],["U","L","D","R","O","A"],function_name="special_2d_rmatvec")

s = Subgraph(g)
for i in xrange(7):
    s.add_node(i)
special_2d_expectation_value = s.merge_all().matrices[0].compile_with_name("special_2d_expectation_value","U","L","D","R","O","A")

special_multiplication_graph = g
del s,g,i


del L,A,O,R,U,D</t>
<t tx="cog.20080210171852.43">class TwoDimensionalSystem(System):
    @others
</t>
<t tx="cog.20080210171852.44">def __init__(self,site_dimension,horizontal_auxiliary_dimension,vertical_auxiliary_dimension,initial_up_site_boundary,initial_left_site_boundary,initial_down_site_boundary,initial_right_site_boundary,create_normalization_term=True):
    System.__init__(self)
    self.site_dimension = site_dimension
    self.horizontal_auxiliary_dimension = horizontal_auxiliary_dimension
    self.vertical_auxiliary_dimension = vertical_auxiliary_dimension
    self.initial_up_site_boundary = initial_up_site_boundary
    self.initial_left_site_boundary = initial_left_site_boundary
    self.initial_down_site_boundary = initial_down_site_boundary
    self.initial_right_site_boundary = initial_right_site_boundary

    self.update_quantities_derivative_from_auxiliary_dimension()

    self.site_matrix = 1-2*rand(*self.shape_of_site_matrix)+1j-2j*rand(*self.shape_of_site_matrix)
    self.unnormalized_site_matrix = None

    self.number_of_sites_per_column = 1

    if create_normalization_term:
        self.normalization_term = TwoDimensionalNormalizerTerm(self)
</t>
<t tx="cog.20080210171852.45">def absorb_site(self,direction,number_of_times_to_absorb=1):

    for i in xrange(number_of_times_to_absorb):
        for term in self.terms + [self.normalization_term]:
            term.absorb_site(direction)

    self.total_number_of_sites += self.number_of_sites_per_column


</t>
<t tx="cog.20080210171852.46">def normalize_and_absorb_site(self,direction,number_of_times_to_absorb=1):
    self.normalize_site(direction)
    self.absorb_site(direction)
</t>
<t tx="cog.20080210171852.47">def normalize_site(self,direction):
    if direction == LEFT:
        self.site_matrix = normalize(self.site_matrix,4)
    elif direction == RIGHT:
        self.site_matrix = normalize(self.site_matrix,2)
    elif direction == UP:
        self.site_matrix = normalize(self.site_matrix,3)
    else:
        raise RuntimeError("direction must either be LEFT (%i) or RIGHT (%i), instead was %i" % (LEFT,RIGHT,direction))</t>
<t tx="cog.20080210171852.48">def increase_horizontal_auxiliary_dimension_by(self,increment):
    u, s, v = svd(2*rand(self.horizontal_auxiliary_dimension,self.horizontal_auxiliary_dimension+increment)-1+2j*rand(self.horizontal_auxiliary_dimension,self.horizontal_auxiliary_dimension+increment)-1j)
    s = diag(ones(v.shape[0]))[:u.shape[0]]
    unitary = reduce(dot,[u,s,v])

    self.horizontal_auxiliary_dimension += increment
    self.update_quantities_derivative_from_auxiliary_dimension()

    if self.site_matrix is not None:
        self.site_matrix = multiply_tensor_by_matrix_at_index(self.site_matrix,unitary.conj(),2)
        self.site_matrix = multiply_tensor_by_matrix_at_index(self.site_matrix,unitary,4)
        #self.site_matrix = multiply_tensor_by_matrix_at_index(self.site_matrix,unitary.conj(),1)
        #self.site_matrix = multiply_tensor_by_matrix_at_index(self.site_matrix,unitary,3)

    if self.unnormalized_site_matrix is not None:
        self.unnormalized_site_matrix = multiply_tensor_by_matrix_at_index(self.unnormalized_site_matrix,unitary.conj(),2)
        self.unnormalized_site_matrix = multiply_tensor_by_matrix_at_index(self.unnormalized_site_matrix,unitary,4)
        #self.unnormalized_site_matrix = multiply_tensor_by_matrix_at_index(self.unnormalized_site_matrix,unitary.conj(),1)
        #self.unnormalized_site_matrix = multiply_tensor_by_matrix_at_index(self.unnormalized_site_matrix,unitary,3)

    for term in [self.normalization_term] + self.terms:
        term.absorb_unitary(unitary)

</t>
<t tx="cog.20080210171852.49">def update_quantities_derivative_from_auxiliary_dimension(self):
    self.site_matrix_flattened_dimension = self.site_dimension*self.vertical_auxiliary_dimension**2*self.horizontal_auxiliary_dimension**2
    self.shape_of_site_matrix = (self.site_dimension,)+(self.vertical_auxiliary_dimension,self.horizontal_auxiliary_dimension)*2
</t>
<t tx="cog.20080210171852.50">def compute_energy_per_term(self):
    boundary = self.normalization_term.get_infinite_limit_boundary()

    return sum([term.get_energy_per_term(*boundary) for term in self.terms])
</t>
<t tx="cog.20080210171852.51">def absorb_row(self,direction):
    #self.normalize_site(UP)

    self.horizontal_auxiliary_dimension = 1
    self.update_quantities_derivative_from_auxiliary_dimension()

    params = self.normalization_term.absorb_row(direction)
    for term in self.terms:
        term.absorb_row(direction,*params)

    self.number_of_sites_per_column += 1
    self.total_number_of_sites = self.number_of_sites_per_column

    self.site_matrix = 1-2*rand(*self.shape_of_site_matrix)+1j-2j*rand(*self.shape_of_site_matrix)
    self.unnormalized_site_matrix = None
</t>
<t tx="cog.20080210171852.52">def replace_boundaries_with_infinite_limit(self):
    U, L, D, R = self.normalization_term.get_infinite_limit_boundary()
    for term in self.terms + [self.normalization_term]:
        term.replace_boundaries_with(L,R)
    self.total_number_of_sites = 1

</t>
<t tx="cog.20080210171852.53">class ProtoPEPSOperatorTerm:
    @others
</t>
<t tx="cog.20080210171852.54">def __init__(self,system,operator_matrix,left_operator_boundary,right_operator_boundary,up_boundary,down_boundary,left_up_boundary,left_down_boundary,right_up_boundary,right_down_boundary):
    self.system = system
    self.operator_matrix = operator_matrix

    self.left_boundary = reduce(outer_product,[
        system.initial_left_site_boundary,
        system.initial_left_site_boundary.conj(),
        left_operator_boundary,
        left_up_boundary,
        left_down_boundary,
    ])

    self.right_boundary = reduce(outer_product,[
        system.initial_right_site_boundary,
        system.initial_right_site_boundary.conj(),
        right_operator_boundary,
        right_up_boundary,
        right_down_boundary,
    ])

    self.up_boundary = reduce(outer_product,[
        up_boundary,
        system.initial_up_site_boundary,
        system.initial_up_site_boundary.conj(),
    ])

    self.down_boundary = reduce(outer_product,[
        down_boundary,
        system.initial_down_site_boundary,
        system.initial_down_site_boundary.conj(),
    ])
</t>
<t tx="cog.20080210171852.55">def get_matvec(self):
    U = self.up_boundary
    L = self.left_boundary
    D = self.down_boundary
    R = self.right_boundary
    O = self.operator_matrix
    return lambda A: special_2d_matvec(U,L,D,R,O,A)
</t>
<t tx="cog.20080210171852.56">def get_imatvec(self):

    class Dummy:
        pass

    d = Dummy()

    shape_of_site_matrix = self.system.shape_of_site_matrix

    matvec = self.get_matvec()
    d.matvec = lambda A: matvec(A.reshape(shape_of_site_matrix)).ravel()

    #rmatvec = self.get_ratvec()
    #d.rmatvec = lambda A: rmatvec(A.reshape(shape_of_site_matrix)).ravel()

    def imatvec(vector):
        x, info = bicgstab(d,vector.ravel(),tol=10e-10)
        if info != 0:
            raise RuntimeError("info=%i" % i)
        return x.reshape(shape_of_site_matrix)

    return imatvec
</t>
<t tx="cog.20080210171852.57">def get_rmatvec(self):
    U = self.up_boundary
    L = self.left_boundary
    D = self.down_boundary
    R = self.right_boundary
    O = self.operator_matrix
    return lambda A: special_2d_rmatvec(U,L,D,R,O,A) 

</t>
<t tx="cog.20080210171852.58">def get_expectation_value(self):
    return special_2d_expectation_value(
        self.up_boundary,
        self.left_boundary,
        self.down_boundary,
        self.right_boundary,
        self.operator_matrix,
        self.system.site_matrix
    )

</t>
<t tx="cog.20080210171852.59">@
def get_optimization_matrix(self):
    return compute_2d_opt_matrix(self.left_boundary,self.operator_matrix,self.right_boundary).reshape((self.system.auxiliary_dimension**2 * self.system.site_dimension,)*2)

    return tensordot(
             tensordot(self.left_boundary,self.operator_matrix,(2,0)),
                                                    # sum[c''=a''] L_cc'c'' O_a''b''ss' = Y_cc'b''ss'
             self.right_boundary,(2,2)    # sum[b''=d''] Y_cc'b''ss' R_dd'd'' = Z_cc'ss'dd'
).transpose(3,1,5,2,0,4).reshape((self.system.auxiliary_dimension**2 * self.system.site_dimension,)*2)

@c
</t>
<t tx="cog.20080210171852.60">def absorb_site(self,direction):
    if direction == RIGHT:
        self.right_boundary = special_2d_left_multiply(
            self.up_boundary,
            self.down_boundary,
            self.right_boundary,
            self.operator_matrix,
            self.system.site_matrix,
        )
    elif direction == LEFT:
        self.left_boundary = special_2d_right_multiply(
            self.up_boundary,
            self.left_boundary,
            self.down_boundary,
            self.operator_matrix,
            self.system.site_matrix,
        )
    else:
        raise RuntimeError("direction must either be LEFT (%i) or RIGHT (%i), instead was %i" % (LEFT,RIGHT,direction))

</t>
<t tx="cog.20080210171852.61">def absorb_unitary(self,unitary):

    self.left_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary,0)
    self.left_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary.conj(),1)
    self.right_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary.conj(),0)
    self.right_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary,1)

@
    self.up_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary,2)
    self.up_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary.conj(),3)
    self.down_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary.conj(),2)
    self.down_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary,3)
@c
    return
</t>
<t tx="cog.20080210171852.62">class PEPSOperatorTerm:
    @others
</t>
<t tx="cog.20080210171852.63">def __init__(self,system,operator_matrix,up_operator_boundary,left_operator_boundary,down_operator_boundary,right_operator_boundary):
    self.system = system
    self.operator_matrix = operator_matrix

    self.left_boundary = reduce(outer_product,[
        system.initial_left_site_boundary,
        system.initial_left_site_boundary.conj(),
        left_operator_boundary,
    ])

    self.right_boundary = reduce(outer_product,[
        system.initial_right_site_boundary,
        system.initial_right_site_boundary.conj(),
        right_operator_boundary,
    ])

    self.up_boundary = reduce(outer_product,[
        up_operator_boundary,
        system.initial_up_site_boundary,
        system.initial_up_site_boundary.conj(),
    ])

    self.down_boundary = reduce(outer_product,[
        down_operator_boundary,
        system.initial_down_site_boundary,
        system.initial_down_site_boundary.conj(),
    ])
</t>
<t tx="cog.20080210171852.64">def get_matvec(self):
    U = self.up_boundary
    L = self.left_boundary
    D = self.down_boundary
    R = self.right_boundary
    O = self.operator_matrix
    return lambda A: special_2d_matvec(U,L,D,R,O,A)
</t>
<t tx="cog.20080210171852.65">def get_imatvec(self):

    class Dummy:
        pass

    d = Dummy()

    shape_of_site_matrix = self.system.shape_of_site_matrix

    matvec = self.get_matvec()
    d.matvec = lambda A: matvec(A.reshape(shape_of_site_matrix)).ravel()

    #rmatvec = self.get_ratvec()
    #d.rmatvec = lambda A: rmatvec(A.reshape(shape_of_site_matrix)).ravel()

    def imatvec(vector):
        x, info = bicgstab(d,vector.ravel(),tol=10e-10)
        if info != 0:
            raise RuntimeError("info=%i" % i)
        return x.reshape(shape_of_site_matrix)

    return imatvec
</t>
<t tx="cog.20080210171852.66">def get_rmatvec(self):
    U = self.up_boundary
    L = self.left_boundary
    D = self.down_boundary
    R = self.right_boundary
    O = self.operator_matrix
    return lambda A: special_2d_rmatvec(U,L,D,R,O,A) 

</t>
<t tx="cog.20080210171852.67">def get_expectation_value(self):
    return special_2d_expectation_value(
        self.up_boundary,
        self.left_boundary,
        self.down_boundary,
        self.right_boundary,
        self.operator_matrix,
        self.system.site_matrix
    )

</t>
<t tx="cog.20080210171852.68">@
def get_optimization_matrix(self):
    return compute_2d_opt_matrix(self.left_boundary,self.operator_matrix,self.right_boundary).reshape((self.system.auxiliary_dimension**2 * self.system.site_dimension,)*2)

    return tensordot(
             tensordot(self.left_boundary,self.operator_matrix,(2,0)),
                                                    # sum[c''=a''] L_cc'c'' O_a''b''ss' = Y_cc'b''ss'
             self.right_boundary,(2,2)    # sum[b''=d''] Y_cc'b''ss' R_dd'd'' = Z_cc'ss'dd'
).transpose(3,1,5,2,0,4).reshape((self.system.auxiliary_dimension**2 * self.system.site_dimension,)*2)

@c
</t>
<t tx="cog.20080210171852.69">def absorb_site(self,direction):
    if direction == RIGHT:
        self.right_boundary = special_2d_left_multiply(
            self.up_boundary,
            self.down_boundary,
            self.right_boundary,
            self.operator_matrix,
            self.system.site_matrix,
        )
    elif direction == LEFT:
        self.left_boundary = special_2d_right_multiply(
            self.up_boundary,
            self.left_boundary,
            self.down_boundary,
            self.operator_matrix,
            self.system.site_matrix,
        )
    else:
        raise RuntimeError("direction must either be LEFT (%i) or RIGHT (%i), instead was %i" % (LEFT,RIGHT,direction))

</t>
<t tx="cog.20080210171852.70">def absorb_unitary(self,unitary):

    self.left_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary,0)
    self.left_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary.conj(),1)
    self.right_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary.conj(),0)
    self.right_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary,1)

@
    self.up_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary,2)
    self.up_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary.conj(),3)
    self.down_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary.conj(),2)
    self.down_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary,3)
@c
    return
</t>
<t tx="cog.20080210171852.71">def absorb_row(self,direction,new_left_site_boundary,new_right_site_boundary):
    assert direction == UP

    U = self.up_boundary
    O = self.operator_matrix
    S = self.system.site_matrix
    s = self.system.site_matrix.conj()

    g = Graph()

    g.add_node(U)
    g.add_node(O)
    g.add_node(S)
    g.add_node(s)


@
def absorb_row(self,direction,new_left_site_boundary,new_right_site_boundary):
    if direction == UP:
        newU = special_2d_absorb_up(self.up_boundary,self.operator_matrix,self.system.site_matrix
            ).reshape(
self.up_boundary.shape[0]*self.system.site_matrix.shape[2],
self.up_boundary.shape[0]*self.system.site_matrix.shape[2],
                self.down_boundary.shape[0],
                self.system.site_matrix.shape[3],
                self.system.site_matrix.shape[3],
            ).transpose(
                0,
                2,
                1,
                3,
                4,
            )

        newL = multiply.outer(
            new_left_site_boundary,      # 0,1,2,3
            self.left_operator_boundary, # 4,5,6
        ).transpose(
            0,
            1,
            4,
            2,5,
            3,6,
        ).reshape(
            new_left_site_boundary.shape[0],
            new_left_site_boundary.shape[1],
            self.left_operator_boundary.shape[0],
new_left_site_boundary.shape[2]*self.left_operator_boundary.shape[1],
new_left_site_boundary.shape[3]*self.left_operator_boundary.shape[2],
        )

        newR = multiply.outer(
            new_right_site_boundary,      # 0,1,2,3
            self.right_operator_boundary, # 4,5,6
        ).transpose(
            0,
            1,
            4,
            2,5,
            3,6,
        ).reshape(
            new_right_site_boundary.shape[0],
            new_right_site_boundary.shape[1],
            self.right_operator_boundary.shape[0],
new_right_site_boundary.shape[2]*self.right_operator_boundary.shape[1],
new_right_site_boundary.shape[3]*self.right_operator_boundary.shape[2],
        )


    else:
        raise RuntimeError("only absorbing up supported at this time")
@c

</t>
<t tx="cog.20080210171852.72">class MagneticFieldTerm(PEPSOperatorTerm):
    @others
</t>
<t tx="cog.20080210171852.73">def __init__(self,system):

    self.system = system

    self.left_boundary = reduce(outer_product,[
        system.initial_left_site_boundary,
        system.initial_left_site_boundary.conj(),
        ones((1,)),
        array([1,0]),
    ])

    self.right_boundary = reduce(outer_product,[
        system.initial_right_site_boundary,
        system.initial_right_site_boundary.conj(),
        ones((1,)),
        array([0,1]),
    ])

    self.up_boundary = reduce(outer_product,[
        ones((1,)),
        ones((1,)),
        array([1,0]),
        system.initial_up_site_boundary,
        system.initial_up_site_boundary.conj(),
    ])

    down_operator_boundary = zeros((2,2,2))
    down_operator_boundary[0,0,0] = 1
    down_operator_boundary[0,1,1] = 1
    down_operator_boundary[1,1,0] = 1

    self.down_boundary = reduce(outer_product,[
        down_operator_boundary,
        system.initial_down_site_boundary,
        system.initial_down_site_boundary.conj(),
    ])

    I = identity(2)
    Z = array([[1,0],[0,-1]])

    self.operator_matrix = zeros((2,2,2,2))
    self.operator_matrix[0,0] = I
    self.operator_matrix[0,1] = -Z
    self.operator_matrix[1,1] = I

    self.update_multiplication_functions()


</t>
<t tx="cog.20080210171852.74">def get_optimization_matrix(self):

    U = self.up_boundary
    L = self.left_boundary
    D = self.down_boundary
    R = self.right_boundary
    O = self.operator_matrix

    return self.compute_optimization_matrix(U,L,D,R,O).reshape((prod(self.system.shape_of_site_matrix),)*2)
</t>
<t tx="cog.20080210171852.75">def get_matvec(self):
    U = self.up_boundary
    L = self.left_boundary
    D = self.down_boundary
    R = self.right_boundary
    O = self.operator_matrix
    matvec = self.matvec
    return lambda A: matvec(U,L,D,R,O,A)
</t>
<t tx="cog.20080210171852.76">def get_matvec(self):
    O = self.get_optimization_matrix()
    return lambda A: dot(O,A.ravel())
</t>
<t tx="cog.20080210171852.77">def get_expectation_value(self):
    return self.expectation_value(
        self.up_boundary,
        self.left_boundary,
        self.down_boundary,
        self.right_boundary,
        self.operator_matrix,
        self.system.site_matrix
    )

</t>
<t tx="cog.20080210171852.78">def absorb_site(self,direction):
    if direction == RIGHT:
        self.right_boundary = self.left_multiply(
            self.up_boundary,
            self.down_boundary,
            self.right_boundary,
            self.operator_matrix,
            self.system.site_matrix,
        )
    elif direction == LEFT:
        self.left_boundary = self.right_multiply(
            self.up_boundary,
            self.left_boundary,
            self.down_boundary,
            self.operator_matrix,
            self.system.site_matrix,
        )
    else:
        raise RuntimeError("direction must either be LEFT (%i) or RIGHT (%i), instead was %i" % (LEFT,RIGHT,direction))

</t>
<t tx="cog.20080210171852.79">def absorb_unitary(self,unitary):

    self.left_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary,0)
    self.left_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary.conj(),1)
    self.right_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary.conj(),0)
    self.right_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary,1)

@
    self.up_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary,2)
    self.up_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary.conj(),3)
    self.down_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary.conj(),2)
    self.down_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary,3)
@c

    self.update_multiplication_functions()

</t>
<t tx="cog.20080210171852.80">def absorb_row(self,direction,normalizer_left_boundary,normalizer_right_boundary,X):
    if direction == UP:

        self.up_boundary = self.absorb_up(self.up_boundary,self.operator_matrix,self.system.site_matrix
        ).reshape(
            self.up_boundary.shape[0]*self.system.site_matrix.shape[2]**2,
            self.up_boundary.shape[1]*self.system.site_matrix.shape[4]**2,
            self.operator_matrix.shape[1],
            self.system.site_matrix.shape[3],
            self.system.site_matrix.shape[3],
        )

        self.up_boundary = multiply_tensor_by_matrix_at_index(self.up_boundary,X.transpose(),0)
        self.up_boundary = multiply_tensor_by_matrix_at_index(self.up_boundary,X.conj().transpose(),1)

        self.replace_boundaries_with(normalizer_left_boundary,normalizer_right_boundary)

        self.update_multiplication_functions()

    else:
        assert direction == DOWN

        D = self.system.site_matrix.shape[2]**2*self.down_boundary.shape[0]
        #D2 = self.system.site_matrix.shape[4]**2*self.down_boundary.shape[1]

        self.down_boundary = self.absorb_down(self.down_boundary,self.operator_matrix,self.system.site_matrix
        ).reshape(
            D/2,
            2,
            D/2,
            2,
            self.operator_matrix.shape[1],
            self.system.site_matrix.shape[1],
            self.system.site_matrix.shape[1],
        )

        self.down_boundary = multiply_tensor_by_matrix_at_index(self.down_boundary,X.transpose(),0)
        self.down_boundary = multiply_tensor_by_matrix_at_index(self.down_boundary,X.conj().transpose(),2)

        self.down_boundary = self.down_boundary.reshape(
            self.down_boundary.shape[0]*self.down_boundary.shape[1],
            self.down_boundary.shape[2]*self.down_boundary.shape[3],
            self.operator_matrix.shape[1],
            self.system.site_matrix.shape[1],
            self.system.site_matrix.shape[1],
        )

        self.replace_boundaries_with(normalizer_left_boundary,normalizer_right_boundary)

        self.update_multiplication_functions()


</t>
<t tx="cog.20080210171852.81">def update_multiplication_functions(self):
    @others
</t>
<t tx="cog.20080210171852.82">g = Graph()

@
Note:

These dimensions are not the actual dimensions;  they are random prime numbers.

This is done so that index checking can be performed (i.e., to make sure that I've
connected all of the indices properly).  The function that is produced at the end
of the day will not depend on these dimensions at all.

@c

@
L = Placeholder("L",(7,7,3,101,111))
A = Placeholder("A",(2,5,7,13,17))
O = Placeholder("O",(3,3,3,3,2,2))
R = Placeholder("R",(17,17,3,103,113))
U = Placeholder("U",(101,103,3,5,5))
D = Placeholder("D",(111,113,3,13,13))
@c

@
L = Placeholder("L",(7,7,2,2))
A = Placeholder("A",(2,5,7,13,17))
O = Placeholder("O",(3,3,2,2))
R = Placeholder("R",(17,17,2,2))
U = Placeholder("U",(2,2,3,5,5))
D = Placeholder("D",(2,2,3,13,13))
@c

U = Placeholder("U",ensure_dimensions_greater_than_one(self.up_boundary.shape))
L = Placeholder("L",ensure_dimensions_greater_than_one(self.left_boundary.shape))
D = Placeholder("D",ensure_dimensions_greater_than_one(self.down_boundary.shape))
R = Placeholder("R",ensure_dimensions_greater_than_one(self.right_boundary.shape))
A = Placeholder("A",ensure_dimensions_greater_than_one(self.system.shape_of_site_matrix))
O = Placeholder("O",ensure_dimensions_greater_than_one(self.operator_matrix.shape))

L_ = g.add_node(L)        #0
A_ = g.add_node(A)        #1
O_ = g.add_node(O)        #2
a_ = g.add_node(A.conj()) #3
R_ = g.add_node(R)        #4
U_ = g.add_node(U)        #5
D_ = g.add_node(D)        #6

# L tensor
g.connect(L_,0,A_,2) #--&gt;A
g.connect(L_,1,a_,2) #--&gt;A*
g.connect(L_,2,U_,0) #--&gt;U
g.connect(L_,3,D_,0) #--&gt;D

# R tensor
g.connect(R_,0,A_,4) #--&gt;A
g.connect(R_,1,a_,4) #--&gt;A*
g.connect(R_,2,U_,1) #--&gt;U
g.connect(R_,3,D_,1) #--&gt;D

# U tensor
g.connect(U_,2,O_,0) #--&gt;O
g.connect(U_,3,A_,1) #--&gt;A
g.connect(U_,4,a_,1) #--&gt;A*

# D tensor
g.connect(D_,2,O_,1) #--&gt;O
g.connect(D_,3,A_,3) #--&gt;A
g.connect(D_,4,a_,3) #--&gt;A*

# O tensor
g.connect(O_,2,A_,0)
g.connect(O_,3,a_,0)

node_ids = {}
for name in ["U","L","D","R","A","O"]:
    node_ids[name] = vars()[name+"_"]

for name, variables, other_nodes, ordering in [
    ("right_multiply", ["U","L","D","O","A"], [a_], None),
    ("left_multiply", ["U","D","R","O","A"], [a_], None),
    ("matvec",["U","L","D","R","O","A"], [], None),
    ("absorb_up",["U","O","A"], [a_], [L_,R_,D_]),
    ("absorb_down",["D","O","A"], [a_], [L_,R_,U_]),
    ("compute_optimization_matrix", ["U","L","D","R","O"], [], [a_,A_] ),
    ]:
        setattr(self,name,compile_graph(
            g,
            [node_ids[name] for name in variables] + other_nodes,
            variables,
            node_ordering=ordering,
            function_name=name
            )
        )


s = Subgraph(g)
for i in xrange(len(g.nodes)):
    s.add_node(i)
self.expectation_value = s.merge_all().matrices[0].compile_with_name("expectation_value","U","L","D","R","O","A")

self.multiplication_graph = g
del s,g,i


del L,A,O,R,U,D,L_,A_,a_,O_,R_,U_,D_

</t>
<t tx="cog.20080210171852.83">def replace_boundaries_with(self,normalizer_left_boundary,normalizer_right_boundary):

    horizontal_boundary_shape = copy(normalizer_left_boundary.shape)
    horizontal_boundary_shape[-1] *= 2

    self.left_boundary = multiply.outer(normalizer_left_boundary,array([1,0])).reshape(horizontal_boundary_shape)
    self.right_boundary = multiply.outer(normalizer_right_boundary,array([0,1])).reshape(horizontal_boundary_shape)
</t>
<t tx="cog.20080210171852.84">def get_energy_per_term(self,up_boundary,left_boundary,down_boundary,right_boundary):
    g = Graph()

    U_ = g.add_node(up_boundary)
    L_ = g.add_node(left_boundary)
    D_ = g.add_node(down_boundary)
    R_ = g.add_node(right_boundary)
    O_ = g.add_node(array([[-1,0],[0,1]]))
    S_ = g.add_node(self.system.site_matrix)
    s_ = g.add_node(self.system.site_matrix.conj())

    g.connect(L_,0,S_,2)
    g.connect(L_,1,s_,2)
    g.connect(L_,2,U_,0)
    g.connect(L_,3,D_,0)

    g.connect(R_,0,S_,4)
    g.connect(R_,1,s_,4)
    g.connect(R_,2,U_,1)
    g.connect(R_,3,D_,1)

    g.connect(U_,2,S_,1)
    g.connect(U_,3,s_,1)

    g.connect(D_,2,S_,3)
    g.connect(D_,3,s_,3)

    g.connect(O_,0,s_,0)
    g.connect(O_,1,S_,0)

    s = Subgraph(g)
    for i in g.nodes.keys():
        s.add_node(i)

    expectation = abs(s.merge_all().matrices[0])

    s = Subgraph(g)
    for i in g.nodes.keys():
        if i == O_:
            s.add_node(O_,identity(2))
        else:
            s.add_node(i)

    normalization = abs(s.merge_all().matrices[0])

    return expectation/normalization
</t>
<t tx="cog.20080210171852.85">class TwoDimensionalNormalizerTerm:
    @others
</t>
<t tx="cog.20080210171852.86">def __init__(self,system):
    self.system = system

    self.left_boundary = reduce(outer_product,[
        system.initial_left_site_boundary,
        system.initial_left_site_boundary.conj(),
        ones((1,)),
        ones((1,)),
    ])

    self.right_boundary = reduce(outer_product,[
        system.initial_right_site_boundary,
        system.initial_right_site_boundary.conj(),
        ones((1,)),
        ones((1,)),
    ])

    self.up_boundary = reduce(outer_product,[
        ones((1,)),
        ones((1,)),
        system.initial_up_site_boundary,
        system.initial_up_site_boundary.conj(),
    ])

    self.down_boundary = reduce(outer_product,[
        ones((1,)),
        ones((1,)),
        system.initial_down_site_boundary,
        system.initial_down_site_boundary.conj(),
    ])

    self.update_multiplication_functions()

</t>
<t tx="cog.20080210171852.87">def get_optimization_matrix(self):

    U = self.up_boundary
    L = self.left_boundary
    D = self.down_boundary
    R = self.right_boundary

    return self.compute_optimization_matrix(U,L,D,R).reshape((prod(self.system.shape_of_site_matrix[1:]),)*2)
</t>
<t tx="cog.20080210171852.88">def get_matvec(self):
    U = self.up_boundary
    L = self.left_boundary
    D = self.down_boundary
    R = self.right_boundary

    return lambda A: self.matvec(U,L,D,R,A)

    #A = Placeholder("A",shape=self.system.shape_of_site_matrix)
    #return self.matvec(U,L,D,R,A).compile("A")

</t>
<t tx="cog.20080210171852.89">def get_matvec(self):
    O = self.get_optimization_matrix()
    site_matrix_shape = (self.system.shape_of_site_matrix[0],prod(self.system.shape_of_site_matrix[1:]))
    return lambda A: dot(A.reshape(site_matrix_shape),O.transpose())
</t>
<t tx="cog.20080210171852.90">def get_imatvec(self):

    class Dummy:
        pass

    d = Dummy()

    shape_of_site_matrix = self.system.shape_of_site_matrix

    N = self.get_optimization_matrix()

    def imatvec(vector):
        vector = vector.reshape(shape_of_site_matrix)
        x0, info = bicgstab(N,vector[0].ravel(),tol=1e-8) #,maxiter=10) #,tol=1e-10)
        x1, info = bicgstab(N,vector[1].ravel(),tol=1e-8) #,maxiter=10) #,tol=1e-10)
        #if info != 0:
        #    x, info = bicgstab(d,vector.ravel(),tol=1e-6)
        #    if info != 0:
        #        raise RuntimeError("info=%i" % info)
        return array([x0,x1]).reshape(shape_of_site_matrix)

    return imatvec
</t>
<t tx="cog.20080210171852.91">def get_imatvec(self):

    class Dummy:
        pass

    d = Dummy()

    shape_of_site_matrix = self.system.shape_of_site_matrix

    matvec = self.get_matvec()
    d.matvec = lambda A: matvec(A.reshape(shape_of_site_matrix)).ravel()

    #rmatvec = self.get_ratvec()
    #d.rmatvec = lambda A: rmatvec(A.reshape(shape_of_site_matrix)).ravel()

    def imatvec(vector):
        x, info = bicgstab(d,vector.ravel(),tol=1e-8) #,maxiter=10) #,tol=1e-10)
        #if info != 0:
        #    x, info = bicgstab(d,vector.ravel(),tol=1e-6)
        #    if info != 0:
        #        raise RuntimeError("info=%i" % info)
        return x.reshape(shape_of_site_matrix)

    return imatvec
</t>
<t tx="cog.20080210171852.92">def get_imatvec(self):

    N = self.get_optimization_matrix()

    Ninv = pinv2(N)

    new_A_shape = (self.system.shape_of_site_matrix[0],Ninv.shape[0])

    return lambda A: dot(A.reshape(new_A_shape),Ninv.transpose())
</t>
<t tx="cog.20080210171852.93">def get_rmatvec(self):
    U = self.up_boundary
    L = self.left_boundary
    D = self.down_boundary
    R = self.right_boundary
    return lambda A: self.rmatvec(U,L,D,R,A) 

</t>
<t tx="cog.20080210171852.94">def get_expectation_value(self):
    return self.expectation_value(
        self.up_boundary,
        self.left_boundary,
        self.down_boundary,
        self.right_boundary,
        self.system.site_matrix
    )

</t>
<t tx="cog.20080210171852.95">def get_infinite_limit_boundary(self):
    U = self.up_boundary
    D = self.down_boundary
    S = self.system.site_matrix

    left_boundary_shape = self.left_boundary.shape
    right_boundary_shape = self.right_boundary.shape

    right_evals, right_evecs = my_eigen(
            lambda R: self.left_multiply(U,D,R.reshape(right_boundary_shape),S).ravel(),
            prod(left_boundary_shape),
            which='LM'
            )

    left_evals, left_evecs = my_eigen(
            lambda L: self.right_multiply(U,L.reshape(left_boundary_shape),D,S).ravel(),
            prod(right_boundary_shape),
            which='LM'
            )

    return U, left_evecs[:,0].reshape(left_boundary_shape), D, right_evecs[:,0].reshape(right_boundary_shape)
</t>
<t tx="cog.20080210171852.96">def update_multiplication_functions(self):
    @others
</t>
<t tx="cog.20080210171852.97">g = Graph()

@
Note:

These dimensions are not the actual dimensions;  they are random prime numbers.

This is done so that index checking can be performed (i.e., to make sure that I've
connected all of the indices properly).  The function that is produced at the end
of the day will not depend on these dimensions at all.

@c

L = Placeholder("L",ensure_dimensions_greater_than_one(self.left_boundary.shape))
A = Placeholder("A",ensure_dimensions_greater_than_one(self.system.shape_of_site_matrix))
R = Placeholder("R",ensure_dimensions_greater_than_one(self.right_boundary.shape))
U = Placeholder("U",ensure_dimensions_greater_than_one(self.up_boundary.shape))
D = Placeholder("D",ensure_dimensions_greater_than_one(self.down_boundary.shape))

@
L = Placeholder("L",(7,7,2,2))
A = Placeholder("A",(2,5,7,13,17))
R = Placeholder("R",(17,17,2,2))
U = Placeholder("U",(2,2,5,5))
D = Placeholder("D",(2,2,13,13))
@c

L_ = g.add_node(L)        #0
A_ = g.add_node(A)        #1
a_ = g.add_node(A.conj()) #2
R_ = g.add_node(R)        #3
U_ = g.add_node(U)        #4
D_ = g.add_node(D)        #5

# L tensor
g.connect(L_,0,A_,2)
g.connect(L_,1,a_,2)
g.connect(L_,2,U_,0)
g.connect(L_,3,D_,0)

# R tensor
g.connect(R_,0,A_,4)
g.connect(R_,1,a_,4)
g.connect(R_,2,U_,1)
g.connect(R_,3,D_,1)

# U tensor
g.connect(U_,2,A_,1)
g.connect(U_,3,a_,1)

# D tensor
g.connect(D_,2,A_,3)
g.connect(D_,3,a_,3)

# A tensor
g.connect(A_,0,a_,0)

node_ids = {}
for name in ["U","L","D","R","A"]:
    node_ids[name] = vars()[name+"_"]

for name, variables, other_nodes, ordering in [
    ("right_multiply", ["U","L","D","A"], [a_], None),
    ("left_multiply", ["U","D","R","A"], [a_], None),
    ("matvec",["U","L","D","R","A"], [], None),
    ("absorb_up",["U","A"], [a_], [L_,R_,D_]),
    ("absorb_down",["D","A"], [a_], [L_,R_,U_]),
    ("compute_optimization_matrix", ["U","L","D","R"], [], [a_,A_] ),
    ("compute_r_optimization_matrix", ["U","L","D","R"], [], [A_,a_] ),
    ]:
        setattr(self,name,compile_graph(
            g,
            [node_ids[name] for name in variables] + other_nodes,
            variables,
            node_ordering=ordering,
            function_name=name
            )
        )

@
self.right_multiply = compile_graph(g,[0,1,2,4,5],["U","L","D","A",],function_name="right_multiply")
self.left_multiply = compile_graph(g,[1,2,3,4,5],["U","D","R","A",],function_name="left_multiply")

self.matvec = compile_graph(g,[0,1,3,4,5],["U","L","D","R","A"],function_name="matvec")
self.rmatvec = compile_graph(g,[0,2,3,4,5],["U","L","D","R","A"],function_name="rmatvec")

self.absorb_up = compile_graph(g,[U_,A_,a_],["U","A",],node_ordering=[L_,R_,D_], function_name="absorb_up")
self.absorb_down = compile_graph(g,[D_,A_,a_],["D","A",],node_ordering=[L_,R_,U_], function_name="absorb_down")
@c

s = Subgraph(g)
for i in xrange(6):
    s.add_node(i)
self.expectation_value = s.merge_all().matrices[0].compile_with_name("special_2d_normalizer_expectation_value","U","L","D","R","A")

self.multiplication_graph = g
del s, g, i

del L, A, R, U, D

</t>
<t tx="cog.20080210171852.98">@
IN = Placeholder("IN",(7,7,111,101))
P_UP = Placeholder("P_UP",(111,111,111))
P_DOWN = Placeholder("P_DOWN",(101,101,101))

OUT1 = Placeholder("OUT1",(7,))
OUT2 = Placeholder("OUT2",(7,))
OUT3 = Placeholder("OUT3",(7,))
OUT4 = Placeholder("OUT4",(7,))
OUT5 = Placeholder("OUT5",(111,))
OUT6 = Placeholder("OUT6",(101,))

g = Graph()

IN1_ = g.add_node(IN)
IN2_ = g.add_node(IN)
P_UP_ = g.add_node(P_UP)
P_DOWN_ = g.add_node(P_DOWN)

OUT1_ = g.add_node(OUT1)
OUT2_ = g.add_node(OUT2)
OUT3_ = g.add_node(OUT3)
OUT4_ = g.add_node(OUT4)
OUT5_ = g.add_node(OUT5)
OUT6_ = g.add_node(OUT6)

g.connect(IN1_,0,OUT1_,0)
g.connect(IN1_,1,OUT2_,0)
g.connect(IN2_,0,OUT3_,0)
g.connect(IN2_,1,OUT4_,0)
g.connect(P_UP_,2,OUT5_,0)
g.connect(P_DOWN_,2,OUT6_,0)

g.connect(IN1_,2,P_UP_,0)
g.connect(IN2_,2,P_UP_,1)

g.connect(IN1_,3,P_DOWN_,0)
g.connect(IN2_,3,P_DOWN_,1)

self.extend_indices = compile_graph(g,[0,1,2,3,],["IN","P_UP","P_DOWN"],node_ordering=[OUT1_,OUT2_,OUT3_,OUT4_,OUT5_,OUT6_,],function_name="special_2d_normalizer_extend_indices")

del IN,P_UP,P_DOWN,OUT1,OUT2,OUT3,OUT4,OUT5,OUT6,IN1_,IN2_,P_UP_,P_DOWN_,OUT1_,OUT2_,OUT3_,OUT4_,OUT5_,OUT6_,g
@c

</t>
<t tx="cog.20080210171852.99">def absorb_site(self,direction):
    if direction == RIGHT:
        self.right_boundary = self.left_multiply(
            self.up_boundary,
            self.down_boundary,
            self.right_boundary,
            self.system.site_matrix,
        )
    elif direction == LEFT:
        self.left_boundary = self.right_multiply(
            self.up_boundary,
            self.left_boundary,
            self.down_boundary,
            self.system.site_matrix,
        )
    else:
        raise RuntimeError("direction must either be LEFT (%i) or RIGHT (%i), instead was %i" % (LEFT,RIGHT,direction))

</t>
<t tx="cog.20080210171852.100">def absorb_row(self,direction):
    @others

    if direction == UP:        
        U, L, D, R = self.get_infinite_limit_boundary()

@
        U = self.up_boundary
        L = self.left_boundary
        D = self.down_boundary
        R = self.right_boundary
@c

        newD = D

        newU = self.absorb_up(U,self.system.site_matrix).reshape(
            self.up_boundary.shape[0]*self.system.site_matrix.shape[2]**2,
            self.up_boundary.shape[1]*self.system.site_matrix.shape[4]**2,
            self.system.site_matrix.shape[3],
            self.system.site_matrix.shape[3],
        )

        newL = L.reshape((1,1,newU.shape[0],newD.shape[0]))

        newR = R.reshape((1,1,newU.shape[0],newD.shape[0]))

        if newU.shape[1] &gt; 16 or True:
            newU, X = reduce_dimension(newU,1,newU.shape[1]-1)
            newU = multiply_tensor_by_matrix_at_index(newU,X.transpose(),0)
            newL = multiply_tensor_by_matrix_at_index(newL,X.transpose().conj(),2)
            newR = multiply_tensor_by_matrix_at_index(newR,X.transpose(),2)
        else:
            X = identity(newU.shape[0])

        self.up_boundary = newU
        self.left_boundary = newL
        self.down_boundary = newD
        self.right_boundary = newR

        self.update_multiplication_functions()

        return newL, newR, X

    elif direction == DOWN:        
        U, L, D, R = self.get_infinite_limit_boundary()

@
        U = self.up_boundary
        L = self.left_boundary
        D = self.down_boundary
        R = self.right_boundary
@c

        newU = U

        newD = self.absorb_down(D,self.system.site_matrix).reshape(
            self.down_boundary.shape[0]*self.system.site_matrix.shape[2]**2,
            self.down_boundary.shape[1]*self.system.site_matrix.shape[4]**2,
            self.system.site_matrix.shape[1],
            self.system.site_matrix.shape[1],
        )

        newL = L.reshape((1,1,newU.shape[0],newD.shape[0]))

        newR = R.reshape((1,1,newU.shape[0],newD.shape[0]))

        if newD.shape[1] &gt; 16 or True:
            newD, X = reduce_dimension(newD,1,newD.shape[1]-1)
            newD = multiply_tensor_by_matrix_at_index(newD,X.transpose(),0)
            newL = multiply_tensor_by_matrix_at_index(newL,X.transpose().conj(),3)
            newR = multiply_tensor_by_matrix_at_index(newR,X.transpose(),3)
        else:
            X = identity(newD.shape[0])

        self.up_boundary = newU
        self.left_boundary = newL
        self.down_boundary = newD
        self.right_boundary = newR

        self.update_multiplication_functions()

        return newL, newR, X

    else:
        raise RuntimeError("only up/down direction supported")
</t>
<t tx="cog.20080210171852.101">def reduce_dimension(matrix,index,new_dimension):
    new_indices = range(matrix.ndim)
    del new_indices[index]
    new_indices.append(index)

    old_shape = list(matrix.shape)
    del old_shape[index]
    new_shape = (prod(old_shape),matrix.shape[index])
    old_shape.append(new_dimension)

    new_matrix = matrix.transpose(new_indices).reshape(new_shape)

    u, s, v = svd(new_matrix,full_matrices=0)

    old_indices = range(matrix.ndim-1)
    old_indices.insert(index,matrix.ndim-1)

    new_u = u[:,:new_dimension]
    new_s = s[:new_dimension]
    new_v = v[:new_dimension,:]

    return (new_s*new_u).reshape(old_shape).transpose(old_indices), new_v

</t>
<t tx="cog.20080210171852.102">def absorb_unitary(self,unitary):

    self.left_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary,0)
    self.left_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary.conj(),1)
    self.right_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary.conj(),0)
    self.right_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary,1)

@
    self.up_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary,2)
    self.up_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary.conj(),3)
    self.down_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary.conj(),2)
    self.down_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary,3)
@c

    self.update_multiplication_functions()

</t>
<t tx="cog.20080210171852.103">def replace_boundaries_with(self,left_boundary,right_boundary):
    self.left_boundary = left_boundary
    self.right_boundary = right_boundary
</t>
<t tx="cog.20080210171852.104">class SpinCouplingTerm:
    @others
</t>
<t tx="cog.20080210171852.105">def __init__(self,system,lam):
    self.system = system
    self.lam = lam
    self.number_of_sites_absorbed_left = 0
    self.number_of_sites_absorbed_right = 0
    self.left_site = None
    self.right_site = None

    I = identity(2)
    X = array([[0,1],[1,0]])

    &lt;&lt; One site boundary &gt;&gt;

    multi_site_down_boundary = zeros((2,2,2))
    multi_site_down_boundary[0,0,0] = 1
    multi_site_down_boundary[0,1,1] = 1
    multi_site_down_boundary[1,1,0] = 1

    &lt;&lt; Two site boundary &gt;&gt;

    self.left_boundary = [None,None]
    self.left_boundary[0] = reduce(outer_product,[
        system.initial_left_site_boundary,
        system.initial_left_site_boundary.conj(),
        ones((1,)),
        array([1,0]),
    ])
    self.left_boundary[1] = self.left_boundary[0].copy()

    self.right_boundary = [None,None]
    self.right_boundary[0] = reduce(outer_product,[
        system.initial_right_site_boundary,
        system.initial_right_site_boundary.conj(),
        ones((1,)),
        array([0,1]),
    ])
    self.right_boundary[1] = self.right_boundary[0].copy()

    self.update_multiplication_functions()


</t>
<t tx="cog.20080210171852.106">self.one_site_up_boundary = reduce(outer_product,[
    ones((1,1)),
    system.initial_up_site_boundary,
    system.initial_up_site_boundary.conj(),
])

self.one_site_down_boundary = reduce(outer_product,[
    identity(2),
    system.initial_down_site_boundary,
    system.initial_down_site_boundary.conj(),
])
</t>
<t tx="cog.20080210171852.107">self.up_boundary = reduce(outer_product,[
    ones((1,)),
    ones((1,)),
    array([1,0]),
    system.initial_up_site_boundary,
    system.initial_up_site_boundary.conj(),
    system.initial_up_site_boundary,
    system.initial_up_site_boundary.conj(),
])

two_site_operator_matrix_A = zeros((2,2,2,)+(2,2))
two_site_operator_matrix_A[0,0,0] = I
two_site_operator_matrix_A[0,1,1] = -lam*X
two_site_operator_matrix_A[1,1,0] = I

two_site_operator_matrix_B = zeros((2,)+(2,2))
two_site_operator_matrix_B[0] = I
two_site_operator_matrix_B[1] = X

self.lamXX = multiply.outer(-lam*X,X)

self.operator_matrix_1 = two_site_operator_matrix_A
self.operator_matrix_2 = two_site_operator_matrix_B

self.down_boundary = reduce(outer_product,[
    multi_site_down_boundary,
    system.initial_down_site_boundary,
    system.initial_down_site_boundary.conj(),
    system.initial_down_site_boundary,
    system.initial_down_site_boundary.conj(),
])
</t>
<t tx="cog.20080210171852.108">def get_optimization_matrix(self):
    optimization_matrix_shape = self.system.shape_of_site_matrix*2
    optimization_matrix = zeros(optimization_matrix_shape,complex128)
    U = self.up_boundary
    D = self.down_boundary
    O1 = self.operator_matrix_1
    O2 = self.operator_matrix_2

    fns = []

    if self.left_site is not None:
        A = self.left_site
        L_AB = self.left_boundary[(self.number_of_sites_absorbed_left-1)%2]
        R_AB = self.right_boundary[(self.number_of_sites_absorbed_right)%2]
        optimization_matrix += self.compute_optimization_matrix_AB(U,L_AB,D,R_AB,O1,O2,A)

    if self.right_site is not None:
        C = self.right_site
        L_BC = self.left_boundary[(self.number_of_sites_absorbed_left)%2]
        R_BC = self.right_boundary[(self.number_of_sites_absorbed_right-1)%2]
        optimization_matrix += self.compute_optimization_matrix_BC(U,L_BC,D,R_BC,O1,O2,C)

    return optimization_matrix.reshape((prod(self.system.shape_of_site_matrix),)*2)
</t>
<t tx="cog.20080210171852.109">def get_matvec(self):
    U = self.up_boundary
    D = self.down_boundary
    O1 = self.operator_matrix_1
    O2 = self.operator_matrix_2

    fns = []

    if self.left_site is not None:
        A = self.left_site
        L_AB = self.left_boundary[(self.number_of_sites_absorbed_left-1)%2]
        R_AB = self.right_boundary[(self.number_of_sites_absorbed_right)%2]
        fns.append(lambda B1: self.matvec_AB(U,L_AB,D,R_AB,O1,O2,A,B1))

    if self.right_site is not None:
        C = self.right_site
        L_BC = self.left_boundary[(self.number_of_sites_absorbed_left)%2]
        R_BC = self.right_boundary[(self.number_of_sites_absorbed_right-1)%2]
        fns.append(lambda B2: self.matvec_BC(U,L_BC,D,R_BC,O1,O2,B2,C))

    if len(fns) == 0:
        return None
    elif len(fns) == 1:
        return fns[0]
    else:
        assert len(fns) == 2
        return lambda B: fns[0](B) + fns[1](B)
</t>
<t tx="cog.20080210171852.110">def get_matvec(self):
    O = self.get_optimization_matrix()
    return lambda A: dot(O,A.ravel())
</t>
<t tx="cog.20080210171852.111">def get_expectation_value(self):
    U = self.up_boundary
    D = self.down_boundary
    O1 = self.operator_matrix_1
    O2 = self.operator_matrix_2

    value = 0

    B = self.system.site_matrix

    if self.left_site is not None:
        A = self.left_site
        L = self.left_boundary[(self.number_of_sites_absorbed_left-1)%2]
        R = self.right_boundary[(self.number_of_sites_absorbed_right)%2]
        value += self.expectation_value(U,L,D,R,O1,O2,A,B)

    if self.right_site is not None:
        C = self.right_site
        L = self.left_boundary[(self.number_of_sites_absorbed_left)%2]
        R = self.right_boundary[(self.number_of_sites_absorbed_right-1)%2]
        value += self.expectation_value(U,L,D,R,O1,O2,B,C)

    return value

</t>
<t tx="cog.20080210171852.112">def get_energy_per_term(self,up_boundary,left_boundary,down_boundary,right_boundary):
    g = Graph()

    U1_ = g.add_node(up_boundary)
    U2_ = g.add_node(up_boundary)
    L_ = g.add_node(left_boundary)
    D1_ = g.add_node(down_boundary)
    D2_ = g.add_node(down_boundary)
    R_ = g.add_node(right_boundary)
    O_ = g.add_node(self.lamXX)
    S1_ = g.add_node(self.system.site_matrix)
    s1_ = g.add_node(self.system.site_matrix.conj())
    S2_ = g.add_node(self.system.site_matrix)
    s2_ = g.add_node(self.system.site_matrix.conj())

    g.connect(L_,0,S1_,2)
    g.connect(L_,1,s1_,2)
    g.connect(L_,2,U1_,0)
    g.connect(L_,3,D1_,0)

    g.connect(R_,0,S2_,4)
    g.connect(R_,1,s2_,4)
    g.connect(R_,2,U2_,1)
    g.connect(R_,3,D2_,1)

    g.connect(U1_,1,U2_,0)
    g.connect(U1_,2,S1_,1)
    g.connect(U1_,3,s1_,1)
    g.connect(U2_,2,S2_,1)
    g.connect(U2_,3,s2_,1)

    g.connect(D1_,1,D2_,0)
    g.connect(D1_,2,S1_,3)
    g.connect(D1_,3,s1_,3)
    g.connect(D2_,2,S2_,3)
    g.connect(D2_,3,s2_,3)

    g.connect(O_,0,S1_,0)
    g.connect(O_,1,s1_,0)
    g.connect(O_,2,S2_,0)
    g.connect(O_,3,s2_,0)

    g.connect(S1_,4,S2_,2)
    g.connect(s1_,4,s2_,2)

    s = Subgraph(g)
    for i in g.nodes.keys():
        s.add_node(i)

    expectation = abs(s.merge_all().matrices[0])

    s = Subgraph(g)
    for i in g.nodes.keys():
        if i == O_:
            s.add_node(O_,outer_product(*[identity(2)]*2))
        else:
            s.add_node(i)

    normalization = abs(s.merge_all().matrices[0])

    return expectation/normalization
</t>
<t tx="cog.20080210171852.113">def update_multiplication_functions(self,horizontal_boundary_shape=None):
    if horizontal_boundary_shape is None:
        horizontal_boundary_shape = self.left_boundary[0].shape
    @others
</t>
<t tx="cog.20080210171852.114">g = Graph()

@
Note:

These dimensions are not the actual dimensions;  they are random prime numbers.

This is done so that index checking can be performed (i.e., to make sure that I've
connected all of the indices properly).  The function that is produced at the end
of the day will not depend on these dimensions at all.

@c

U = Placeholder("U",ensure_dimensions_greater_than_one(self.one_site_up_boundary.shape))
L = Placeholder("L",ensure_dimensions_greater_than_one(horizontal_boundary_shape))
D = Placeholder("D",ensure_dimensions_greater_than_one(self.one_site_down_boundary.shape))
R = Placeholder("R",ensure_dimensions_greater_than_one(horizontal_boundary_shape))
A = Placeholder("A",ensure_dimensions_greater_than_one(self.system.shape_of_site_matrix))

U_ = g.add_node(U)        #0
L_ = g.add_node(L)        #1
D_ = g.add_node(D)        #2
R_ = g.add_node(R)        #3
A_ = g.add_node(A)        #4
a_ = g.add_node(A.conj()) #5

# L tensor
g.connect(L_,0,A_,2)
g.connect(L_,1,a_,2)
g.connect(L_,2,U_,0)
g.connect(L_,3,D_,0)

# R tensor
g.connect(R_,0,A_,4)
g.connect(R_,1,a_,4)
g.connect(R_,2,U_,1)
g.connect(R_,3,D_,1)

# U tensor
g.connect(U_,2,A_,1)
g.connect(U_,3,a_,1)

# D tensor
g.connect(D_,2,A_,3)
g.connect(D_,3,a_,3)

# A tensor, A* tensor
g.connect(A_,0,a_,0)

node_ids = {}
for name in ["U","L","D","R","A"]:
    node_ids[name] = vars()[name+"_"]

for name, variables, other_nodes, ordering in [
    ("absorb_one_site_into_left_boundary", ["U","L","D","A"], [a_], None),
    ("absorb_one_site_into_right_boundary", ["U","D","R","A"], [a_], None),
    ("absorb_one_site_up", ["U", "A"], [a_], [L_, R_, D_]),
    ("absorb_one_site_down", ["D", "A"], [a_], [L_, R_, U_]),
    ]:
        setattr(self,name,compile_graph(
            g,
            [node_ids[name] for name in variables] + other_nodes,
            variables,
            node_ordering=ordering,
            function_name=name
            )
        )

del g

del U,L,D,R,A,U_,L_,D_,R_,A_,a_

</t>
<t tx="cog.20080210171852.115">g = Graph()

@
Note:

These dimensions are not the actual dimensions;  they are random prime numbers.

This is done so that index checking can be performed (i.e., to make sure that I've
connected all of the indices properly).  The function that is produced at the end
of the day will not depend on these dimensions at all.

@c

@
U = Placeholder("U",(6,3,7,5,5,5,5))
L = Placeholder("L",(6,8,5,5))
D = Placeholder("D",(3,8,9,5,5,5,5))
R = Placeholder("R",(7,9,5,5))
O = Placeholder("O",(3,3,2,2,2,2))
A = Placeholder("A",(2,5,5,5,5))
B = Placeholder("B",(2,5,5,5,5))
@c

U = Placeholder("U",ensure_dimensions_greater_than_one(self.up_boundary.shape))
L = Placeholder("L",ensure_dimensions_greater_than_one(horizontal_boundary_shape))
D = Placeholder("D",ensure_dimensions_greater_than_one(self.down_boundary.shape))
R = Placeholder("R",ensure_dimensions_greater_than_one(horizontal_boundary_shape))
OA = Placeholder("OA",ensure_dimensions_greater_than_one(self.operator_matrix_1.shape))
OB = Placeholder("OB",ensure_dimensions_greater_than_one(self.operator_matrix_2.shape))
A = Placeholder("A",ensure_dimensions_greater_than_one(self.system.shape_of_site_matrix))
B = Placeholder("B",ensure_dimensions_greater_than_one(self.system.shape_of_site_matrix))

U_ = g.add_node(U)
L_ = g.add_node(L)
D_ = g.add_node(D)
R_ = g.add_node(R)
OA_= g.add_node(OA)
OB_= g.add_node(OB)
A_ = g.add_node(A)
a_ = g.add_node(A.conj())
B_ = g.add_node(B)
b_ = g.add_node(B.conj())

# L tensor
g.connect(L_,0,A_,2)
g.connect(L_,1,a_,2)
g.connect(L_,2,U_,0)
g.connect(L_,3,D_,0)

# R tensor
g.connect(R_,0,B_,4)
g.connect(R_,1,b_,4)
g.connect(R_,2,U_,1)
g.connect(R_,3,D_,1)

# U tensor
g.connect(U_,2,OA_,0)
g.connect(U_,3,A_,1)
g.connect(U_,4,a_,1)
g.connect(U_,5,B_,1)
g.connect(U_,6,b_,1)

# D tensor
g.connect(D_,2,OA_,1)
g.connect(D_,3,A_,3)
g.connect(D_,4,a_,3)
g.connect(D_,5,B_,3)
g.connect(D_,6,b_,3)

# O tensor
g.connect(OA_,3,A_,0)
g.connect(OA_,4,a_,0)
g.connect(OB_,1,B_,0)
g.connect(OB_,2,b_,0)
g.connect(OA_,2,OB_,0)

# A tensor, A* tensor
g.connect(A_,4,B_,2)
g.connect(a_,4,b_,2)

node_ids = {}
for name in ["U","L","D","R","OA","OB","A","B"]:
    node_ids[name] = vars()[name+"_"]

for name, variables, other_nodes, ordering in [
    ("matvec_AB", ["U","L","D","R","OA","OB","A","B"], [a_], None),
    ("matvec_BC", ["U","L","D","R","OA","OB","A","B"], [b_], None),
    ("compute_optimization_matrix_AB", ["U","L","D","R","OA","OB","A"], [a_], [b_,B_]),
    ("compute_optimization_matrix_BC", ["U","L","D","R","OA","OB","B"], [b_], [a_,A_]),
    ("absorb_two_sites_into_left_boundary", ["U","L","D","OA","OB","A","B"], [a_,b_], None),
    ("absorb_two_sites_into_right_boundary", ["U","D","R","OA","OB","A","B"], [a_,b_], None),
    ("absorb_two_sites_up", ["U", "OA", "OB", "A", "B"], [a_, b_], [L_, R_, D_]),
    ("absorb_two_sites_down", ["D", "OA", "OB", "A", "B"], [a_, b_], [L_, R_, U_]),
    ]:
        setattr(self,name,compile_graph(
            g,
            [node_ids[name] for name in variables] + other_nodes,
            variables,
            node_ordering=ordering,
            function_name=name
            )
        )

s = Subgraph(g)
for i in xrange(len(g.nodes)):
    s.add_node(i)
self.expectation_value = s.merge_all().matrices[0].compile_with_name("expectation_value","U","L","D","R","OA","OB","A","B")

del s, g, i

del U,L,D,R,A,U_,L_,D_,R_,A_,a_,B_,b_

</t>
<t tx="cog.20080210171852.116">def absorb_row(self,direction,normalizer_left_boundary,normalizer_right_boundary,X):
    if direction == UP:

        self.up_boundary = self.absorb_two_sites_up(
            self.up_boundary,
            self.operator_matrix_1,
            self.operator_matrix_2,
            self.system.site_matrix,
            self.system.site_matrix,
        ).reshape(
            self.up_boundary.shape[0]*self.system.site_matrix.shape[2]**2,
            self.up_boundary.shape[1]*self.system.site_matrix.shape[4]**2,
            self.operator_matrix_1.shape[0],
            self.system.site_matrix.shape[3],
            self.system.site_matrix.shape[3],
            self.system.site_matrix.shape[3],
            self.system.site_matrix.shape[3],
        )

        self.up_boundary = multiply_tensor_by_matrix_at_index(self.up_boundary,X.transpose(),0)
        self.up_boundary = multiply_tensor_by_matrix_at_index(self.up_boundary,X.conj().transpose(),1)

        self.one_site_up_boundary = self.absorb_one_site_up(
            self.one_site_up_boundary,
            self.system.site_matrix
        ).reshape(
            self.one_site_up_boundary.shape[0]*self.system.site_matrix.shape[2]**2,
            self.one_site_up_boundary.shape[1]*self.system.site_matrix.shape[4]**2,
            self.system.site_matrix.shape[3],
            self.system.site_matrix.shape[3],
        )

        self.one_site_up_boundary = multiply_tensor_by_matrix_at_index(self.one_site_up_boundary,X.transpose(),0)
        self.one_site_up_boundary = multiply_tensor_by_matrix_at_index(self.one_site_up_boundary,X.conj().transpose(),1)

        self.replace_boundaries_with(normalizer_left_boundary,normalizer_right_boundary)

        self.update_multiplication_functions()

    else:

        assert direction == DOWN

        D = self.down_boundary.shape[0]*self.system.site_matrix.shape[2]**2
        #D2 = self.down_boundary.shape[1]*self.system.site_matrix.shape[4]**2

        self.down_boundary = self.absorb_two_sites_down(
            self.down_boundary,
            self.operator_matrix_1,
            self.operator_matrix_2,
            self.system.site_matrix,
            self.system.site_matrix,
        ).reshape(
            D/2,
            2,
            D/2,
            2,
            self.operator_matrix_1.shape[0],
            self.system.site_matrix.shape[1],
            self.system.site_matrix.shape[1],
            self.system.site_matrix.shape[1],
            self.system.site_matrix.shape[1],
        )

        self.down_boundary = multiply_tensor_by_matrix_at_index(self.down_boundary,X.transpose(),0)
        self.down_boundary = multiply_tensor_by_matrix_at_index(self.down_boundary,X.conj().transpose(),2)

        self.down_boundary = self.down_boundary.reshape(
            self.down_boundary.shape[0]*self.down_boundary.shape[1],
            self.down_boundary.shape[2]*self.down_boundary.shape[3],
            self.operator_matrix_1.shape[0],
            self.system.site_matrix.shape[1],
            self.system.site_matrix.shape[1],
            self.system.site_matrix.shape[1],
            self.system.site_matrix.shape[1],
        )

        D = self.one_site_down_boundary.shape[0]*self.system.site_matrix.shape[2]**2
        #D2 = self.one_site_down_boundary.shape[1]*self.system.site_matrix.shape[4]**2

        self.one_site_down_boundary = self.absorb_one_site_down(
            self.one_site_down_boundary,
            self.system.site_matrix
        ).reshape(
            D/2,
            2,
            D/2,
            2,
            self.system.site_matrix.shape[1],
            self.system.site_matrix.shape[1],
        )

        self.one_site_down_boundary = multiply_tensor_by_matrix_at_index(self.one_site_down_boundary,X.transpose(),0)
        self.one_site_down_boundary = multiply_tensor_by_matrix_at_index(self.one_site_down_boundary,X.conj().transpose(),2)

        self.one_site_down_boundary = self.one_site_down_boundary.reshape(
            self.one_site_down_boundary.shape[0]*self.one_site_down_boundary.shape[1],
            self.one_site_down_boundary.shape[2]*self.one_site_down_boundary.shape[3],
            self.system.site_matrix.shape[1],
            self.system.site_matrix.shape[1],
        )

        self.replace_boundaries_with(normalizer_left_boundary,normalizer_right_boundary)

        self.update_multiplication_functions()

</t>
<t tx="cog.20080210171852.117">def absorb_site(self,direction):
    assert direction == LEFT or direction == RIGHT
    if direction == LEFT:
        self.number_of_sites_absorbed_left += 1       
        if self.left_site is not None:
            self.left_boundary[self.number_of_sites_absorbed_left%2] = \
                self.absorb_two_sites_into_left_boundary(
                    self.up_boundary,
                    self.left_boundary[self.number_of_sites_absorbed_left%2],
                    self.down_boundary,
                    self.operator_matrix_1,
                    self.operator_matrix_2,
                    self.left_site,
                    self.system.site_matrix
                    )
        else:
            self.left_boundary[1] = \
                self.absorb_one_site_into_left_boundary(
                    self.one_site_up_boundary,
                    self.left_boundary[1],
                    self.one_site_down_boundary,
                    self.system.site_matrix
                    )     
        self.left_site = self.system.site_matrix
    else:
        self.number_of_sites_absorbed_right += 1
        if self.right_site is not None:
            self.right_boundary[self.number_of_sites_absorbed_right%2] = \
                self.absorb_two_sites_into_right_boundary(
                    self.up_boundary,
                    self.down_boundary,
                    self.right_boundary[self.number_of_sites_absorbed_right%2],
                    self.operator_matrix_1,
                    self.operator_matrix_2,
                    self.system.site_matrix,
                    self.right_site,
                    )
        else:
            self.right_boundary[1] = \
                self.absorb_one_site_into_right_boundary(
                    self.one_site_up_boundary,
                    self.one_site_down_boundary,
                    self.right_boundary[1],
                    self.system.site_matrix
                    )    
        self.right_site = self.system.site_matrix
</t>
<t tx="cog.20080210171852.118">def absorb_unitary(self,unitary):
    if self.left_site is not None:
        self.left_site = multiply_tensor_by_matrix_at_index(self.left_site,unitary,4)
        i = self.number_of_sites_absorbed_left%2
        self.left_boundary[i] = multiply_tensor_by_matrix_at_index(self.left_boundary[i],unitary,0)
        self.left_boundary[i] = multiply_tensor_by_matrix_at_index(self.left_boundary[i],unitary.conj(),1)
    else:
        for i in (0,1):
            self.left_boundary[i] = multiply_tensor_by_matrix_at_index(self.left_boundary[i],unitary,0)
            self.left_boundary[i] = multiply_tensor_by_matrix_at_index(self.left_boundary[i],unitary.conj(),1)

    if self.right_site is not None:
        self.right_site = multiply_tensor_by_matrix_at_index(self.right_site,unitary.conj(),2)
        i = self.number_of_sites_absorbed_right%2
        self.right_boundary[i] = multiply_tensor_by_matrix_at_index(self.right_boundary[i],unitary.conj(),0)
        self.right_boundary[i] = multiply_tensor_by_matrix_at_index(self.right_boundary[i],unitary,1)
    else:
        for i in (0,1):
            self.right_boundary[i] = multiply_tensor_by_matrix_at_index(self.right_boundary[i],unitary,0)
            self.right_boundary[i] = multiply_tensor_by_matrix_at_index(self.right_boundary[i],unitary.conj(),1)

    horizontal_boundary_shape = list(self.left_boundary[0].shape)
    horizontal_boundary_shape[0] = horizontal_boundary_shape[1] = self.system.shape_of_site_matrix[2]
    self.update_multiplication_functions(tuple(horizontal_boundary_shape))
</t>
<t tx="cog.20080210171852.119">def replace_boundaries_with(self,normalizer_left_boundary,normalizer_right_boundary):
    self.number_of_left_sites_absorbed = 0
    self.number_of_right_sites_absorbed = 0
    self.left_site = None
    self.right_site = None

    horizontal_boundary_shape = copy(normalizer_left_boundary.shape)
    horizontal_boundary_shape[-1] *= 2

    for i in (0,1):
        self.left_boundary[i] = multiply.outer(normalizer_left_boundary,array([1,0])).reshape(horizontal_boundary_shape)
        self.right_boundary[i] = multiply.outer(normalizer_right_boundary,array([0,1])).reshape(horizontal_boundary_shape)
</t>
<t tx="cog.20080210171852.120">class OldSpinCouplingTerm:
    @others
</t>
<t tx="cog.20080210171852.121">def __init__(self,system,lam,ignore_first_left=False,ignore_first_right=False,ignore_first_two_matvecs=False):
    self.system = system
    self.lam = lam
    self.number_of_active_sites = 1
    self.ignore_first_left = ignore_first_left
    self.ignore_next_left_absorb = ignore_first_left
    self.ignore_first_right = ignore_first_right
    self.ignore_next_right_absorb = ignore_first_right
    self.ignore_first_two_matvecs = ignore_first_two_matvecs
    self.matvecs_to_ignore = 2 if ignore_first_two_matvecs else 0

    I = identity(2)
    X = array([[0,1],[1,0]])

    &lt;&lt; One site boundary &gt;&gt;

    multi_site_down_boundary = zeros((2,2,2))
    multi_site_down_boundary[0,0,0] = 1
    multi_site_down_boundary[0,1,1] = 1
    multi_site_down_boundary[1,1,0] = 1

    &lt;&lt; Two site boundary &gt;&gt;
    &lt;&lt; Three site boundary &gt;&gt;

    self.left_boundary = reduce(outer_product,[
        system.initial_left_site_boundary,
        system.initial_left_site_boundary.conj(),
        ones((1,)),
        array([1,0]),
    ])

    self.right_boundary = reduce(outer_product,[
        system.initial_right_site_boundary,
        system.initial_right_site_boundary.conj(),
        ones((1,)),
        array([0,1]),
    ])

    self.update_multiplication_functions()


</t>
<t tx="cog.20080210171852.122">self.one_site_up_boundary = reduce(outer_product,[
    ones((1,1)),
    system.initial_up_site_boundary,
    system.initial_up_site_boundary.conj(),
])

self.one_site_down_boundary = reduce(outer_product,[
    identity(2),
    system.initial_down_site_boundary,
    system.initial_down_site_boundary.conj(),
])
</t>
<t tx="cog.20080210171852.123">self.two_site_up_boundary = reduce(outer_product,[
    ones((1,)),
    ones((1,)),
    array([1,0]),
    system.initial_up_site_boundary,
    system.initial_up_site_boundary.conj(),
    system.initial_up_site_boundary,
    system.initial_up_site_boundary.conj(),
])

#II = reduce(outer_product,[identity(2)]*2)
#XX = reduce(outer_product,[array([[0,1],[1,0]])]*2)

two_site_operator_matrix_A = zeros((2,2,2,)+(2,2))
two_site_operator_matrix_A[0,0,0] = I
two_site_operator_matrix_A[0,1,1] = -lam*X
two_site_operator_matrix_A[1,1,0] = I

two_site_operator_matrix_B = zeros((2,)+(2,2))
two_site_operator_matrix_B[0] = I
two_site_operator_matrix_B[1] = X

self.lamXX = multiply.outer(-lam*X,X)

self.two_site_operator_A = two_site_operator_matrix_A
self.two_site_operator_B = two_site_operator_matrix_B

self.two_site_down_boundary = reduce(outer_product,[
    multi_site_down_boundary,
    system.initial_down_site_boundary,
    system.initial_down_site_boundary.conj(),
    system.initial_down_site_boundary,
    system.initial_down_site_boundary.conj(),
])
</t>
<t tx="cog.20080210171852.124">self.three_site_up_boundary = reduce(outer_product,[
    ones((1,)),
    ones((1,)),
    array([1,0]),
    system.initial_up_site_boundary,
    system.initial_up_site_boundary.conj(),
    system.initial_up_site_boundary,
    system.initial_up_site_boundary.conj(),
    system.initial_up_site_boundary,
    system.initial_up_site_boundary.conj(),
])

@
III = reduce(outer_product,[identity(2)]*3)
XX = reduce(outer_product,[array([[0,1],[1,0]])]*2)

IXX = outer_product(identity(2),XX)
XXI = outer_product(XX,identity(2))

three_site_operator_matrix = zeros((2,2,2,2,2,2,2,2))
three_site_operator_matrix[0,0] = III
three_site_operator_matrix[0,1] = -lam*(XXI+IXX)
three_site_operator_matrix[1,1] = III
@c

three_site_operator_matrix_A = zeros((2,2,3,)+(2,2))
three_site_operator_matrix_A[0,0,0] = I
three_site_operator_matrix_A[0,1,1] = -lam*X
three_site_operator_matrix_A[0,1,2] = I
three_site_operator_matrix_A[1,1,0] = I

three_site_operator_matrix_B = zeros((3,2,)+(2,2))
three_site_operator_matrix_B[0,0] = I
three_site_operator_matrix_B[1,0] = X
three_site_operator_matrix_B[2,1] = -lam*X

three_site_operator_matrix_C = zeros((2,)+(2,2))
three_site_operator_matrix_C[0] = I
three_site_operator_matrix_C[1] = X

self.three_site_operator_A = three_site_operator_matrix_A
self.three_site_operator_B = three_site_operator_matrix_B
self.three_site_operator_C = three_site_operator_matrix_C

self.three_site_down_boundary = reduce(outer_product,[
    multi_site_down_boundary,
    system.initial_down_site_boundary,
    system.initial_down_site_boundary.conj(),
    system.initial_down_site_boundary,
    system.initial_down_site_boundary.conj(),
    system.initial_down_site_boundary,
    system.initial_down_site_boundary.conj(),
])
</t>
<t tx="cog.20080210171852.125">def get_matvec(self):
    if self.matvecs_to_ignore &gt; 0:
        return None
    L = self.left_boundary
    R = self.right_boundary
    if self.number_of_active_sites == 1:
        return None
        U = self.one_site_up_boundary
        D = self.one_site_down_boundary
        return lambda A: self.one_site_matvec(U,L,D,R,A)
    elif self.number_of_active_sites == 2:
        U = self.two_site_up_boundary
        D = self.two_site_down_boundary
        OA = self.two_site_operator_A
        OB = self.two_site_operator_B
        if self.A is None:
            B = self.B
            assert B is not None
            return lambda A: self.two_site_matvec_A(U,L,D,R,OA,OB,A,B)
        else:
            A = self.A
            assert A is not None
            return lambda B: self.two_site_matvec_B(U,L,D,R,OA,OB,A,B)
    elif self.number_of_active_sites == 3:
        return None
        U = self.three_site_up_boundary
        D = self.three_site_down_boundary
        OA = self.three_site_operator_A
        OB = self.three_site_operator_B
        OC = self.three_site_operator_C
        assert self.A is not None
        assert self.B is None
        assert self.C is not None

        A = self.A
        C = self.C

        return lambda B: self.three_site_matvec_B(U,L,D,R,OA,OB,OC,A,B,C)
    else:
        raise RuntimeError("shouldn't ever get here (self.number_of_active_sites=%i" % self.number_of_active_sites)
</t>
<t tx="cog.20080210171852.126">def get_expectation_value(self):
    if self.matvecs_to_ignore &gt; 0:
        return 0
    if self.number_of_active_sites == 1:
        return 0
        return self.one_site_expectation_value(
            self.one_site_up_boundary,
            self.left_boundary,
            self.one_site_down_boundary,
            self.right_boundary,
            self.system.site_matrix,
            )
    elif self.number_of_active_sites == 2:
        if self.A is None:
            assert self.B is not None
            return self.two_site_expectation_value(
                self.two_site_up_boundary,
                self.left_boundary,
                self.two_site_down_boundary,
                self.right_boundary,
                self.two_site_operator_A,
                self.two_site_operator_B,
                self.system.site_matrix,
                self.B,
                )
        else:
            assert self.A is not None
            return self.two_site_expectation_value(
                self.two_site_up_boundary,
                self.left_boundary,
                self.two_site_down_boundary,
                self.right_boundary,
                self.two_site_operator_A,
                self.two_site_operator_B,
                self.A,
                self.system.site_matrix,
                )
    else:
        return 0
        assert self.number_of_active_sites == 3
        assert self.A is not None
        assert self.B is None
        assert self.C is not None
        return self.three_site_expectation_value(
            self.three_site_up_boundary,
            self.left_boundary,
            self.three_site_down_boundary,
            self.right_boundary,
            self.three_site_operator_A,
            self.three_site_operator_B,
            self.three_site_operator_C,
            self.A,
            self.system.site_matrix,
            self.C,
            )

</t>
<t tx="cog.20080210171852.127">def get_energy_per_term(self,up_boundary,left_boundary,down_boundary,right_boundary):
    if self.matvecs_to_ignore &gt; 0 or self.number_of_active_sites % 2 == 1:
        return 0

    g = Graph()

    U1_ = g.add_node(up_boundary)
    U2_ = g.add_node(up_boundary)
    L_ = g.add_node(left_boundary)
    D1_ = g.add_node(down_boundary)
    D2_ = g.add_node(down_boundary)
    R_ = g.add_node(right_boundary)
    O_ = g.add_node(self.lamXX/2)
    S1_ = g.add_node(self.system.site_matrix)
    s1_ = g.add_node(self.system.site_matrix.conj())
    S2_ = g.add_node(self.system.site_matrix)
    s2_ = g.add_node(self.system.site_matrix.conj())

    g.connect(L_,0,S1_,2)
    g.connect(L_,1,s1_,2)
    g.connect(L_,2,U1_,0)
    g.connect(L_,3,D1_,0)

    g.connect(R_,0,S2_,4)
    g.connect(R_,1,s2_,4)
    g.connect(R_,2,U2_,1)
    g.connect(R_,3,D2_,1)

    g.connect(U1_,1,U2_,0)
    g.connect(U1_,2,S1_,1)
    g.connect(U1_,3,s1_,1)
    g.connect(U2_,2,S2_,1)
    g.connect(U2_,3,s2_,1)

    g.connect(D1_,1,D2_,0)
    g.connect(D1_,2,S1_,3)
    g.connect(D1_,3,s1_,3)
    g.connect(D2_,2,S2_,3)
    g.connect(D2_,3,s2_,3)

    g.connect(O_,0,S1_,0)
    g.connect(O_,1,s1_,0)
    g.connect(O_,2,S2_,0)
    g.connect(O_,3,s2_,0)

    g.connect(S1_,4,S2_,2)
    g.connect(s1_,4,s2_,2)

    s = Subgraph(g)
    for i in g.nodes.keys():
        s.add_node(i)

    expectation = abs(s.merge_all().matrices[0])

    s = Subgraph(g)
    for i in g.nodes.keys():
        if i == O_:
            s.add_node(O_,outer_product(*[identity(2)]*2))
        else:
            s.add_node(i)

    normalization = abs(s.merge_all().matrices[0])

    return expectation/normalization
</t>
<t tx="cog.20080210171852.128">def update_multiplication_functions(self,horizontal_boundary_shape=None):
    if horizontal_boundary_shape is None:
        horizontal_boundary_shape = self.left_boundary.shape
    @others
</t>
<t tx="cog.20080210171852.129">g = Graph()

@
Note:

These dimensions are not the actual dimensions;  they are random prime numbers.

This is done so that index checking can be performed (i.e., to make sure that I've
connected all of the indices properly).  The function that is produced at the end
of the day will not depend on these dimensions at all.

@c

U = Placeholder("U",ensure_dimensions_greater_than_one(self.one_site_up_boundary.shape))
L = Placeholder("L",ensure_dimensions_greater_than_one(horizontal_boundary_shape))
D = Placeholder("D",ensure_dimensions_greater_than_one(self.one_site_down_boundary.shape))
R = Placeholder("R",ensure_dimensions_greater_than_one(horizontal_boundary_shape))
A = Placeholder("A",ensure_dimensions_greater_than_one(self.system.shape_of_site_matrix))

U_ = g.add_node(U)        #0
L_ = g.add_node(L)        #1
D_ = g.add_node(D)        #2
R_ = g.add_node(R)        #3
A_ = g.add_node(A)        #4
a_ = g.add_node(A.conj()) #5

# L tensor
g.connect(L_,0,A_,2)
g.connect(L_,1,a_,2)
g.connect(L_,2,U_,0)
g.connect(L_,3,D_,0)

# R tensor
g.connect(R_,0,A_,4)
g.connect(R_,1,a_,4)
g.connect(R_,2,U_,1)
g.connect(R_,3,D_,1)

# U tensor
g.connect(U_,2,A_,1)
g.connect(U_,3,a_,1)

# D tensor
g.connect(D_,2,A_,3)
g.connect(D_,3,a_,3)

# A tensor, A* tensor
g.connect(A_,0,a_,0)

node_ids = {}
for name in ["U","L","D","R","A"]:
    node_ids[name] = vars()[name+"_"]

for name, variables, other_nodes, ordering in [
    ("matvec", ["U","L","D","R","A",], [], None),
    ("absorb_into_left_boundary", ["U","L","D","A"], [a_], None),
    ("absorb_into_right_boundary", ["U","D","R","A"], [a_], None),
    ("absorb_up", ["U", "A"], [a_], [L_, R_, D_]),
    ]:
        setattr(self,"one_site_"+name,compile_graph(
            g,
            [node_ids[name] for name in variables] + other_nodes,
            variables,
            node_ordering=ordering,
            function_name=name
            )
        )

s = Subgraph(g)
for i in xrange(len(g.nodes)):
    s.add_node(i)
self.one_site_expectation_value = s.merge_all().matrices[0].compile_with_name("expectation_value","U","L","D","R","A")

del s, g, i

del U,L,D,R,A,U_,L_,D_,R_,A_,a_

</t>
<t tx="cog.20080210171852.130">g = Graph()

@
Note:

These dimensions are not the actual dimensions;  they are random prime numbers.

This is done so that index checking can be performed (i.e., to make sure that I've
connected all of the indices properly).  The function that is produced at the end
of the day will not depend on these dimensions at all.

@c

@
U = Placeholder("U",(6,3,7,5,5,5,5))
L = Placeholder("L",(6,8,5,5))
D = Placeholder("D",(3,8,9,5,5,5,5))
R = Placeholder("R",(7,9,5,5))
O = Placeholder("O",(3,3,2,2,2,2))
A = Placeholder("A",(2,5,5,5,5))
B = Placeholder("B",(2,5,5,5,5))
@c

U = Placeholder("U",ensure_dimensions_greater_than_one(self.two_site_up_boundary.shape))
L = Placeholder("L",ensure_dimensions_greater_than_one(horizontal_boundary_shape))
D = Placeholder("D",ensure_dimensions_greater_than_one(self.two_site_down_boundary.shape))
R = Placeholder("R",ensure_dimensions_greater_than_one(horizontal_boundary_shape))
OA = Placeholder("OA",ensure_dimensions_greater_than_one(self.two_site_operator_A.shape))
OB = Placeholder("OB",ensure_dimensions_greater_than_one(self.two_site_operator_B.shape))
A = Placeholder("A",ensure_dimensions_greater_than_one(self.system.shape_of_site_matrix))
B = Placeholder("B",ensure_dimensions_greater_than_one(self.system.shape_of_site_matrix))

U_ = g.add_node(U)
L_ = g.add_node(L)
D_ = g.add_node(D)
R_ = g.add_node(R)
OA_= g.add_node(OA)
OB_= g.add_node(OB)
A_ = g.add_node(A)
a_ = g.add_node(A.conj())
B_ = g.add_node(B)
b_ = g.add_node(B.conj())

# L tensor
g.connect(L_,0,A_,2)
g.connect(L_,1,a_,2)
g.connect(L_,2,U_,0)
g.connect(L_,3,D_,0)

# R tensor
g.connect(R_,0,B_,4)
g.connect(R_,1,b_,4)
g.connect(R_,2,U_,1)
g.connect(R_,3,D_,1)

# U tensor
g.connect(U_,2,OA_,0)
g.connect(U_,3,A_,1)
g.connect(U_,4,a_,1)
g.connect(U_,5,B_,1)
g.connect(U_,6,b_,1)

# D tensor
g.connect(D_,2,OA_,1)
g.connect(D_,3,A_,3)
g.connect(D_,4,a_,3)
g.connect(D_,5,B_,3)
g.connect(D_,6,b_,3)

# O tensor
g.connect(OA_,3,A_,0)
g.connect(OA_,4,a_,0)
g.connect(OB_,1,B_,0)
g.connect(OB_,2,b_,0)
g.connect(OA_,2,OB_,0)

# A tensor, A* tensor
g.connect(A_,4,B_,2)
g.connect(a_,4,b_,2)

node_ids = {}
for name in ["U","L","D","R","OA","OB","A","B"]:
    node_ids[name] = vars()[name+"_"]

for name, variables, other_nodes, ordering in [
    ("matvec_A", ["U","L","D","R","OA","OB","A","B"], [b_], None),
    ("matvec_B", ["U","L","D","R","OA","OB","A","B"], [a_], None),
    ("absorb_into_left_boundary", ["U","L","D","OA","OB","A","B"], [a_,b_], None),
    ("absorb_into_right_boundary", ["U","D","R","OA","OB","A","B"], [a_,b_], None),
    ("absorb_up", ["U", "OA", "OB", "A", "B"], [a_, b_], [L_, R_, D_]),
    ]:
        setattr(self,"two_site_"+name,compile_graph(
            g,
            [node_ids[name] for name in variables] + other_nodes,
            variables,
            node_ordering=ordering,
            function_name=name
            )
        )

s = Subgraph(g)
for i in xrange(len(g.nodes)):
    s.add_node(i)
self.two_site_expectation_value = s.merge_all().matrices[0].compile_with_name("two_site_expectation_value","U","L","D","R","OA","OB","A","B")

del s, g, i

del U,L,D,R,A,U_,L_,D_,R_,A_,a_,B_,b_

</t>
<t tx="cog.20080210171852.131">g = Graph()

@
Note:

These dimensions are not the actual dimensions;  they are random prime numbers.

This is done so that index checking can be performed (i.e., to make sure that I've
connected all of the indices properly).  The function that is produced at the end
of the day will not depend on these dimensions at all.

@c

@
U = Placeholder("U",(6,3,7,5,5,5,5,5,5))
L = Placeholder("L",(6,8,5,5))
D = Placeholder("D",(3,8,9,5,5,5,5,5,5))
R = Placeholder("R",(7,9,5,5))
O = Placeholder("O",(3,3,2,2,2,2,2,2))
A = Placeholder("A",(2,5,5,5,5))
B = Placeholder("B",(2,5,5,5,5))
C = Placeholder("C",(2,5,5,5,5))
@c

U = Placeholder("U",ensure_dimensions_greater_than_one(self.three_site_up_boundary.shape))
L = Placeholder("L",ensure_dimensions_greater_than_one(horizontal_boundary_shape))
D = Placeholder("D",ensure_dimensions_greater_than_one(self.three_site_down_boundary.shape))
R = Placeholder("R",ensure_dimensions_greater_than_one(horizontal_boundary_shape))
OA = Placeholder("OA",ensure_dimensions_greater_than_one(self.three_site_operator_A.shape))
OB = Placeholder("OB",ensure_dimensions_greater_than_one(self.three_site_operator_B.shape))
OC = Placeholder("OC",ensure_dimensions_greater_than_one(self.three_site_operator_C.shape))
A = Placeholder("A",ensure_dimensions_greater_than_one(self.system.shape_of_site_matrix))
B = Placeholder("B",ensure_dimensions_greater_than_one(self.system.shape_of_site_matrix))
C = Placeholder("C",ensure_dimensions_greater_than_one(self.system.shape_of_site_matrix))

U_ = g.add_node(U)
L_ = g.add_node(L)
D_ = g.add_node(D)
R_ = g.add_node(R)
OA_= g.add_node(OA)
OB_= g.add_node(OB)
OC_= g.add_node(OC)
A_ = g.add_node(A)
a_ = g.add_node(A.conj())
B_ = g.add_node(B)
b_ = g.add_node(B.conj())
C_ = g.add_node(C)
c_ = g.add_node(C.conj())

# L tensor
g.connect(L_,0,A_,2)
g.connect(L_,1,a_,2)
g.connect(L_,2,U_,0)
g.connect(L_,3,D_,0)

# R tensor
g.connect(R_,0,C_,4)
g.connect(R_,1,c_,4)
g.connect(R_,2,U_,1)
g.connect(R_,3,D_,1)

# U tensor
g.connect(U_,2,OA_,0)
g.connect(U_,3,A_,1)
g.connect(U_,4,a_,1)
g.connect(U_,5,B_,1)
g.connect(U_,6,b_,1)
g.connect(U_,7,C_,1)
g.connect(U_,8,c_,1)

# D tensor
g.connect(D_,2,OA_,1)
g.connect(D_,3,A_,3)
g.connect(D_,4,a_,3)
g.connect(D_,5,B_,3)
g.connect(D_,6,b_,3)
g.connect(D_,7,C_,3)
g.connect(D_,8,c_,3)

# O tensor
g.connect(OA_,3,A_,0)
g.connect(OA_,4,a_,0)
g.connect(OB_,2,B_,0)
g.connect(OB_,3,b_,0)
g.connect(OC_,1,C_,0)
g.connect(OC_,2,c_,0)
g.connect(OA_,2,OB_,0)
g.connect(OB_,1,OC_,0)

# A tensor, A* tensor
g.connect(A_,4,B_,2)
g.connect(a_,4,b_,2)
g.connect(B_,4,C_,2)
g.connect(b_,4,c_,2)

node_ids = {}
for name in ["U","L","D","R","OA","OB","OC","A","B","C"]:
    node_ids[name] = vars()[name+"_"]

for name, variables, other_nodes, ordering in [
    ("matvec_B", ["U","L","D","R","OA","OB","OC","A","B","C"], [a_,c_], None),
    ("absorb_up", ["U", "OA", "OB", "OC", "A", "B", "C"], [a_, b_, c_], [L_, R_, D_]),
    ]:
        setattr(self,"three_site_"+name,compile_graph(
            g,
            [node_ids[name] for name in variables] + other_nodes,
            variables,
            node_ordering=ordering,
            function_name=name
            )
        )

s = Subgraph(g)
for i in xrange(len(g.nodes)):
    s.add_node(i)
self.three_site_expectation_value = s.merge_all().matrices[0].compile_with_name("expectation_value","U","L","D","R","OA","OB","OC","A","B","C")

del s, g, i

del U,L,D,R,A,U_,L_,D_,R_,A_,a_,B_,b_,C_,c_

</t>
<t tx="cog.20080210171852.132">def absorb_row(self,direction,normalizer_left_boundary,normalizer_right_boundary,X):
    assert direction == UP

    self.one_site_up_boundary = self.one_site_absorb_up(self.one_site_up_boundary,self.system.site_matrix
    ).reshape(
        self.one_site_up_boundary.shape[0]*self.system.site_matrix.shape[2]**2,
        self.one_site_up_boundary.shape[1]*self.system.site_matrix.shape[4]**2,
        self.system.site_matrix.shape[3],
        self.system.site_matrix.shape[3],
    )

    self.one_site_up_boundary = multiply_tensor_by_matrix_at_index(self.one_site_up_boundary,X.transpose(),0)
    self.one_site_up_boundary = multiply_tensor_by_matrix_at_index(self.one_site_up_boundary,X.conj().transpose(),1)

    self.two_site_up_boundary = self.two_site_absorb_up(self.two_site_up_boundary,self.two_site_operator_A,self.two_site_operator_B,self.system.site_matrix,self.system.site_matrix,
    ).reshape(
        self.two_site_up_boundary.shape[0]*self.system.site_matrix.shape[2]**2,
        self.two_site_up_boundary.shape[1]*self.system.site_matrix.shape[4]**2,
        self.two_site_operator_A.shape[0],
        self.system.site_matrix.shape[3],
        self.system.site_matrix.shape[3],
        self.system.site_matrix.shape[3],
        self.system.site_matrix.shape[3],
    )

    self.two_site_up_boundary = multiply_tensor_by_matrix_at_index(self.two_site_up_boundary,X.transpose(),0)
    self.two_site_up_boundary = multiply_tensor_by_matrix_at_index(self.two_site_up_boundary,X.conj().transpose(),1)

    self.three_site_up_boundary = self.three_site_absorb_up(
        self.three_site_up_boundary,
        self.three_site_operator_A,
        self.three_site_operator_B,
        self.three_site_operator_C,
        self.system.site_matrix,
        self.system.site_matrix,
        self.system.site_matrix,
    ).reshape(
        self.three_site_up_boundary.shape[0]*self.system.site_matrix.shape[2]**2,
        self.three_site_up_boundary.shape[1]*self.system.site_matrix.shape[4]**2,
        self.three_site_operator_A.shape[0],
        self.system.site_matrix.shape[3],
        self.system.site_matrix.shape[3],
        self.system.site_matrix.shape[3],
        self.system.site_matrix.shape[3],
        self.system.site_matrix.shape[3],
        self.system.site_matrix.shape[3],
    )

    self.three_site_up_boundary = multiply_tensor_by_matrix_at_index(self.three_site_up_boundary,X.transpose(),0)
    self.three_site_up_boundary = multiply_tensor_by_matrix_at_index(self.three_site_up_boundary,X.conj().transpose(),1)

    self.replace_boundaries_with(normalizer_left_boundary,normalizer_right_boundary)

    self.update_multiplication_functions()


</t>
<t tx="cog.20080210171852.133">def absorb_site(self,direction):
    assert direction == LEFT or direction == RIGHT
    if self.matvecs_to_ignore &gt; 0:
        self.matvecs_to_ignore -= 1
    if direction == RIGHT and self.ignore_next_right_absorb:
        self.right_boundary = self.one_site_absorb_into_right_boundary(
            self.one_site_up_boundary,
            self.one_site_down_boundary,
            self.right_boundary,
            self.system.site_matrix
            )
        self.ignore_next_right_absorb = False
    elif direction == LEFT and self.ignore_next_left_absorb:
        self.left_boundary = self.one_site_absorb_into_left_boundary(
            self.one_site_up_boundary,
            self.left_boundary,
            self.one_site_down_boundary,
            self.system.site_matrix
            )
        self.ignore_next_left_absorb = False
    elif self.number_of_active_sites == 3:
        assert self.B is None
        if direction == LEFT:
            self.left_boundary = self.two_site_absorb_into_left_boundary(
                self.two_site_up_boundary,
                self.left_boundary,
                self.two_site_down_boundary,
                self.two_site_operator_A,
                self.two_site_operator_B,
                self.A,
                self.system.site_matrix
                )
            self.A = None
            self.B = self.C
        else:
            self.right_boundary = self.two_site_absorb_into_right_boundary(
                self.two_site_up_boundary,
                self.two_site_down_boundary,
                self.right_boundary,
                self.two_site_operator_A,
                self.two_site_operator_B,
                self.system.site_matrix,
                self.C
                )
            self.B = None
        del self.C
        self.number_of_active_sites = 2
    elif self.number_of_active_sites == 1:
        if direction == LEFT:
            self.A = self.system.site_matrix.copy()
            self.B = None
        else:
            self.A = None
            self.B = self.system.site_matrix.copy()
        self.number_of_active_sites = 2
    else:
        assert self.number_of_active_sites == 2
        if self.A is None:
            assert self.B is not None
            if direction == LEFT:
                self.A = self.system.site_matrix.copy()
                self.C = self.B
                self.B = None
                self.number_of_active_sites = 3
            else:
                self.right_boundary = self.two_site_absorb_into_right_boundary(
                    self.two_site_up_boundary,
                    self.two_site_down_boundary,
                    self.right_boundary,
                    self.two_site_operator_A,
                    self.two_site_operator_B,
                    self.system.site_matrix,
                    self.B
                )
                self.number_of_active_sites = 1
                del self.A
                del self.B
        else:
            assert self.B is None
            if direction == RIGHT:
                self.C = self.system.site_matrix.copy()
                self.number_of_active_sites = 3
            else:
                self.left_boundary = self.two_site_absorb_into_left_boundary(
                    self.two_site_up_boundary,
                    self.left_boundary,
                    self.two_site_down_boundary,
                    self.two_site_operator_A,
                    self.two_site_operator_B,
                    self.A,
                    self.system.site_matrix
                )
                self.number_of_active_sites = 1
                del self.A
                del self.B

</t>
<t tx="cog.20080210171852.134">def absorb_unitary(self,unitary):

    if self.number_of_active_sites == 1:
        self.left_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary,0)
        self.left_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary.conj(),1)
        self.right_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary.conj(),0)
        self.right_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary,1)
    elif self.number_of_active_sites == 3:
        self.A = multiply_tensor_by_matrix_at_index(self.A,unitary,4)
        self.C = multiply_tensor_by_matrix_at_index(self.C,unitary.conj(),2)
    else:
        assert self.number_of_active_sites == 2
        if self.A is None:
            self.left_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary,0)
            self.left_boundary = multiply_tensor_by_matrix_at_index(self.left_boundary,unitary.conj(),1)
            self.B = multiply_tensor_by_matrix_at_index(self.B,unitary.conj(),2)
        else:
            assert self.B is None
            self.A = multiply_tensor_by_matrix_at_index(self.A,unitary,4)
            self.right_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary.conj(),0)
            self.right_boundary = multiply_tensor_by_matrix_at_index(self.right_boundary,unitary,1)
    horizontal_boundary_shape = list(self.left_boundary.shape)
    horizontal_boundary_shape[0] = horizontal_boundary_shape[1] = self.system.shape_of_site_matrix[2]
    self.update_multiplication_functions(tuple(horizontal_boundary_shape))


</t>
<t tx="cog.20080210171852.135">def replace_boundaries_with(self,normalizer_left_boundary,normalizer_right_boundary):
    self.number_of_active_sites = 1

    self.ignore_next_left_absorb = self.ignore_first_left
    self.ignore_next_right_absorb= self.ignore_first_right
    self.matvecs_to_ignore = 2 if self.ignore_first_two_matvecs else 0

    horizontal_boundary_shape = copy(normalizer_left_boundary.shape)
    horizontal_boundary_shape[-1] *= 2

    self.left_boundary = multiply.outer(normalizer_left_boundary,array([1,0])).reshape(horizontal_boundary_shape)
    self.right_boundary = multiply.outer(normalizer_right_boundary,array([0,1])).reshape(horizontal_boundary_shape)
</t>
<t tx="cog.20080210172454">def draw_port_blend(number_of_ports,heights,slider,alpha=1):
    if slider &gt; 0:
        draw_ports(0,heights,slider*alpha)
        draw_ports_automatically_separated(number_of_ports,(1-slider)*alpha)
    else:
        draw_ports_automatically_separated(number_of_ports,alpha)
</t>
<t tx="cog.20080210173147">class ResultCache:
    @others
</t>
<t tx="cog.20080210173147.1">def __init__(self,system,increment_list={}):
    self.system = system
    self.matrices = {}
    self.unnormalized_matrices = {}
    self.old_matrices = {}
    self.energy_agreements = {}
    self.site_agreements = {}
    self.energy_residuals = {}
    self.energies = {}
    self.total_energies = {}
    self.increment_list = increment_list
    self.last_direction = +1
    self.last_index = -1
    self.system_size = 0
</t>
<t tx="cog.20080210173147.2">def get_matrix(self,index):
    self.ensure_in_cache(index)
    try:
        return self.matrices[index]
    except KeyError:
        print self.matrices.keys()
        raise


def get_unnormalized_matrix(self,index):
    self.ensure_in_cache(index)
    return self.unnormalized_matrices[index]

def get_old_matrix(self,index):
    self.ensure_in_cache(index)
    return self.old_matrices[index]
</t>
<t tx="cog.20080210173147.3">def ensure_in_cache(self,requested_index):
    if self.last_index &gt;= requested_index:
        return

    while self.last_index &lt; requested_index:
        self.last_index += 1
        self.last_direction *= -1
        self.system_size += 1

        self.system.single_site_run(self.last_direction)

        self.matrices[self.last_index] = self.system.site_matrix.copy()
        self.unnormalized_matrices[self.last_index] = self.system.unnormalized_site_matrix.copy()

        self.total_energies[self.last_index] = system.compute_energy()
        self.energies[self.last_index] = infinite_energy_limit(self.matrices[self.last_index])
        self.energy_residuals[self.last_index] = -log(infinite_energy_residual(self.energies[self.last_index]))/log(10)

        if self.last_index &gt; 0:
            #self.energies[self.last_index] = self.total_energies[self.last_index]-self.total_energies[self.last_index-1]
            #self.energy_residuals[self.last_index] = -log(infinite_energy_residual(self.energies[self.last_index]))/log(10)
            self.site_agreements[self.last_index]  = -log(norm(self.unnormalized_matrices[self.last_index]-self.unnormalized_matrices[self.last_index-1]))/log(10)

        if self.last_index &gt; 1:
            self.energy_agreements[self.last_index] = -log(abs(self.energies[self.last_index]-self.energies[self.last_index-1]))/log(10)

        if self.last_index in self.increment_list:
            self.old_matrices[self.last_index+10] = self.matrices[self.last_index]
            self.old_matrices[self.last_index+ 9] = self.matrices[self.last_index-1]
            unitary = self.system.increase_auxiliary_dimension_by(self.increment_list[self.last_index])
            self.matrices[self.last_index+10] = multiply_tensor_by_matrix_at_index(self.matrices[self.last_index],unitary.conj(),1)
            self.matrices[self.last_index+ 9] = multiply_tensor_by_matrix_at_index(self.matrices[self.last_index-1],unitary,2)

            self.unnormalized_matrices[self.last_index+10] = multiply_tensor_by_matrix_at_index(self.unnormalized_matrices[self.last_index],unitary.conj(),1)
            self.unnormalized_matrices[self.last_index+10] = multiply_tensor_by_matrix_at_index(self.unnormalized_matrices[self.last_index+10],unitary,2)

            self.site_agreements[self.last_index+10] = self.site_agreements[self.last_index]
            self.energy_agreements[self.last_index+10] = self.energy_agreements[self.last_index]
            self.energy_residuals[self.last_index+10] = self.energy_residuals[self.last_index]
            self.energies[self.last_index+10] = self.energies[self.last_index]
            self.energies[self.last_index+10] = self.total_energies[self.last_index]

            #self.site_agreements[self.last_index+9] = self.site_agreements[self.last_index-1]
            #self.energy_agreements[self.last_index+9] = self.energy_agreements[self.last_index-1]
            #self.energy_residuals[self.last_index+9] = self.energy_residuals[self.last_index-1]

            self.last_index += 10

</t>
<t tx="cog.20080210174137">def increase_to_reflect_chi(old_chi,new_chi,period=1):
    def update_index(index_list):
        old_indices = get(index_list)
        set(index_list,[old_indices[0]+10]+old_indices[1:])

    update_index(visualizer.left_matrix_indices)
    update_index(visualizer.right_matrix_indices)
    set(visualizer.old_slider,1)

    port_shuffle = range(new_chi)
    shuffle(port_shuffle)
    port_shuffle = array(port_shuffle[:old_chi])

    set(visualizer.old_shuffled_ports,port_shuffle)

    linear(period,visualizer.old_slider,0)
    set(visualizer.old_shuffled_ports,[])

    for meter in meters:
        set(meter.new_index,get(meter.new_index)+10)
        set(meter.slider,1)


</t>
<t tx="cog.20080210174231">speed = 0.5

for index in xrange(20,40):
    run_site(direction,index,1/speed,4)
    direction *= -1
    speed += 0.2

pause()
</t>
<t tx="cog.20080210180641">increase_to_reflect_chi(4,6)

pause()

speed = 1

for index in xrange(50,80):
    run_site(direction,index,1/speed,6,window=3)
    if speed &lt; 3:
        speed += 0.1
    direction *= -1

pause()
</t>
<t tx="cog.20080210180720">cache = ResultCache(system,increment_list={9:2,39:2,79:4,119:5})

visualizer = Drawable(get_camera(),draw_visualizer,cache=cache,unnormalized_shuffled_ports=array([1,0]),unnormalized_slider=1,_alpha=0)

meters = []
</t>
<t tx="cog.20080210182247">def draw_meter(
        fetcher=(OBJECT,None),
        old_index=(INTEGER,0,10000,0),
        new_index=(INTEGER,0,10000,1),
        slider=(SCALAR,0,1,0),
        label=(STRING,""),
    ):
    set_camera(Rect(0,0,width=2,height=2,anchor="s"))

    if slider == 1:
        value = fetcher(new_index)
    elif slider == 0:
        value = fetcher(old_index)
    else:
        value = fetcher(old_index)*(1-slider) + fetcher(new_index)*slider

    color(white)
    rectangle(-0.45,1,0.45,1+value/10)

    color(yellow)
    text(0,0.65,"%.2f"%value,fonts["big"],anchor="sc",size=0.25)
    text(0,0.40,"Digits",fonts["big"],anchor="nc",size=0.20)
    text(0,0.20,label,fonts["big"],anchor="nc",size=0.20)
</t>
<t tx="cog.20080210182948">meter_spots = get_camera().bottom(1/3).xsplit(1,1,1)

meters = [None,None,None]

meters[0] = Drawable(
    meter_spots[0].inset(0.1).restrict_aspect(1),
    draw_meter,
    label="Site Agreement",
    fetcher=cache.get_site_agreement,
    old_index=2,
    new_index=3,
    slider=1,
    _alpha=0
    )
meters[1] = Drawable(
    meter_spots[1].inset(0.1).restrict_aspect(1),
    draw_meter,
    label="Energy Agreement",
    fetcher=cache.get_energy_agreement,
    old_index=2,
    new_index=3,
    slider=1,
    _alpha=0
    )
meters[2] = Drawable(
    meter_spots[2].inset(0.1).restrict_aspect(1),
    draw_meter,
    label="Energy Residual",
    fetcher=cache.get_energy_residual,
    old_index=2,
    new_index=3,
    slider=1,
    _alpha=0
    )

enter(*meters)

for meter in meters:
    fade_in(0.5,meter)

    pause()
</t>
<t tx="cog.20080210185340">def get_site_agreement(self,index):
    self.ensure_in_cache(index)
    return self.site_agreements[index]

def get_energy_agreement(self,index):
    self.ensure_in_cache(index)
    return self.energy_agreements[index]

def get_energy_residual(self,index):
    self.ensure_in_cache(index)
    return self.energy_residuals[index]
</t>
<t tx="cog.20080210194351">for index in xrange(4,10):
    run_site(direction,index,2)
    direction *= -1

pause()
</t>
<t tx="cog.20080210203604">increase_to_reflect_chi(6,10,2)

pause()

smooth(1,visualizer.height,1.5)

pause()

speed = 0.5

for index in xrange(90,120):
    run_site(direction,index,1/speed,10,window=4)
    if speed &lt; 2:
        speed += 0.1
    direction *= -1

pause()
</t>
<t tx="cog.20080210205214">increase_to_reflect_chi(10,15,3)

pause()

smooth(1,visualizer.height,2)

pause()

speed = 0.3

for index in xrange(130,160):
    run_site(direction,index,1/speed,15,window=5)
    if speed &lt; 1.5:
        speed += 0.1
    direction *= -1

pause()
</t>
<t tx="cog.20080210214303">def draw_qubit(
        angle=(SCALAR,0,360,0),
        qubit_scale=(SCALAR,1,2,1),
    ):
    set_camera(Rect(0,0,width=1.75,height=1.75))

    def draw_qubit():
        push()
        rotate(-angle)
        scale(qubit_scale,qubit_scale)
        widestroke(qubit,0.1)
        arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))
        pop()

    draw_with_shadows(0,0,0.05,draw_qubit,white)
</t>
<t tx="cog.20080210214303.1">def draw_connector(
        angle=(SCALAR,0,360,0),
        width=(SCALAR,0,1,0.5)
    ):
    set_camera(Rect(0,0,width=4,height=1.5))

    angle = angle % 360
    if angle &gt; 180:
        angle = 360 - angle

    color(hsv(angle/180*(1/3),1,1))
    thickness(width)
    line(-1.5,0,1.5,0)

    color(port_fill_color)
    dot(0.5,-1.5,0)
    dot(0.5,+1.5,0)
    thickness(0.05)
    color(black)
    circle(0.4,-1.5,0)
    circle(0.4,+1.5,0)

</t>
<t tx="cog.20080210214408"></t>
<t tx="cog.20080210214717">title = Text(get_camera().top(1/4).inset(0.1),text="Qubit Color Coding",color=yellow,font=fonts["title"],size=24,justify=0.5,vjustify=0.5,_alpha=0)

splits = get_camera().bottom(3/4).ysplit(0.1,1,0.1,1,0.1,1,0.1)
thirds = [splits[1],splits[3],splits[5]]

qubit1 = Drawable(thirds[0].left(1/3).restrict_aspect(1),draw_qubit,_alpha=0)
connector1 = Drawable(thirds[0].right(2/3).inset(0.2).restrict_aspect(4/1.5),draw_connector,_alpha=0)

qubit2 = Drawable(thirds[1].left(1/3).restrict_aspect(1),draw_qubit,angle=180,_alpha=0)
connector2 = Drawable(thirds[1].right(2/3).inset(0.2).restrict_aspect(4/1.5),draw_connector,angle=180,_alpha=0)

qubit3 = Drawable(thirds[2].left(1/3).restrict_aspect(1),draw_qubit,angle=90,_alpha=0)
connector3 = Drawable(thirds[2].right(2/3).inset(0.2).restrict_aspect(4/1.5),draw_connector,angle=90,_alpha=0)

start_animation(bg,title,qubit1,connector1,qubit2,connector2,qubit3,connector3)

pause()

fade_in(0.5,title)

pause()

parallel()
fade_in(0.5,qubit1)
fade_in(0.5,connector1)
end()

pause()

parallel()
fade_in(0.5,qubit2)
fade_in(0.5,connector2)
end()

pause()

parallel()
fade_in(0.5,qubit3)
fade_in(0.5,connector3)
end()

pause()

parallel()
linear(1,qubit1.angle,135)
linear(1,connector1.angle,135)
end()

pause()

parallel()
linear(1,qubit2.angle,135+180)
linear(1,connector2.angle,135+180)
end()

pause()

parallel()
linear(1,qubit3.angle,135+90)
linear(1,connector3.angle,135+90)
end()


pause()

parallel()
smooth(1,qubit1.qubit_scale,1.8)
smooth(1,connector1.width,.9)
smooth(1,qubit2.qubit_scale,0.5)
smooth(1,connector2.width,0.25)
end()

pause()

parallel()
smooth(1,qubit1.qubit_scale,0.75)
smooth(1,connector1.width,0.375)
smooth(1,qubit3.qubit_scale,1.5)
smooth(1,connector3.width,0.625)
end()

pause()

parallel()
fade_out(0.5,title)
fade_out(0.5,qubit1)
fade_out(0.5,qubit2)
fade_out(0.5,qubit3)
fade_out(0.5,connector1)
fade_out(0.5,connector2)
fade_out(0.5,connector3)
end()

visualization_guide = end_animation()
</t>
<t tx="cog.20080210222140">title = Text(get_camera().top(1/4).inset(0.1),text="Transverse Ising Model",color=yellow,font=fonts["title"],size=24,justify=0.5,vjustify=0.5,_alpha=0)

leftover = get_camera().bottom(3/4)

tim = Image(leftover.top(2/3).inset(0.2),image=load_image("tim.png"),fit=HEIGHT,_alpha=0)

lam = Image(leftover.bottom(1/3).inset(1/3),image=load_image("lam.png"),fit=HEIGHT,_alpha=0)

start_animation(bg,title,tim,lam)

pause()

fade_in(0.5,title)

pause()

fade_in(0.5,tim)

pause()

fade_in(0.5,lam)

pause()

parallel()
fade_out(0.5,title)
fade_out(0.5,tim)
fade_out(0.5,lam)
end()

tim_slide = end_animation()
</t>
<t tx="cog.20080210223736">@
Absorb the environment into the ubertensor.
@c

set(W_state_wirings.outer_stuff_visible,False)
smooth(1,W_state_wirings.environment_absorbtion_slider,1)

pause()

smooth(0.5,W_state_wirings.index_merge_slider,1)

pause()

fade_out(0.5,W_state_wirings)
</t>
<t tx="cog.20080210225424">if not outer_stuff_visible:
    draw_centered_rectangle(0,-2.375,0.75,0.75,white,grey)
    color(dark_blue,1-environment_absorbtion_slider)
    text(0,-2.375,"H",font=fonts["big"],size=0.5)
    color(dark_blue,environment_absorbtion_slider)
    text(0,-2.375,"Optimization\nMatrix",font=fonts["big"],size=0.125,anchor="cc",justify=0.5)
</t>
<t tx="cog.20080210233155">def title_slide():
    junk, title_v, junk, url_v = get_camera().ysplit( 1, 3, 1, 3 )
    title = Text( title_v.inset( 0.1 ), text = 'Cutting infinite systems down to size with matrix product states', size = 30,
                  font = fonts['title'], color = white, justify = 0.5, vjustify = 0.5, _alpha = 0.0 )
    url = Text( url_v.inset( 0.1 ), text = 'Gregory Crosswhite\nUniversity of Washington, Seattle', size = 14,
                font = fonts['title'], color = 0.8, justify = 0.5, vjustify = 0.5, _alpha = 0.0 )

    logo_v = viewport.interp(get_camera(),get_camera().inset(0.25).move_down(0.25).move_left(.025),_alpha=0)

    logo_animation = Anim(logo_v)

    start_animation( bg, title, url, logo_animation )

    pause()

    logo_animation.fade_in_start(animate_logo,0.5)    
    logo_animation.play(animate_logo)

    parallel()

    smooth(1,logo_v.x,1)

    serial()
    wait(0.5)
    fade_in( 1, title, url )
    end()

    end()

    pause()

    fade_out( 0.5, title, url, logo_animation )

    return end_animation()
title_slide = title_slide()

</t>
<t tx="cog.20080210233638">def logo_slide():
    logo_animation = Anim(get_camera())

    start_animation(bg,logo_animation)

    pause()

    logo_animation.fade_in_start(animate_logo,0.5)

    wait(0.5)

    logo_animation.play(animate_logo)

    wait(0.5)

    logo_animation.fade_out_end(animate_logo,0.5)

    return end_animation()
logo_slide = logo_slide()
</t>
<t tx="cog.20080210235708">def grey_slide():
    grey_square = Fill(color=grey,color2=grey,_alpha=0)

    start_animation(bg,grey_square)

    pause()

    fade_in(0.5, grey_square)

    pause()

    fade_out(0.5, grey_square)

    return end_animation()
grey_slide = grey_slide()
</t>
<t tx="cog.20080211000339">def outline_slide():
    r = get_camera().top( 0.2 ).bottom( 0.85 ).inset( 0.05 )
    title = Text( r, text = 'Overview', font = fonts['title'], size = 30, justify = 0.0,
                  color = yellow, _alpha = 0 )
    r = get_camera().bottom( 0.85 ).inset( 0.05 )
    bl = BulletedList( r, font = fonts['roman'], color = white,
                       bullet = [fonts['dingbats'], 'w'],
                       size = 18 )

    start_animation( bg, title, bl )

    pause()

    fade_in(0.5,title)

    pause()
    bl.add_item( 0, [fonts['fancy'],'Finding the ground state of an infinite systems!'] )
    pause()
    bl.add_item( 0, ['Intuitive physical picture of algorithm'] )
    pause()
    bl.add_item( 0, ['Matrix product states'] )
    pause()
    bl.add_item( 1, ['Motivation: Signal exchange picture'] )
    pause()
    bl.add_item( 1, ['Mathematical formalism'] )
    pause()
    bl.add_item( 1, ['Expectation values --&gt; Relaxation'] )
    pause()
    bl.add_item( 0, ['Results'] )
    pause()
    bl.add_item( 1, ['Transverse Ising Model'] )
    pause()
    bl.add_item( 1, ['Haldane-Shastry Model'] )
    pause()

    parallel()
    fade_out(0.5,bl)
    fade_out(0.5,title)
    end()
    return end_animation()
outline_slide = outline_slide()
</t>
<t tx="cog.20080211004454">def results_slide():
    title1 = Text( get_camera().move_down(.005).move_right(.005), text = 'Results', size = 64,
                  font = fonts['big'], color = black, justify = 0.5, vjustify = 0.4, _alpha = 0.0 )
    title2 = Text( get_camera().move_up(.005).move_left(.005), text = 'Results', size = 64,
                  font = fonts['big'], color = yellow, justify = 0.5, vjustify = 0.4, _alpha = 0.0 )

    start_animation( bg, title1, title2 )

    pause()

    fade_in(0.5,title1,title2)

    pause()

    fade_out(0.5,title1,title2)

    return end_animation()
results_slide = results_slide()
</t>
<t tx="cog.20080211004535">def remarks_slide():
    r = get_camera().top( 0.2 ).bottom( 0.85 ).inset( 0.05 )
    title = Text( r, text = 'Remarks', font = fonts['title'], size = 30, justify = 0.0,
                  color = yellow, _alpha = 0 )
    r = get_camera().bottom( 0.85 ).inset( 0.05 )
    bl = BulletedList( r, font = fonts['roman'], color = white,
                       bullet = [fonts['dingbats'], 'w'],
                       size = 18 )

    start_animation( bg, title, bl )

    pause()

    fade_in(0.5,title)

    pause()
    bl.add_item( 0, ['Algorithm is similar in spirit to DMRG'] )
    pause()
    bl.add_item( 1, ['K. Ueda, T. Nishino, K. Okunishi, Y. Hieida, R. Derian and A. Gendiar. Journal of the Physical Society of Japan. 75, no. 1, (2006): 14003'] )
    pause()
    bl.add_item( 0, ['Differences'] )
    pause()
    bl.add_item( 1, ['Infinite systems modeled directly'] )
    pause()
    bl.add_item( 1, ['Translationally invariance built-in'] )
    pause()
    bl.add_item( 1, ['Handles (factorizeable) long-range interactions'] )
    pause()
    bl.add_item( 1, ['Directly applied to 1D quantum systems'] )
    pause()
    bl.add_item( 1, ['Extendable to 2D quantum systems (in progress)'] )
    pause()

    parallel()
    fade_out(0.5,bl)
    fade_out(0.5,title)
    end()
    return end_animation()
remarks_slide = remarks_slide()
</t>
<t tx="cog.20080211004821">title = Text(get_camera().top(1/8).inset(0.1),text="Haldane-Shastry Model",color=yellow,font=fonts["title"],size=24,justify=0.5,vjustify=0.5,_alpha=0)

leftover = get_camera().bottom(7/8)

hsm = Image(leftover.inset(0.1),image=load_image("hsm.png"),fit=WIDTH,_alpha=0)

correlators = Image(get_camera().bottom(7/8),image=load_image("correlators.png"),fit=HEIGHT,_alpha=0)

start_animation(bg,title,hsm,correlators)

pause()

fade_in(0.5,title)

pause()

fade_in(0.5,hsm)

pause()

fade_in(0.5,correlators)

#set(title._alpha,0)
set(hsm._alpha,0)

pause()

fade_out(0.5,title,correlators)

hsm_slide = end_animation()
</t>
<t tx="cog.20080211012358">def conclusions_slide():
    r = get_camera().top( 0.2 ).bottom( 0.85 ).inset( 0.05 )
    title = Text( r, text = 'Morals', font = fonts['title'], size = 30, justify = 0.0,
                  color = yellow, _alpha = 0 )
    r = get_camera().bottom( 0.85 ).inset( 0.05 )
    bl = BulletedList( r, font = fonts['roman'], color = white,
                       bullet = [fonts['dingbats'], 'w'],
                       size = 18 )

    start_animation( bg, title, bl )

    pause()

    fade_in(0.5,title)

    pause()
    bl.add_item( 0, ['Physical picture of relaxation --&gt; variational algorithm'] )
    pause()
    bl.add_item( 0, ['Matrix product states allow global entanglement properties to be described locally.'] )
    pause()
    bl.add_item( 0, ["This works in part because it formalizes our own intuitive pictures."] )
    pause()

    return end_animation()
conclusions_slide = conclusions_slide()
</t>
<t tx="gcross.20080205144016.1"></t>
<t tx="gcross.20080205144112">import fonts

from slithy.presentation import *

print "Engaging engines at warp 10..."
print "\t FAILED!  Physically impossible;  attempting warp 9..."

from slides import title_slide, grey_slide, logo_slide, outline_slide, crazy_interaction_animation, results_slide, tim_slide, visualization_guide, demonstration, hsm_slide, remarks_slide, conclusions_slide

play(title_slide)

play(grey_slide)

play(logo_slide)

play(outline_slide)

play(crazy_interaction_animation)

play(results_slide)

play(tim_slide)

play(visualization_guide)

play(demonstration)

play(hsm_slide)

play(remarks_slide)

play(conclusions_slide)

run_presentation()

</t>
<t tx="gcross.20080205145843">color(white,center_rectangle_alpha)
thickness(0.01)
frame(-0.5,-1.75,0.5,1.75)
</t>
<t tx="gcross.20080205150700">if middle_alpha &gt; 0:
    configuration = [-1,1,1,-1,-1]

    push()
    translate(-2,0)
    for i in xrange(5):

        push()

        translate(0,configuration[i]*0.075)

        scale(0.75,configuration[i]*0.75)

        push()
        color(black,middle_alpha)
        translate(0.03,-configuration[i]*0.03)
        widestroke(qubit,0.1)
        arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))
        pop()

        color(white,middle_alpha)
        widestroke(qubit,0.1)
        arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))

        pop()

        translate(1,0)
    pop()
</t>
<t tx="gcross.20080205151350">if horribly_wrong_alpha &gt; 0:
    color(red,horribly_wrong_alpha)
    thickness(0.1)
    line(-2.25,-0.6,2.25, 0.6)
    line(-2.25, 0.6,2.25,-0.6)
</t>
<t tx="gcross.20080205151538">@
Highlight the center site while fading away the outside sites and the caption.
@c

parallel()
fade_out(0.5,wheres_the_cat)
linear(0.5,wires.center_rectangle_alpha,1)
linear(0.5,wires.outer_alpha,0.25)
end()

exit(wheres_the_cat)

pause()
</t>
<t tx="gcross.20080205151651">@
Show an example of a wrong configuration.
@c

parallel()
linear(0.5,wires.center_rectangle_alpha,0)
linear(0.5,wires.center_site_alpha,0.25)
linear(0.5,wires.middle_alpha,1)
end()

pause()

@
Draw an X through this configuration.
@c

linear(0.5,wires.horribly_wrong_alpha,1)

pause()

@
Restore back to the original configuration.
@c

parallel()
linear(0.5,wires.horribly_wrong_alpha,0)
linear(0.5,wires.middle_alpha,0)
linear(0.5,wires.center_site_alpha,1)
linear(0.5,wires.outer_alpha,1)
end()

pause()

</t>
<t tx="gcross.20080205152554">if window &gt; 1.15001:
    @others

</t>
<t tx="gcross.20080205152804">push()
translate(-250,height)
for i in xrange(501):

    push()

    scale(0.75,0.75)

    push()
    color(black)
    translate(0.03,-0.03)
    widestroke(qubit,0.1)
    arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))
    pop()

    color(white)
    widestroke(qubit,0.1)
    arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))

    pop()

    translate(1,0)
pop()
</t>
<t tx="gcross.20080205152826">push()
scale(1,-1)
translate(-250,height)
for i in xrange(501):

    push()

    scale(0.75,0.75)

    push()
    color(black)
    translate(0.03,+0.03)
    widestroke(qubit,0.1)
    arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))
    pop()

    color(white)
    widestroke(qubit,0.1)
    arrow(qubit,(0,0.2,0.2),(1,0.2,0.2))

    pop()

    translate(1,0)
pop()
</t>
<t tx="gcross.20080205153207">@
Zoom out to emphasize how big the state is.
@c

exponential(9,wires.window,30,s=.03)

pause()

@
Now zoom back in... *but*, don't go all the way back, so that we can have a little bit of extra space for a margin on the sides.
@c

logarithmic(3,wires.window,1.15,s=30)

pause()
</t>
<t tx="gcross.20080205154433">from math import exp, log

class _LogarithmicTransition(TransitionStyle):
    def __init__( self, starttime, duration, start, end, params, type ):
        TransitionStyle.__init__( self, starttime, duration, start, end, params, type )
        self.s = params.get("s",10)
        self.l = log(1+self.s)

    def __call__( self, t ):
        if self.duration == 0.0:
            f = 1
        else:
            f = (t - self.starttime) / self.duration

        f = log(1+self.s * f)/self.l

        if hasattr( self, 'range' ):
            return self.start + self.range * f
        else:
            return self.start.interp( self.end, f )

Transition.styles["log"] = _LogarithmicTransition

logarithmic = Transition(style="log")
</t>
<t tx="gcross.20080205154455"></t>
<t tx="gcross.20080205160937">if dot_alpha &gt; 0:
    @others</t>
<t tx="gcross.20080206160516">color(yellow,matrix_index_labels_alpha)
text(-0.9,-0.5,"1",fonts["big"],size=0.3+0.1*row_1_highlight)
text(-0.9,-1.5,"2",fonts["big"],size=0.3+0.1*row_2_highlight)
text(-0.5,-2.15,"1",fonts["big"],size=0.2+0.05*row_1_highlight,anchor="cr")
text(-0.5,-2.55,"2",fonts["big"],size=0.2+0.05*row_2_highlight,anchor="cr")

color(0,1,1,matrix_index_labels_alpha)
text(+0.9,-0.5,"1",fonts["big"],size=0.3+0.1*column_1_highlight)
text(+0.9,-1.5,"2",fonts["big"],size=0.3+0.1*column_2_highlight)
text(-0.175,-1.8,"1",fonts["big"],size=0.2+0.05*column_1_highlight)
text(+0.175,-1.8,"2",fonts["big"],size=0.2+0.05*column_2_highlight)
</t>
<t tx="gcross.20080206160626">grey = Color(0.5,0.5,0.5)
port_fill_color = white.interp(grey,0.5)
</t>
<t tx="gcross.20080207161129">def draw_vector(top=(STRING,"1"),bottom=(STRING,"0")):
    set_camera(Rect(0,0,width=1,height=2))
    color(white)
    thickness(0.1)
    line(-0.25,1,-0.5,1,-0.5,-1,-0.25,-1)
    line(+0.25,1,+0.5,1,+0.5,-1,+0.25,-1)
    text(0, 0.5,top,fonts["big"],size=0.75)
    text(0,-0.5,bottom,fonts["big"],size=0.75)
</t>
<t tx="gcross.20080207161559">if vector_alpha &gt; 0:
    embed_object(Rect(0,-0.5,width=0.125,height=0.25),draw_vector,{},_alpha=vector_alpha)
    embed_object(Rect(0,-1.0,width=0.125,height=0.25),draw_vector,{"bottom":"1","top":"0"},_alpha=vector_alpha)
    embed_object(Rect(0,-1.5,width=0.125,height=0.25),draw_vector,{},_alpha=vector_alpha)

    embed_object(Rect(-0.175,-2.20,width=0.125,height=0.25),draw_vector,{},_alpha=vector_alpha) 
    embed_object(Rect(-0.175,-2.55,width=0.125,height=0.25),draw_vector,{"bottom":"0","top":"0"},_alpha=vector_alpha)    
    embed_object(Rect(+0.175,-2.20,width=0.125,height=0.25),draw_vector,{"bottom":"1","top":"0"},_alpha=vector_alpha) 
    embed_object(Rect(+0.175,-2.55,width=0.125,height=0.25),draw_vector,{},_alpha=vector_alpha)
</t>
<t tx="gcross.20080207163659">if operator_slider &gt; 0:

    push()
    color(black,operator_slider*diagram_alpha)
    translate(0.02,-0.02)
    for i in xrange(-1,2,1):
        text(i,-0.5,"I",fonts["bold"],size=0.3)
        text(i,-1.0,"Z",fonts["bold"],size=0.3)
        text(i,-1.5,"I",fonts["bold"],size=0.3)
    pop()

    color(white,operator_slider*diagram_alpha)
    for i in xrange(-1,2,1):
        text(i,-0.5,"I",fonts["bold"],size=0.3)
        text(i,-1.0,"Z",fonts["bold"],size=0.3)
        text(i,-1.5,"I",fonts["bold"],size=0.3)


</t>
<t tx="gcross.20080207164423">@
Show that this also lets us get a formulation of the W operator.
@c

linear(0.5,W_state_wirings.operator_slider,1)

pause()

</t>
</tnodes>
</leo_file>
